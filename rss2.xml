<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Howard&#39;s nest</title>
    <link>https://howardhowonyu.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 08 Jun 2020 07:09:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>회귀분석 프로젝트</title>
      <link>https://howardhowonyu.github.io/2020/04/23/regression-project/</link>
      <guid>https://howardhowonyu.github.io/2020/04/23/regression-project/</guid>
      <pubDate>Thu, 23 Apr 2020 07:53:59 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;craiglist-데이터를-활용한-미국-중고차-가격-예측&quot;&gt;Craiglist 데이터를 활용한 미국 중고차 가격 예측&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Kaggle 데이터셋 중 &amp;quot;Craiglist(미국판 중고나라?)&amp;quot;에서 크롤링된 약 51만건의 중고차 가격 정보를 이용하여 &lt;strong&gt;중고차 가격 예측 프로젝트&lt;/strong&gt;를 진행하였습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;footer&gt;&lt;strong&gt;Craiglist 데이터를 활용한 미국 중고차 가격 예측&lt;/strong&gt;&lt;cite&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS91c2VkY2FyX3JlZ3Jlc3Npb25fcHJvamVjdC9ibG9iL2hvd2FyZC9ob3dhcmQvdXNlZF9jYXJfcmVncmVzc2lvbl9maW5hbC5pcHluYg==&quot; title=&quot;https://nbviewer.jupyter.org/github/HowardHowonYu/usedcar_regression_project/blob/howard/howard/used_car_regression_final.ipynb&quot;&gt;notebook 바로가기&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;전반적인 회귀분석 과정은 위의 링크를 참조해 주시고, 이곳에선 진행과정에서 겪은 여러 &lt;strong&gt;시행착오들과 note에 담지 못한 후기등을 공유&lt;/strong&gt;하고자 합니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="craiglist-데이터를-활용한-미국-중고차-가격-예측">Craiglist 데이터를 활용한 미국 중고차 가격 예측</h1><ul><li>Kaggle 데이터셋 중 &quot;Craiglist(미국판 중고나라?)&quot;에서 크롤링된 약 51만건의 중고차 가격 정보를 이용하여 <strong>중고차 가격 예측 프로젝트</strong>를 진행하였습니다.</li></ul><blockquote><footer><strong>Craiglist 데이터를 활용한 미국 중고차 가격 예측</strong><cite><span class="exturl" data-url="aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS91c2VkY2FyX3JlZ3Jlc3Npb25fcHJvamVjdC9ibG9iL2hvd2FyZC9ob3dhcmQvdXNlZF9jYXJfcmVncmVzc2lvbl9maW5hbC5pcHluYg==" title="https://nbviewer.jupyter.org/github/HowardHowonYu/usedcar_regression_project/blob/howard/howard/used_car_regression_final.ipynb">notebook 바로가기<i class="fa fa-external-link"></i></span></cite></footer></blockquote><ul><li>전반적인 회귀분석 과정은 위의 링크를 참조해 주시고, 이곳에선 진행과정에서 겪은 여러 <strong>시행착오들과 note에 담지 못한 후기등을 공유</strong>하고자 합니다. <a id="more"></a></li></ul><h2 id="review-내용">REVIEW 내용</h2><ul><li>데이터 전처리</li><li>범주형 데이터(Categorical data) 처리</li></ul><h2 id="workflow-chart">1. Workflow Chart</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/img12.png" width="1350px"></p><ul><li><p>크게 <strong>'EDA(데이터 탐색)', '데이터 전처리', '모델링', '모델검증'</strong>의 Step을 정하고 분석을 진행했습니다.</p></li><li><p>좌측부터 총 4번의 싸이클이 진행되었습니다.</p></li><li><p>시작부터 이런 구조를 만들어 낸것은 아니었고, 두번째 싸이클을 시작할때, 앞으로 생길 <strong>문제에 유연하게 대처하고, 다양한 방식을 시도해보기 용이한 방법을 고심</strong>하다 이와 같은 구조가 만들어 졌습니다.</p></li><li><p>분석 과정 중 <strong>한가지 방식에 매몰되지 않고 다양한 가능성을 상정하여, 최대한 여러 방면으로 생각을 확장하려 노력</strong>했고, 이점이 만족할만한 결과를 만들어낸 원동력이었다고 생각합니다.</p></li></ul><h2 id="데이터-전처리---vin차대번호를-활용하여..">2. 데이터 전처리 - Vin(차대번호)를 활용하여..</h2><ul><li>최초의 데이터는 결측치가 많았을뿐 아니라, 중고나라적 특성(?)을 가지고 있는 덕분에, 책정된 가격이 비정상적인 경우가 많았고(123456789, 99999.., 36억 달러 등), 주행거리 데이터도 상식적이지 않은 경우가 많았습니다.</li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img1.png" height="400px" withd="100%"></p><ul><li>첫 싸이클에선 도메인 지식을 활용하여, 가격, 주행거리를 제거하였지만 모델성능이 높지 않았고, 이때 <strong>'vin'</strong>이라는 데이터에 주목했습니다.</li></ul><h3 id="vin으로-허위매물-구별">2.1 Vin으로 허위매물 구별</h3><ul><li><p><strong>'vin'</strong>은 미국내에 운행되는 자동차들이 가지는 고유의 번호입니다. 이를 활용한다면 최소한 광고성 허위매물은 거를수 있을거라는 생각으로 Google을 검색합니다.</p></li><li><p>'Vincheck'를 필두로하여 다양한 'vin'을 검색하는 사이트들을 발견하였고, <strong>'이런 사이트에 &quot;vin&quot;을 검색해서 나오는 정보를 이용해 허위매물을 거르자!'</strong>라는 결론에 다다릅니다.</p></li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img2.png" height="300px" withd="100%"></p><h3 id="api-제공-데이터">2.2 api 제공 데이터</h3><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img3.png" height="400px" withd="100%"></p><ul><li>미국내 'vin'을 체크하는 사이트들은 모두 'vinaudit.com'이라는 업체가 제공하는 api를 사용하고 있었고, 이 api가 제공하는 데이터의 출처는<ul><li>자동차 이력 제공시스템 : (NMVTIS/National Motor Vehicle Title Information System)</li><li>미국 도로교통 안전국 : (NHTSA / National Highway Traffic Safety Administration)</li><li>미국 교통부 연방차량안전국 : (Federal Motor Carrier Safety Administration, FMCSA)</li><li>그외 미국 정부 기관과 관련된 업체 및 파트너사 라고 합니다.</li></ul></li><li><p>이 api에 'vin'을 던져주어 <strong>'error를 반환 받으면 == '허위매물'</strong> 이었기 때문에, 허위매물을 한번에 제거할수 있었습니다.</p></li><li><p>'vin'과 '주행거리'를 api에 옵션으로 던져주면, 현재 차량의 중고차 시장에서의 판매 가격에 대한, <strong>평균가격</strong>, <strong>표준편차</strong>, <strong>실제 주행거리</strong> 등을 반환해 주었습니다.</p></li><li><p>이를 이용해 '주행거리'와 '가격'에 대한 <strong>아웃라이어를 제거</strong>할수 있었습니다.</p></li><li><p>결정적으로 <strong>'실제 운행되고 존재하는 차량'에 관한 데이터</strong>라는걸 검증할수 있었습니다. 이후 분석은 데이터 전처리에 대한 고민없이 진행할수 있었습니다.</p></li></ul><h2 id="범주형-데이터-처리---변수-선택">3.1 범주형 데이터 처리 - 변수 선택</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img5.png" height="400px"></p><ul><li><p>데이터셋에는 <strong>실린더 갯수</strong>, <strong>변속기 자동 여부</strong>, <strong>차량종류</strong>등과 같이 <strong>차량의 '모델명'하나만으로 설명이 되는</strong> 범주형 변수가 많았습니다. <strong>'여러 범주형 변수'와 '모델명'</strong>을 어떻게 처리할지 고심했습니다.</p></li><li><p>결국 <strong>'여러 범주형 변수'를 선택하고 '모델명'변수는 삭제</strong>했습니다.</p></li><li><p>현대의 '아반떼' 라는 변수 하나만 남기고 나머지 범주형 변수를 삭제한다면, '201x년에 사셔서 X만 마일 타신 아반떼는 예상금액이 Y불 입니다' 라는 결론밖에 내지 못하고, <strong>중고차의 어떤 요소들이 가격 예측에 영향을 미쳤는지에 대한 파악을 하지 못하기 때문</strong>입니다.</p></li><li><p>또한, 여러가지 범주형 변수들과 '연식',' 주행거리'등과 같은 연속형 변수간의 Interaction을 통해 모델을 추가적으로 발전시킬수 있는 가능성도 사라지게 됩니다.</p></li></ul><h2 id="범주형-데이터-처리---교차-검증">3.2 범주형 데이터 처리 - 교차 검증</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img4.png" height="400px"></p><blockquote><p><span style="background:yellow;font-weight:800">종속 변수</span> <span style="background:pink;font-weight:800">연속형 변수</span> <span style="background:#ADD8E6;font-weight:800">범주형 변수</span></p></blockquote><ul><li><p>범주형 데이터는 학습데이터와 검증데이터를 나누는 과정에서도 문제가 되었습니다.</p></li><li><p>빈도수가 적은 (여기서는 페라리 같은 고급 차종들에 대한 데이터) 경우 Cross-validation(교차 검증)을 위해 데이터를 나누는 과정에서 한쪽으로 데이터가 쏠리는 경우가 발생하게 됩니다. 이렇게 되면 오류가 발생하게 됩니다.</p></li><li><p>처음엔 임의로 10개 미만의 빈도수를 가지는 데이터를 삭제하고 진행하는 방법, Bootstraping등의 방법을 시도하였습니다.</p></li><li><p>하지만 데이터를 최대한 살리는 방법을 선택해 결국, 빈도수 10개 미만의 데이터를 따로 분류하여, 데이터셋이 나누어 질때마다 각 데이터 셋에 고르게 분배될수 있도록 하였습니다.</p></li></ul><h2 id="후기">4. 후기</h2><ul><li>첫 회귀분석 프로젝트였던 만큼 시행착오가 많았지만, 그만큼 <strong>분석 주제와 목적에 대해 많이 고민</strong>할수 있었습니다.</li><li>향후 머신러닝, 딥러닝등 다양한 기법과 방법론을 학습하고 응용하겠지만 <strong>데이터의 본질을 이해하기 위한 노력</strong>이 선행될때, 이런 방법론들이 최상의 결과로 이어질수 있다는 점도 알게되었습니다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/04/23/regression-project/#disqus_thread</comments>
    </item>
    
    <item>
      <title>교차엔트로피와 쿨백-라이블러 발산</title>
      <link>https://howardhowonyu.github.io/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/</link>
      <guid>https://howardhowonyu.github.io/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/</guid>
      <pubDate>Mon, 23 Mar 2020 10:59:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;교차엔트로피cross-entropy&quot;&gt;교차엔트로피(cross entropy)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;두 확률분포 &lt;span class=&quot;math inline&quot;&gt;\(p,q\)&lt;/span&gt;의 교차엔트로피 &lt;span class=&quot;math inline&quot;&gt;\(H[p,q]\)&lt;/span&gt;의
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;이산확률분포의 경우는 &lt;span class=&quot;math display&quot;&gt;\[H[p,q] = - \sum_{k=1}^{K}p(y_k)log_2q(y_k)\]&lt;/span&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="교차엔트로피cross-entropy">교차엔트로피(cross entropy)</h3><ul><li>두 확률분포 <span class="math inline">\(p,q\)</span>의 교차엔트로피 <span class="math inline">\(H[p,q]\)</span>의<ul><li><p>이산확률분포의 경우는 <span class="math display">\[H[p,q] = - \sum_{k=1}^{K}p(y_k)log_2q(y_k)\]</span> <a id="more"></a></p></li><li>연속확률분포의 경우는 <span class="math display">\[H[p,q] = - \int_y p(y)log_2 q(y)dy\]</span></li></ul></li><li>교차엔트로피는 <strong>확률분포</strong> 를 인수로</li><li>엔트로피, 결합엔트로피, 조건부엔트로피는 <strong>확률변수</strong> 를 인수로</li><li><p><span class="math inline">\(q\)</span>가 <span class="math inline">\(p\)</span>(기준)를 얼마나 닮았는지를 나타낸다(유사도와는 다름)</p></li><li>교차엔트로피는 분류모형의 성능을 측정하는데 사용된다.</li><li>이진분류문제를 예로들면<ul><li><span class="math inline">\(p\)</span>는 <span class="math inline">\(X\)</span>값이 정해졌을 때 정답인 <span class="math inline">\(Y\)</span>의 확률분포다. 따라서 p는<ul><li>정답이 <span class="math inline">\(Y = 1\)</span>일때, <span class="math display">\[p(Y=0) = 0, p(y=1)=1\]</span></li><li>정답이 <span class="math inline">\(Y = 0\)</span>일때, <span class="math display">\[p(Y=0) = 1, p(y=1)=0\]</span></li></ul></li></ul></li><li><p>따라서 분포 <span class="math inline">\(q\)</span>는 <span class="math inline">\(X\)</span>값이 정해졌을때 예측값의 확률분포다. 모수가 <span class="math inline">\(\mu\)</span>인 베르누이분포라고 가정하면 <span class="math display">\[ q(Y=0) =1 - \mu, q(Y=1) = \mu\]</span></p></li><li><p>확률분포 <span class="math inline">\(p\)</span>와 <span class="math inline">\(q\)</span>의 교차엔트로피는</p><ul><li>정답이 <span class="math inline">\(Y = 1\)</span>일 때, <span class="math display">\[H[p,q] = -p(Y=0)log_2q(y=0) -p(Y=1)log_2q(y=1) = -log_2\mu\]</span></li><li><p>정답이 <span class="math inline">\(Y = 0\)</span>일 때, <span class="math display">\[H[p,q] = -p(Y=0)log_2q(y=0) -p(Y=1)log_2q(y=1) = -log_2(1-\mu)\]</span></p></li><li>이 값은 분류성능이 좋을수록 작아지고, 분류성능이 나쁠수록 커진다.<ul><li><span class="math inline">\(Y=1\)</span>일 때는 <span class="math inline">\(\mu\)</span>가 작아질수록 즉, 예측이 틀릴수록 <span class="math inline">\(-log_2\mu\)</span>의 값이 커진다</li><li><span class="math inline">\(Y=0\)</span>일 때는 <span class="math inline">\(\mu\)</span>가 작아질수록 즉, 예측이 틀릴수록 <span class="math inline">\(-log_2(1 - \mu)\)</span>의 값이 커진다</li></ul></li></ul></li><li>교차엔트로피값은 예측의 틀린 정도를 나타내는 오차함수의 역할을 할수 있다.</li><li>로그 손실 : <span class="math inline">\(N\)</span>개의 학습데이터 전체에 대해 교차 엔트로피의 평균을 구하면 <span class="math display">\[\text{log loss} = - {1\over 1}\sum_{i=1}^{N}(y_ilog_2\mu_i + (1 - y_i)log_2(1-\mu_i))\]</span></li><li>카테고리 로그손실 : 다중분류문제의 교차엔트로피의 손실함수 <span class="math display">\[\text{categorical log loss} = -{1\over N}\sum_{i=1}^{N}\sum_{k=1}^{K}(\mathbb{I}(y_i = k)log_2p(y_i=k))\]</span><ul><li>위 식에서 <span class="math inline">\(\mathbb{I}(y_i = k)\)</span>는 <span class="math inline">\(y_i\)</span>가 <span class="math inline">\(k\)</span>인 경우에만 1인 지시함수</li><li><span class="math inline">\(p(y_i=k)\)</span>는 <span class="math inline">\(y_i = k\)</span>일 확률이다</li></ul></li></ul><h3 id="쿨벡-라이블러-발산">쿨벡-라이블러 발산</h3><ul><li>두 확률분포 <span class="math inline">\(p(y),q(y)\)</span>의 <strong>분포모양이 얼마나 다른지를 숫자로 계산한 값</strong> 이다.</li><li><p>이산확률분포에 대해서는 <span class="math display">\[\begin{aligned}KL(p||q) &amp;= H[p,q] - H[p] \\ &amp;= \sum_{i=1}^{K} p(y_i) \log_2 \left(\dfrac{p(y_i)}{q(y_i)}\right)\end{aligned}\]</span></p></li><li><p>연속확률분포에 대해서는 <span class="math display">\[\begin{aligned}KL(p||q) &amp; = H[p,q] - H[p] \\ &amp; = \int p(y) \log_2 \left(p(y)\over q(y)\right)\end{aligned}\]</span></p></li><li>쿨백-라이블러 발산은 교차엔트로피에서 기준이 되는 <span class="math inline">\(p\)</span>분포의 엔트로피 값을 뺀 값이므로 상대엔트로피라고도 한다. 값은 항상 양수이며 두 확률분포가 완전히 같은 경우에만 0이된다.</li><li><p>쿨백-라이블러 발산은 거리가 아니라 두 확률분포가 얼마나 다른지를 나타내는 값이므로. 두 확률분포의 위치가 달라지면 일반적으로 값이 달라진다.</p></li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>결합엔트로피와 조건부엔트로피</title>
      <link>https://howardhowonyu.github.io/2020/03/10/TIL-mathematics-2020-03-10-entropy/</link>
      <guid>https://howardhowonyu.github.io/2020/03/10/TIL-mathematics-2020-03-10-entropy/</guid>
      <pubDate>Tue, 10 Mar 2020 12:59:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;결합엔트로피&quot;&gt;결합엔트로피&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;결합확률분포를 사용하여 정의한 엔트로피
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="결합엔트로피">결합엔트로피</h3><ul><li><p>결합확률분포를 사용하여 정의한 엔트로피 <a id="more"></a></p></li><li>이산확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(K_X,K_Y\)</span>는 각각 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 가질수 있는 값의 개수</li><li><span class="math inline">\(p\)</span>는 확률질량함수</li></ul><p><span class="math display">\[ H[X,Y] = - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} p(x_i,y_j) log_2p(x_i,y_j)\]</span></p></li><li>연속확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(p\)</span>는 확률밀도함수</li></ul><p><span class="math display">\[ H[X,Y] = - \int_x \int_y p(x,y)log_2p(x,y)dxdy\]</span></p></li></ul><h3 id="조건부엔트로피">조건부엔트로피</h3><ul><li><p>확률변수 <span class="math inline">\(X\)</span>가 다른 확률변수 <span class="math inline">\(Y\)</span>의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나(상관관계와는 조금 다른 개념)</p></li><li>조건부엔트로피는 조건에 따라 나눈 데이터의 엔트로피의 가중평균<ul><li>의사결정나무에서 어떤 것이 더 좋은 분류인가를 판단할때 조건부엔트로피를 활용</li><li>조건부엔트로피가 가장 낮은걸 분류 기준으로 두고 다음 의사 결정 과정을 진행</li></ul></li><li><p>이산확률변수일떄의 조건부엔트로피</p></li></ul><p><span class="math display">\[H[Y | X] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(y_i|x_i)\]</span></p><ul><li>연속확률변수일떄의 조건부엔트로피</li></ul><p><span class="math display">\[H[Y | X] = - \int_x \int_y p(x_i,y_j)log_2p(y_i|x_i)\]</span></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/03/10/TIL-mathematics-2020-03-10-entropy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>엔트로피란?</title>
      <link>https://howardhowonyu.github.io/2020/03/09/TIL-mathematics-2020-03-09-entropy1/</link>
      <guid>https://howardhowonyu.github.io/2020/03/09/TIL-mathematics-2020-03-09-entropy1/</guid>
      <pubDate>Mon, 09 Mar 2020 12:12:42 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;엔트로피entropy&quot;&gt;엔트로피(entropy)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;수학적인 엔트로피는 확률분포가 가지는 정보의 확신도 또는 정보량을 수치로 표현한 것.&lt;/li&gt;
&lt;li&gt;확률분포에서 특정한 값이 나올 확률이 높고, 나머지 값의 확률이 낮아진다면 엔트로피는 작아지고, 반대로 확률이 대부분 비슷한 경우 엔트로피가 높아진다.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;확률분포의 모양이 어떤지를 나타낼수 있는 특성값중 하나&lt;/strong&gt; 이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="엔트로피entropy">엔트로피(entropy)</h2><ul><li>수학적인 엔트로피는 확률분포가 가지는 정보의 확신도 또는 정보량을 수치로 표현한 것.</li><li>확률분포에서 특정한 값이 나올 확률이 높고, 나머지 값의 확률이 낮아진다면 엔트로피는 작아지고, 반대로 확률이 대부분 비슷한 경우 엔트로피가 높아진다.</li><li><p><strong>확률분포의 모양이 어떤지를 나타낼수 있는 특성값중 하나</strong> 이다. <a id="more"></a></p></li><li>엔트로피 역시 범함수의 일종<ul><li>범함수(함수를 입력받아 숫자를 출력하는 함수)의 예<ul><li>기대값 : $E[P_X(x)]= $숫자(함수의 중심위치)</li><li>분산 : $Var[P_X(x)] = $숫자 (함수의 폭)</li><li>엔트로피 : $H[P_X(x)] = $숫자(함수가 얼마나 골고루 분포)</li></ul></li></ul></li></ul><h2 id="이산확률변수와-연속확률변수에서의-엔트로피의-정의">이산확률변수와 연속확률변수에서의 엔트로피의 정의</h2><ul><li><p>이산확률변수(카테고리분포 등) <span class="math display">\[ H[Y] = -\sum_{k=1}^{K} p(y_k) log_2 p(y_k)\]</span></p></li><li><p>연속확률변수(정규분포 등) <span class="math display">\[ H[Y] = \int_{-\infty}^{\infty}p(y)log_2p(y)dy\]</span></p></li><li><p><span class="math inline">\(p(x)=0\)</span>인경우 로그값이 정의되지 않으므로 극한값을 사용한다 <span class="math display">\[ \lim_{n \to 0} plog_2p = 0 \]</span></p></li></ul><h2 id="엔트로피의-성질">엔트로피의 성질</h2><ul><li>엔트로피의 최소값은 0(모든 데이터가 동일한 확률값을 가질때)</li><li>엔트로피의 최대값은 이산 확률변수의 클래스의 갯수에 따라 달라진다. 만약 이산확률분포가 가질수 있는 값이 <span class="math inline">\(2^K\)</span>개면 엔트로피의 최대값은 각 값에 대한 확률이 모두 같은 <span class="math inline">\(1\over 2^K\)</span>이다</li></ul><p><span class="math display">\[H = -2^K \cdot {1\over 2^K}log_2{1\over2^K} = K \]</span></p><h2 id="엔트로피의-추정">엔트로피의 추정</h2><ul><li>이론적 확률밀도함수가 없고, 데이터만 있는 경우, 데이터에서 확률질량함수를 추정한후 이를 기반으로 엔트로피를 계산한다.<ul><li>80개 데이터중 <span class="math inline">\(Y=0\)</span>인 데이터가 40개, <span class="math inline">\(Y=1\)</span>인 데이터가 40개인 경우 엔트로피는 1이다.</li></ul><p><span class="math display">\[P(y=0) = {40\over80} = {1\over2}\]</span></p><p><span class="math display">\[P(y=1) = {40\over80} = {1\over2}\]</span></p><p><span class="math display">\[H[Y] = -{1\over2}log_2 \left( {1\over2} \right) - {1\over2}log_2 \left({1\over2}\right) = {1\over2} + {1\over2} = 1\]</span></p></li></ul><h2 id="결합엔트로피">결합엔트로피</h2><ul><li><p>결합확률분포를 사용하여 정의한 엔트로피 <!--more--></p></li><li>이산확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(K_X,K_Y\)</span>는 각각 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 가질수 있는 값의 개수</li><li><span class="math inline">\(p\)</span>는 확률질량함수</li></ul></li></ul><p><span class="math display">\[H[X,Y] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(x_i,y_j)\]</span></p><ul><li>연속확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(p\)</span>는 확률밀도함수</li></ul></li></ul><p><span class="math display">\[H[X,Y] = - \int_x \int_y p(x,y)log_2p(x,y)dxdy\]</span></p><h3 id="조건부엔트로피">조건부엔트로피</h3><ul><li><p>확률변수 <span class="math inline">\(X\)</span>가 다른 확률변수 <span class="math inline">\(Y\)</span>의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나(상관관계와는 조금 다른 개념)</p></li><li>조건부엔트로피는 조건에 따라 나눈 데이터의 엔트로피의 가중평균<ul><li>의사결정나무에서 어떤 것이 더 좋은 분류인가를 판단할때 조건부엔트로피를 활용</li><li>조건부엔트로피가 가장 낮은걸 분류 기준으로 두고 진행</li></ul></li><li><p>이산확률변수일떄의 조건부엔트로피</p></li></ul><p><span class="math display">\[H[Y | X] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(y_i|x_i)\]</span></p><ul><li>연속확률변수일떄의 조건부엔트로피</li></ul><p><span class="math display">\[H[Y | X] = - \int_x \int_y p(x_i,y_j)log_2p(y_i|x_i)\]</span></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/03/09/TIL-mathematics-2020-03-09-entropy1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SQLAlchemy</title>
      <link>https://howardhowonyu.github.io/2020/02/29/Database-2020-02-29-sqlalchemy/</link>
      <guid>https://howardhowonyu.github.io/2020/02/29/Database-2020-02-29-sqlalchemy/</guid>
      <pubDate>Sat, 29 Feb 2020 11:12:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;sql-alchemy&quot;&gt;SQL Alchemy&lt;/h2&gt;
&lt;p&gt;python 에서 사용하는 ORM 입니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="sql-alchemy">SQL Alchemy</h2><p>python 에서 사용하는 ORM 입니다. <a id="more"></a></p><p><strong>ORM</strong> 이란? : Object Relational Mapping &gt; 데이터 베이스를 객체화 시켜서 데이터 베이스에 있는 데이터를 CRUD(create,read,update,delete)할수 있습니다. &gt; 쿼리 대신 함수 형태로 CRUD를 할수 있습니다. &gt; 사용하는 데이터 베이스를 변경하는 경우 엔진을 바꾸면 됩니다. &gt; 따라서 쿼리문을 몰라도 데이터 베이스를 조작할수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker <span class="comment">#sql에 연결 시켜주는 함수</span></span><br></pre></td></tr></table></figure><h3 id="데이터-베이스-연결">데이터 베이스 연결</h3><p><db종류>://유저이름.비밀번호:퍼블릭 ip/데이터 베이스 이름</db종류></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">"mysql://root:***@&lt;퍼블릭 ip&gt;/test"</span>)</span><br></pre></td></tr></table></figure><h3 id="테이블-객체-생성을-위한-클래스-작성">테이블 객체 생성을 위한 클래스 작성</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    </span><br><span class="line">    __tablename__ = <span class="string">"user"</span> <span class="comment">#테이블 이름</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#컬럼 데이터 타입 작성</span></span><br><span class="line">    user_id = Column(Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line">    email = Column(String(<span class="number">30</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    rdate = Column(DateTime)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 생성자 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,email,age,rdate)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.email = email</span><br><span class="line">        self.age = age</span><br><span class="line">        self.rdate = rdate</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># repr 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User &#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&gt;"</span>.format(</span><br><span class="line">            self.name, self.email, self.age, self.rdate)</span><br></pre></td></tr></table></figure><h3 id="데이터-베이스와-객체를-연결">데이터 베이스와 객체를 연결</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># engine에 연결된 데이터 베이스(test)에 테이블 생성</span></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"><span class="comment"># Base를 상속받은 클래스들이 engine에 테이블 형태로 생성됨</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 베이스에 session 연결</span></span><br><span class="line">Session = sessionmaker(engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클래스를 return  받고</span></span><br><span class="line">session = Session()</span><br><span class="line"><span class="comment"># 객체 생성</span></span><br></pre></td></tr></table></figure><p><strong>session</strong> 은 데이터 베이스와 연결된 객체입니다.데이터 베이스 접속 정보가 들어 있습니다. <strong>session</strong>을 통해 데이터 베이스에 데이터를 넣고, 삭제하고 수정해 보겠습니다.</p><blockquote><p>데이터 베이스 연결 -&gt; 테이블 객체 생성을 위한 클래스 작성 -&gt; 데이터 베이스와 객체를 연결후 사용</p></blockquote><h3 id="insert">1. Insert</h3><p>session객체를 통해 데이터 배이스에 데이터를 넣어보겠습니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># insert</span></span><br><span class="line">user = User(<span class="string">"howard"</span>,<span class="string">"howard@thisisemail.com"</span>,<span class="number">27</span>,<span class="string">"2016-03-21"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># session 객체에 데이터가 저장</span></span><br><span class="line">session.add(user)</span><br><span class="line"><span class="comment"># run tranaction : 이순간 데이터 베이스에 저장</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure> 여러 동작을 한 tranction으로 묶어서 tranaction이 실행되는 동안은 다른 Task가 들어오지 못합니다.(예: 은행 계좌 출금 과정)</p><p>insert 여러개 해보면 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">users = [</span><br><span class="line">    User(<span class="string">"alice"</span>,<span class="string">"alice@gmail.com"</span>,<span class="number">25</span>,<span class="string">"2018-02-21"</span>),</span><br><span class="line">    User(<span class="string">"andy"</span>,<span class="string">"andy@daum.net"</span>,<span class="number">33</span>,<span class="string">"2015-10-21"</span>),</span><br><span class="line">]</span><br><span class="line">session.add_all(users) <span class="comment"># 데이터 저장</span></span><br><span class="line">session.commit() <span class="comment"># commit으로 데이터 베이스에 저장</span></span><br></pre></td></tr></table></figure></p><p>rollback : session안에 있는 객체를 초기화 시킵니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.rollback()</span><br></pre></td></tr></table></figure></p><h3 id="select">2. Select</h3><p>SQL의 Select처럼 데이터 프레임의 데이터들을 봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select all</span></span><br><span class="line">results = session.query(User).all()</span><br></pre></td></tr></table></figure></p><p>filter : ==, !=, &gt;, &lt;, &lt;=, &gt;=, like, in 등 SQL의 쿼리문 기능을 다 쓸수 있습니다. SQL WHERE 처럼 사용 가능합니다 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">results = session.query(User).filter(User.name==<span class="string">"howard"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : like</span></span><br><span class="line">results = session.query(User).filter(User.email.like(<span class="string">"%gmail%"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : in_</span></span><br><span class="line">results = session.query(User).filter(User.name.in_([<span class="string">"alice"</span>,<span class="string">"andy"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : or_</span></span><br><span class="line">results = session.query(User).filter(or_(User.name == <span class="string">"howard"</span>, User.age == <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># order by : desc, asc(내림차순, 오름차순 정렬)</span></span><br><span class="line">results = session.query(User).order_by(User.age.desc())</span><br><span class="line"></span><br><span class="line"><span class="comment"># count</span></span><br><span class="line">session.query(User).count()</span><br></pre></td></tr></table></figure></p><h3 id="updata">3. Updata</h3><p>데이터 베이스의 데이터를 수정해봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data에 andy의 row데이터 가져와서</span></span><br><span class="line">data = session.query(User).filter(User.name == <span class="string">"howard"</span>).one()</span><br><span class="line"><span class="comment"># age라는 칸에 30 넣어주고</span></span><br><span class="line">data.age = <span class="number">30</span></span><br><span class="line"><span class="comment"># session에 담아서</span></span><br><span class="line">session.add(data)</span><br><span class="line"><span class="comment"># commit</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="delete">4. Delete</h3><p>데이터를 삭제해 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete row</span></span><br><span class="line">session.query(User).filter(User.name == <span class="string">'jin'</span>).delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete table</span></span><br><span class="line"><span class="comment"># User클래스에서 지정된 테이블인 user만 지워짐</span></span><br><span class="line">User.__table__.drop(engine)</span><br></pre></td></tr></table></figure><h3 id="with-pandas">5. With Pandas</h3><p>판다스와 함께 사용해봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 데이터 프레임을 데이터 베이스에 넣기</span></span><br><span class="line">iris_df = sns.load_dataset(<span class="string">"iris"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># iris_df 데이터를 iris라는 이름으로 </span></span><br><span class="line"><span class="comment"># engine에서 지정된 데이터 베이스로 보냅니다. </span></span><br><span class="line"><span class="comment"># 만약 존재한다면 대체(replace)합니다.</span></span><br><span class="line">iris_df.to_sql(name=<span class="string">"iris"</span>,con=engine,if_exists=<span class="string">"replace"</span>)</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/29/Database-2020-02-29-sqlalchemy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>정규표현식</title>
      <link>https://howardhowonyu.github.io/2020/02/28/TIL-crawling-2020-02-28-crawling/</link>
      <guid>https://howardhowonyu.github.io/2020/02/28/TIL-crawling-2020-02-28-crawling/</guid>
      <pubDate>Fri, 28 Feb 2020 13:38:37 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;정규표현식-regx&quot;&gt;정규표현식 : regx&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;문자열을 처리할때 특정 &lt;strong&gt;패턴&lt;/strong&gt;으로 문자열을 처리하는 방법
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="정규표현식-regx">정규표현식 : regx</h3><ul><li><p>문자열을 처리할때 특정 <strong>패턴</strong>으로 문자열을 처리하는 방법 <a id="more"></a></p></li><li>BeautifulSoup같이 html만이 아닌 JS코드 등 여러개 혼합 되어있는 페이지를 크롤링 할때 사용 가능</li><li>예제<ul><li>문자열에서 정규표현식 패턴으로 이메일 찾아내기</li><li>문자열에서 주민등록번호 패턴을 찾아서 마지막 6자리의 숫자를 <code>*</code>로 치환</li><li>중고나라의 전화번호 패턴을 찾아서 숫자로 치환하기</li></ul></li></ul><h3 id="함수">함수</h3><ul><li><code>findall()</code> : 일치하는 패턴의 문자열을 찾아서 리스트로 리턴해주는 함수</li><li><code>sub()</code> : 특정 패턴에 맞는 문자열을 찾아서 특정 규칙에 따라 치환해주는 함수</li></ul><h4 id="패턴">패턴</h4><ul><li><code>[]</code> : 문자</li><li><code>-</code> : 범위</li><li><code>.</code> : 하나의 문자</li><li><code>?</code> : 0또는 1회 반복</li><li><code>*</code> : 0회 이상 반복</li><li><code>+</code> : 1회 이상 반복</li><li><code>{m}</code> : m회 반복</li><li><code>{m,n}</code> : m~n회 반복</li><li><code>()</code> : 그룹핑</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/28/TIL-crawling-2020-02-28-crawling/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Selenium</title>
      <link>https://howardhowonyu.github.io/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/</link>
      <guid>https://howardhowonyu.github.io/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/</guid>
      <pubDate>Wed, 26 Feb 2020 08:53:17 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;selenium&quot;&gt;Selenium&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;브라우저를 직접 실행하여 자동화하고 브라우저상에 있는 데이터를 수집
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="selenium">Selenium</h2><ul><li>브라우저를 직접 실행하여 자동화하고 브라우저상에 있는 데이터를 수집 <a id="more"></a></li><li>웹 테스트 자동화를 위해서 만들어진 라이브러리</li><li>다양한 브라우져 지원</li><li>다양한 언어를 지원</li></ul><h1 id="thread를-사용한-데이터-수집">thread를 사용한 데이터 수집</h1><ul><li>원래 파이썬 프로그램은 기본적으로 Single Thread 에서 실행됨. 즉 하나의 쓰레드가 순차적으로 코드를 실행함.</li><li>여기에서 별도의 쓰레드를 생성해 코드를 병렬로 실행하면 컴퓨터의 리소스가 허락하는 한도내에서 코드를 더 빨리 실행시킬수 있음.</li></ul><h1 id="pickle">Pickle</h1><ul><li>객체를 파일로 저장할때 직렬화(Serialization)라는 과정을 거쳐서 저장.</li><li><strong>직렬화</strong><ul><li>객체(데이터타입)과, 저장되는 파일의(데이터타입)은 다릅니다.</li><li>서로 다른 데이터 타입을 맞춰주는 과정이 필요</li></ul></li><li>파일을 읽고 저장하는데 속도가 더 빠릅니다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/#disqus_thread</comments>
    </item>
    
    <item>
      <title>확률론적 선형 회귀모형</title>
      <link>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/</link>
      <guid>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/</guid>
      <pubDate>Wed, 26 Feb 2020 01:17:59 GMT</pubDate>
      <description>
      
        &lt;h4 id=&quot;ols방법을-사용하여-최적의-가중치를-계산할수-있지만-오차범위를-알지-못하면-가중치를-알아도-아무것도-모르는-거랑-같다&quot;&gt;OLS방법을 사용하여 최적의 가중치를 계산할수 있지만, 오차범위를 알지 못하면 가중치를 알아도 아무것도 모르는 거랑 같다!&lt;/h4&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="ols방법을-사용하여-최적의-가중치를-계산할수-있지만-오차범위를-알지-못하면-가중치를-알아도-아무것도-모르는-거랑-같다">OLS방법을 사용하여 최적의 가중치를 계산할수 있지만, 오차범위를 알지 못하면 가중치를 알아도 아무것도 모르는 거랑 같다!</h4><a id="more"></a><ul><li>가중치의 오차 범위 혹은 신뢰 구간을 계산할 수 없다면 OLS 결과로부터 실질적인 결론을 이끌어내기 어렵다.</li></ul><h2 id="부트스트래핑">부트스트래핑</h2><ul><li>OLS로 구한 가중치의 추정값은 표본 데이터에 따라 달라진다.</li><li>여러 다른 표본 데이터 집합이 있다면 넣어보면서 가중치가 어떻게 달라지는지 알아 볼수 있지만, 현실적으로 다시 데이터를 얻기는 힘듦</li><li>따라서 기존 데이터를 재표본화하여(re-sampling)하여 여러가지 다양한 표본 데이터를 만드는 방법을 부트스트래핑이라 한다.</li></ul><h2 id="확률론적-선형-회귀모형">확률론적 선형 회귀모형</h2><p><strong>확률론적 선형회귀모형을 쓰면 빠르고 안정적으로 가중치 추정값의 오차를 구할수 있다.</strong></p><ul><li>확률론적 선형 회귀모형에서는 데이터가 확률 변수로 부터 생성된 표본이라고 가정한다.</li></ul><p><strong>1. 선형 정규 분포 가정</strong></p><ul><li>종속변수 <span class="math inline">\(y\)</span>가 독립변수<span class="math inline">\(x\)</span>의 선형조합으로 결정되는 &quot;기대값&quot;과 고정된 분산<span class="math inline">\(\sigma^2\)</span>를 가지는 &quot;정규 분포&quot;라는 것이다.</li></ul><p><span class="math display">\[y \sim N(w^Tx,\sigma^2)\]</span> <span class="math display">\[\epsilon = y - w^Tx\]</span> <span class="math display">\[p(\epsilon|\theta) = N(0,\sigma^2)\]</span></p><p><strong>2. 외생성 가정</strong></p><ul><li>잡음 <span class="math inline">\(\epsilon\)</span>의 기대값은 독립변수 <span class="math inline">\(x\)</span>의 크기에 상관없이 항상 0이라고 가정.</li></ul><p><span class="math display">\[E[\epsilon|x] = 0\]</span></p><p><strong>3. 조건부 독립 가정</strong></p><ul><li><span class="math inline">\(i\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_i\)</span>와 <span class="math inline">\(j\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_j\)</span>의 공분산 값이 <span class="math inline">\(x\)</span>와 상관없이 항상 0이라고 가정한다.</li></ul><p><span class="math display">\[Cov[\epsilon_i,\epsilon_j]=0 (i,j = 1,2,...,N)\]</span></p><ul><li>이는 서로 독립이라는 가정과 같다.</li></ul><p><span class="math display">\[E[\epsilon_i\epsilon_j]=0(i,j = 1,2,...,N)\]</span></p><ul><li>잡음 벡터 <span class="math inline">\(\epsilon\)</span>의 공분산 행렬이 대각행렬이 되어야 한다.(비대각 성분 모두 0)</li></ul><p><span class="math display">\[Cov[\epsilon] = E[\epsilon\epsilon^T] = Diagonal matrix \]</span></p><p><strong>4. 등분산성 가정</strong></p><ul><li><span class="math inline">\(i\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_i\)</span>와 <span class="math inline">\(j\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_j\)</span>의 분산 값이 표본과 상관없이 항상 같다고 가정</li></ul><p><span class="math display">\[Cov[\epsilon]=E[\epsilon\epsilon^T]=\sigma^2I\]</span></p><ul><li>잡음 벡터 공분산 행렬이 항등행렬 형태가 되어야 한다는 조건과 같다.</li></ul><h2 id="최대-가능도-방법을-사용한-선형-회귀분석">최대 가능도 방법을 사용한 선형 회귀분석</h2><ul><li>최대 가능도 방법(Maximum Likelihood Estimation)을 사용하여 가중치 벡터 𝑤 의 값을 구해보면, OLS의 직교 방정식과 같은 직교 방정식을 얻을 수 있다</li></ul><h2 id="잔차의-분포">잔차의 분포</h2><p>$ e = M$</p><ul><li>M : 잔차행렬</li><li>잔차 <span class="math inline">\(e\)</span>는 잡음 <span class="math inline">\(\epsilon\)</span>의 선형변환이다.</li><li>정규분포의 선형변환은 마찬가지로 정규분포 이므로 잔차는 정규분포를 따른다.</li></ul><h2 id="회귀계수의-표준오차">회귀계수의 표준오차</h2><ul><li>실제 가중치 계수 <span class="math inline">\(w_i\)</span>와 우리가 추정한 가중치 계수 <span class="math inline">\(\hat{w}_i\)</span>의 차이를 표준오차로 나눈값, 즉 <strong>정규화된 모수 오차는 자유도가 <span class="math inline">\(N-K\)</span>인 표준 스튜던트 t분포를 따른다.</strong></li></ul><h2 id="단일-계수-t-검정">단일 계수 t-검정</h2><ul><li>정규화된 모수 오차를 검정통계량으로 사용하면 <span class="math inline">\(w_i\)</span>가 0인지 아닌지에 대한 검정을 실시할수 있다.</li><li>StatsModels summary 메서드가 출력하는 회귀분석 보고서에서 <code>std err</code>로 표시된 열이 모형계수의 표준오차, <code>t</code>로 표시된 열이 단일 계수 t-검정의 검정 통계량, 그리고 <code>P&gt;|t|</code>로 표시된 열이 유의확률을 뜻한다.</li><li><strong>두 독립변수의 계수값을 비교할때도 사용</strong></li><li><strong>범주형 독립변수의 범주값이 가지는 유의성을 판단하는데 유용하다.</strong></li></ul><h2 id="회귀분석-f-검정">회귀분석 F-검정</h2><ul><li>개별 개수가 아닌 전체 회귀 계수가 모두 의미가 있는지 확인하는 경우 사용.</li><li>전체 독립 변수 중 어느 것도 의미를 가진 것이 없다는 귀무가설을 세운다.</li><li>유의확률이 작으면 작을수록 더 강력하게 기각된 것이므로 더 의미가 있는 모형이라고 할 수 있다.</li><li>따라서 여러 모형의 유의 확률을 비교하여 어느 모형이 더 성능이 좋은가를 비교할 때 이 유의 확률을 사용한다</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>부분회귀</title>
      <link>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/</link>
      <guid>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/</guid>
      <pubDate>Wed, 26 Feb 2020 01:03:53 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;부분회귀&quot;&gt;부분회귀&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;회귀분석을 한 후 새로운 독립변수를 추가하여 다시 회귀분석 한다면?
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="부분회귀">부분회귀</h1><ul><li>회귀분석을 한 후 새로운 독립변수를 추가하여 다시 회귀분석 한다면? <a id="more"></a><ul><li>처음에 나온 w1의 값과 두번째 나온 w'1의 값은 다르다.</li><li>종속변수에 영향을 미치는 모든 독립변수들이 회귀모형에 포함되지 않는한, 모형의 가중치는 항상 편향된(biased)값 이다.</li></ul></li></ul><blockquote><p><strong>새로운 독립변수 그룹을 추가해서 다시 회귀분석을 하면, 기존 가중치 벡터의 값이 달라진다.</strong></p></blockquote><h3 id="두가지-회귀분석-결과가-같을수-있는-경우">두가지 회귀분석 결과가 같을수 있는 경우</h3><ul><li><span class="math inline">\(w&#39;2 = 0\)</span>, 즉 <span class="math inline">\(X_2\)</span>와 <span class="math inline">\(y\)</span>의 상관관계가 없는 경우</li><li><span class="math inline">\(X_1^TX_2 = 0\)</span>, 즉 독립변수 <span class="math inline">\(X_1\)</span>과 독립변수 <span class="math inline">\(X_2\)</span>가 직교하는 경우. 서로 상관관계가 없으면 직교할 가능성이 높다.</li></ul><h2 id="프리슈-워-로벨-정리">프리슈-워-로벨 정리</h2><ul><li>1 : 특정한 독립변수 그룸 <span class="math inline">\(X_1\)</span>로 종속변수 <span class="math inline">\(y\)</span>를 선형회귀분석하여 잔차 <span class="math inline">\(y^*\)</span>를 구한다.</li><li>2 : <span class="math inline">\(X_1\)</span>로 다른 독립변수 <span class="math inline">\(x_2\)</span>를 선형 회귀분석하여 나온 잔차 <span class="math inline">\(x^*_2\)</span>를 구한다.</li><li>3 : <span class="math inline">\(y^*\)</span>를 종속변수로 하고 <span class="math inline">\(x^*_2\)</span> 를 독립변수로 하여 선형회귀분석하여 구한 가중치는 <span class="math inline">\(X_1\)</span>과 <span class="math inline">\(x_2\)</span>를 모두 사용하여 <span class="math inline">\(y\)</span>를 선형 회귀분석하였을때 <span class="math inline">\(x_2\)</span>에 대한 가중치와 같다.</li></ul><h2 id="부분회귀-플롯partial-regression-plot-added-variable-plot">부분회귀 플롯(Partial Regression Plot, Added Variable Plot)</h2><ul><li>특정한 하나의 독립변수의 영향력을 시각화하는 방법</li></ul><blockquote><p><strong>순서</strong></p></blockquote><ol type="1"><li>특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 제외한 나머지 독립변수 <span class="math inline">\(𝑋_1\)</span> 들로 종속변수 <span class="math inline">\(𝑦\)</span> 를 선형 회귀분석하여 잔차 <span class="math inline">\(𝑦^∗\)</span> 를 구한다.</li><li>특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 제외한 나머지 독립변수 <span class="math inline">\(𝑋_1\)</span> 들로 특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 선형 회귀분석하여 잔차 <span class="math inline">\(x_2^*\)</span> 를 구한다.</li><li>잔차 <span class="math inline">\(𝑥_2^*\)</span> 를 독립변수로, 잔차 <span class="math inline">\(𝑦^∗\)</span> 를 종속변수로 하여 선형 회귀분석한다. 이렇게 구한 <span class="math inline">\(𝑥_2^*\)</span> , <span class="math inline">\(𝑦^∗\)</span> 의 스캐터 플롯과 회귀분석 결과를 나타낸 것이 부분회귀 플롯이다.</li></ol><ul><li>부분회귀 플롯에서 가로축의 값은 독립변수 자체의 값이 아닌, 다른 독립변수의 영향을 제거한 일종의 &quot;순수한 독립변수 성분&quot;</li></ul><h2 id="ccpr-플롯">CCPR 플롯</h2><ul><li>부분회귀플롯과 마찬가지, &quot;가로축의 값은 독립변수 그대로의 값&quot;</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>범주형 독립변수</title>
      <link>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/</link>
      <guid>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/</guid>
      <pubDate>Tue, 25 Feb 2020 13:36:19 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;풀랭크-방식&quot;&gt;풀랭크 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;더미변수의 값을 원핫인코딩 방식으로 지정.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="풀랭크-방식">풀랭크 방식</h3><ul><li>더미변수의 값을 원핫인코딩 방식으로 지정. <a id="more"></a> <span class="math display">\[x_1 = A \to d_{1A} = 1, d_{1B} = 0 \]</span> <span class="math display">\[x_1 = B \to d_{1B} = 0, d_{1B} = 1 \]</span></li><li>위 수식을 대입하면 <span class="math display">\[x_1 = A \to \hat{y} = w_{1A} + w_2x_2 + \dots + w_Dx_D\]</span> <span class="math display">\[x_1 = B \to \hat{y} = w_{1B} + w_2x_2 + \dots + w_Dx_D\]</span></li><li><strong>더미변수의 가중치는 상수항이 된다.</strong></li></ul><h3 id="풀랭크-방식과-축소랭크-방식">풀랭크 방식과 축소랭크 방식</h3><ul><li>풀랭크 : 더미변수의 값을 원핫인코딩 방식으로 지정.</li><li>축소랭크 : 특정한 하나의 범주값을 기준값으로 하고 기준값에 대응하는 더미변수의 가중치는 항상 1로 놓는다.</li></ul><blockquote><p>월별기온예측 - 풀랭크 방식: 각 월의 대표값 - 축소랭크 방식: 기준값(1월의 평균기온)에서 &quot;차이&quot;가 얼마나 나는가</p></blockquote><h2 id="두개-이상의-범주형-변수가-있는-경우">두개 이상의 범주형 변수가 있는 경우</h2><ul><li>두개 이상의 범주형 변수가 있는 경우 축소형 방식을 사용</li><li>모든 범주형 변수의 가중치는 기준값 상수항에 더해지는 상수항으로 취급.</li></ul><h2 id="범주형-독립변수와-실수-독립변수의-상호작용">범주형 독립변수와 실수 독립변수의 상호작용</h2><p>Case1) - 범주형 독립변수 <span class="math inline">\(x_1\)</span>과 실수 독립변수 <span class="math inline">\(x_2\)</span>를 가지는 회귀모형에서 연속값 독립변수 <span class="math inline">\(x_2\)</span>가 미치는 영향, 즉 가중치가 범주형 독립변수 <span class="math inline">\(x_1\)</span>에 따라 달라진다면</p><ul><li>범주형 독립변수를 더미변수 <span class="math inline">\(d_1\)</span>으로 인코딩하고 연속값 독립변수 <span class="math inline">\(x_2\)</span>는 <span class="math inline">\(d_1\)</span>과의 상호작용항 <code>d_1:x_2</code>를 추가한다.</li><li><span class="math inline">\(x_1\)</span>범주값에 따라 <span class="math inline">\(x_2\)</span>의 기울기가 달라지는 모형이 된다.</li></ul><p>Case2) - 범주형 독립변수도 종속변수에 영향을 미치고, 범주형 독립변수와 실수 독립변수의 &quot;상호작용&quot;도 종속변수에 영향을 미치면</p><ul><li><span class="math inline">\(x_1\)</span>의 범주값에 따라 상수항과 <span class="math inline">\(x_2\)</span>의 기울기가 모두 달라지는 모형이 된다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>스케일링</title>
      <link>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/</link>
      <guid>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/</guid>
      <pubDate>Tue, 25 Feb 2020 13:32:52 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;조건수&quot;&gt;조건수&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;가장큰 고유값와 가장 작은 고유값의 비율&lt;/li&gt;
&lt;li&gt;&lt;p&gt;조건수가 크면 민감도가 커진다. 즉, 오차가 생기면 해에 미치는 영향이 커진다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="조건수">조건수</h2><ul><li>가장큰 고유값와 가장 작은 고유값의 비율</li><li><p>조건수가 크면 민감도가 커진다. 즉, 오차가 생기면 해에 미치는 영향이 커진다. <a id="more"></a></p></li><li><p>연립방정식을 이루는 행렬의 조건수가 커지면 상수항 오차가 작은 경우라도 연립방정식 해의 오차는 커진다. &gt; <strong>결론 : 공분산 행렬의 조건수가 크면 회귀분석을 사용한 예측값도 오차가 커진다.</strong></p></li></ul><h4 id="조건수가-커지는-경우">조건수가 커지는 경우</h4><ul><li>스케일이 크게 다른 경우 -&gt; 스케일링으로 해결</li><li><p>다중공선성, 상관관계가 큰 독립변수들이 있는 경우 -&gt; 변수선택(변수를 버리거나), PCA를 이용한 차원 축소로 해결</p></li><li>스케일링이 안된경우 독립변수의 분포 모양이 옆이나 위로 퍼져있다. 이를 원에 가깝게 모을수록 조건수가 작아진다.</li><li><p>다중공선성이 있을경우 그래프가 상관관계를 보인다.</p></li><li><code>scale()</code>명령 formula안에서 사용하여 스케일링을 할수 있다.</li><li><p>위 방식으로 스케일하면 스케일링에 사용된 평균과 표준편차를 저장하였다가 나중에 <code>predict()</code>명령을 사용할때 같은 스케일을 사용하기 때문에 편하다.</p></li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>데이터 전처리 기초 2</title>
      <link>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning/</link>
      <guid>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning/</guid>
      <pubDate>Mon, 24 Feb 2020 11:15:23 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;sklearn.preprocessing-패키지&quot;&gt;sklearn.preprocessing 패키지&lt;/h2&gt;
&lt;p&gt;스케일링 및 변수변환을 위한 &lt;code&gt;StandardScaler&lt;/code&gt; 클래스에서
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="sklearn.preprocessing-패키지">sklearn.preprocessing 패키지</h2><p>스케일링 및 변수변환을 위한 <code>StandardScaler</code> 클래스에서 <a id="more"></a></p><ul><li><code>fit()</code>: 학습용 데이터를 입력으로 실행하면 평균값과 표준편차를 계산하여 객체내에 저장</li><li><code>transform()</code>: 저장했던 평균값을 빼서 새로운 평균값이 0이 되도록 만들고, 저장한 표준편차로 나누어 새로운 표준편차가 1이 되도록 데이터를 변환하여 출력</li><li><code>fit_transform()</code>: 1,2단계를 합친것</li></ul><p>데이터에 아웃라이어가 있을 경우 <code>RobustScaler</code> 클래스를 사용 - 중앙값이 0, IQR(interquartile range)이 1이 되도록 변환하여, 아웃라이어가 섞여 있어도 데이터는 0주위에 남게 된다.</p><p><code>FunctionTransformer</code>클래스와 <code>PolynomialFeatures</code>클래스 - <code>PolynomialFeatures</code>클래스는 입력데이터를 여러개의 다항식으로 변환 - degree: 차수 - include_bias: 상수항 생성 여부 - <code>FunctionTransformer</code>클래스는 사용자가 지정한 함수를 사용하여 입력값을 변환 - 각도 0도와 360도를 구분하기위한 sin,cos함수 사용 예제</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>선형회귀분석의 기초</title>
      <link>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/</link>
      <guid>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/</guid>
      <pubDate>Mon, 24 Feb 2020 11:15:23 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;회귀분석&quot;&gt;회귀분석&lt;/h1&gt;
&lt;p&gt;독립변수에 대응하는 종속변수와 가장 비슷한값 y^을 출력하는 함수를 찾는 과정 만약 함수 f(x)가 선형함수면, 이 함수를 선형회귀모형(linear regression model)이라 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="회귀분석">회귀분석</h1><p>독립변수에 대응하는 종속변수와 가장 비슷한값 y^을 출력하는 함수를 찾는 과정 만약 함수 f(x)가 선형함수면, 이 함수를 선형회귀모형(linear regression model)이라 한다. <a id="more"></a></p><ul><li>만약 <span class="math inline">\(f(x)\)</span>가 선형함수면 이 함수를 선형회귀모형이라고 한다. 선형회귀모형을 사용하는 회귀분석은 선형회귀분석이라고 한다. <span class="math display">\[\hat{y} = w_0 + w_1x_1 + w_2x_2 + ... + w_Dx_D = w_0+w^Tx\]</span></li></ul><h2 id="상수항-결합">상수항 결합</h2><p>회귀분석모형 수식을 간단하게 만들기 위해 상수항을 독립변수 데이터 제일 처음에 추가하는것을 상수항 결합 작업이라 한다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">X0 = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">X = sm.add_constant(X0)</span><br></pre></td></tr></table></figure></p><h2 id="최소자승법">최소자승법</h2><p>최소자승법(OLS)은 잔차제곱합(RSS)을 최소화 하는 가중치 벡터를 구하는 방법. 잔차의 크기(RSS)를 가장 작게 하는 가중치 벡터를 구하기 위해서, 잔차제곱합 식을 미분하여 그레디언트 벡터를 구하고, 이 그레디언트벡터가 영벡터 일때 RSS는 최소가 된다.</p><h2 id="직교방정식">직교방정식</h2><p>여기서 그레디언트 벡터가 0벡터가 되는 관계를 나타내는 식을 직교방정식(normal equation)이라 한다. 1. 모형에 상수항이 있는 경우 잔차벡터의 원소의 합은 0이다. 즉 잔차의 평균은 0이다 2. x데이터의 평균값에 대한 예측값은 y데이터의 평균값이다.</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>범주형 데이터 처리</title>
      <link>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/</link>
      <guid>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/</guid>
      <pubDate>Mon, 24 Feb 2020 11:13:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;범주형-데이터&quot;&gt;범주형 데이터&lt;/h1&gt;
&lt;p&gt;혈액형, 성별과 같이 종류를 표시하는 데이터
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="범주형-데이터">범주형 데이터</h1><p>혈액형, 성별과 같이 종류를 표시하는 데이터 <a id="more"></a></p><h2 id="범주형-데이터의-변형">범주형 데이터의 변형</h2><ul><li>더미변수화</li><li>카테고리 임베딩</li></ul><h2 id="더미변수화">더미변수화</h2><p>0 또는 1만 가지는 값으로 어떤 특징의 존재 여부를 표시. 이진지시자(Boolean indicator),이진변수(binary variable),지시변수(indicator variable),설계변수(design variable),처치(treatment)등으로 불린다.</p><h2 id="patsy를-활용한-더미변수화">patsy를 활용한 더미변수화</h2><ul><li>풀랭크 방식 patsy패키지의 <code>dmatrix()</code>함수는 범주값을 더미변수로 바꿔준다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> patsy <span class="keyword">import</span> dmatrix</span><br><span class="line">df = pd.DataFrame([<span class="string">"A"</span>, <span class="string">"B"</span>], columns=[<span class="string">"x"</span>])</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line">dmatrix(<span class="string">"x + 0"</span>, df1)</span><br></pre></td></tr></table></figure></li><li>축소랭크 방식 특정한 하나의 범주값을 기준값으로 하고 기준값에 대응하는 더미변수의 가중치는 항상 1로 한다. 더미변수화 할떄 <code>dmatrix()</code>함수의 문자열에 +0을 생략함</li></ul><h2 id="두개의-범주형-변수">두개의 범주형 변수</h2><ul><li>통합 축소형 방식</li><li>상호작용 방식</li></ul><h2 id="카테고리-임베딩">카테고리 임베딩</h2><p>범주값 대신 범주값의 특성을 나타내는 연속값 혹은 연속값 벡터를 사용 예를들어 운동선수의 이름을 나타내는 범주값의 경우, 운동선수의 나이, 연봉, 신체능력치 등을 사용하고, 지역명을 나타내느 범주값은 지역의 면적, 인구수 등을 사용한다.</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS-selector</title>
      <link>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-crawling-css/</link>
      <guid>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-crawling-css/</guid>
      <pubDate>Sat, 22 Feb 2020 12:16:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;css-selector&quot;&gt;CSS Selector&lt;/h1&gt;
&lt;p&gt;HTML 엘리먼트에 CSS 스타일을 적용시킬때 엘리먼트를 선택하는 방법입니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="css-selector">CSS Selector</h1><p>HTML 엘리먼트에 CSS 스타일을 적용시킬때 엘리먼트를 선택하는 방법입니다. <a id="more"></a></p><h4 id="태그-이름으로-선택">1. 태그 이름으로 선택</h4><p>&quot;data 1 엘리먼트를 선택&quot; - css-selector : <code>div</code></p><h4 id="아이디-값으로-선택">2. 아이디 값으로 선택</h4><p>&quot;data 2를 아이디 값으로 선택&quot; - css-selector : <code>#text</code></p><h4 id="클래스-값으로-선택">3.클래스 값으로 선택</h4><p>&quot;data 3를 클래스 값으로 선택&quot; - css-selector : <code>.no1</code> - <code>.dss-txt</code> : data2, data 3가 선택</p><h4 id="속성값으로-선택">4. 속성값으로 선택</h4><p>&quot;data 4를 속성값으로 선택&quot; - css-selector : <code>[val=&quot;d4&quot;]</code>, <code>[id=&quot;da4&quot;]</code></p><h4 id="혼합해서-사용">5. 혼합해서 사용</h4><p>&quot;span 태그, class 값이 no5인 엘리먼트 선택&quot; - css-selector : <code>span.no5</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"dss-txt no1"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dss-txt no2"</span> <span class="attr">val</span>=<span class="string">"d3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"da4"</span> <span class="attr">val</span>=<span class="string">"d4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"no5"</span> &gt;</span>data 5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="not-selector">6. not selector</h4><p>선택된 엘리먼트에서 특정 조건의 엘리먼트를 제거해서 선택 data 2 엘리먼트만 제외한 ds 클래스를 선택 - css-selector : <code>.ds:not(.dss2)</code></p><h4 id="nth-child">7.nth-child</h4><p>n번째의 엘리먼트를 선택</p><p>data 3 선택하는 방법 - css-selector : <code>.ds:nth-child(3)</code> 뒤의 조건(.ds라는 클래스를 가진 상위 클래스의 자식중에 3번째)이 먼저, 다음 ds라는 클래스를 가진거를 선택</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>data 0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss1"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss2"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> # 얘도 3번째 ds</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss1"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss2"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span> # 얘도 3번째 ds</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds"</span>&gt;</span> data5<span class="tag">&lt;/<span class="name">div</span>&gt;</span> # 얘도 3번째 ds</span><br></pre></td></tr></table></figure><h4 id="계층구조로-엘리먼트-선택">8. 계층구조로 엘리먼트 선택</h4><p>바로 아래 단계의 엘리먼트 선택 - <code>.wrap-1 &gt; h5</code> : inner 1선택 모든 하위 엘리먼트를 선택 - <code>.wrap-1 h5</code> : inner 1,inner 2선택 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>inner 1 <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>inner 2 <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-crawling-css/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML</title>
      <link>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/</link>
      <guid>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/</guid>
      <pubDate>Sat, 22 Feb 2020 10:38:19 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;html&quot;&gt;HTML&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Hyper Text Markup Language&lt;/li&gt;
&lt;li&gt;웹 문서를 작성하는 마크업 언어입니다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="html">HTML</h1><ul><li>Hyper Text Markup Language</li><li>웹 문서를 작성하는 마크업 언어입니다.</li></ul><a id="more"></a><ul><li>웹페이지를 구성하는 언어에는 3종류가 있습니다.<ul><li>HTML : 화면의 레이아웃이나 텍스트</li><li>CSS : 화면의 색상 크기 등의 스타일</li><li>Javascript : 화면의 클릭, 드래그 등등의 이벤트</li></ul></li></ul><h2 id="html의-구성요소">1.1 HTML의 구성요소</h2><p><strong><code>Document</code></strong> - 페이지 전체 <strong><code>element</code></strong> - 계층적 구조로 이루어져 있으며 모여서 Document가 됩니다. - 시작 태그와 끝 태그로 구성되어 있습니다. <code>&lt;div&gt; &lt;/div&gt;</code> <strong><code>Tag</code></strong> - 시작태그와 끝 태그로 엘리먼트를 구성합니다. - 시작 태그에는 여러가지 속성값들이 들어 있습니다. - 태그와 태그 사이에는 문자열 데이터를 가질수 있습니다. - 태그의 이름에 따라서 태그의 목적이 달라집니다. <strong><code>Attribute</code></strong> - 시작 태그 안에 포함되는 속성값입니다. - <code>id</code>, <code>class</code> : 엘리먼트를 선택하기 위한 목적으로 만들어진 속성값입니다. - 이 외에도 다양한 속성값이 존재 합니다.</p><h3 id="속성값">1.2 속성값</h3><p><strong><code>id</code></strong> : 웹페이지에서 유일한 값입니다. <strong><code>class</code></strong> : - 웹 페이지 내에서 여러개의 class가 존재합니다. - 하나의 엘리먼트에 여러개의 class를 부여할수 있습니다. <strong><code>type</code></strong> : 엘리먼트 형태를 결정합니다. (button, checkbox 등) <strong><code>style</code></strong> : CSS 스타일 값을 적용할수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-1"</span> <span class="attr">class</span>=<span class="string">"bt no1"</span><span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">style</span>=<span class="string">"color:red;"</span> &gt;</span>HTML 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-2"</span> <span class="attr">class</span>=<span class="string">"bt no2"</span><span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>HTML 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="태그의-종류">1.3 태그의 종류</h3><p><strong><code>Head</code></strong> : 제목을 나타낼때 사용합니다. h1부터 숫자가 커질수록 작아집니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>p</code></strong> : 한줄의 문자열을 출력하기 위한 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>파이썬은 재미있습니다.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>내일은 휴강입니다.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>div</code></strong> : 레이아웃을 나타내는 태그이고, 가장 많이 사용됩니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>table</code></strong> : row와 column이 있는 테이블 모양을 나타낼때 사용되는 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>테이블 제목<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>코드<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>회사명<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>0001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>애플<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">td</span>&gt;</span>0002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>네이버<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>ul</code></strong>,<strong><code>li</code></strong> : 리스트를 나타내는 태그입니다. 하나의 ul에 다수의 li태그를 가집니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>a</code></strong> : 링크를 출력하는 태그입니다. <code>href</code> 속성값에 이동할 URL을 입력합니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"howardhowonyu.github.io"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Howard's nest<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>img</code></strong> : 이미지를 불러오는 태그 입니다. <code>src</code> 속성값에 이미지의 URL을 입력합니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span> =<span class="string">"width:200px;"</span><span class="attr">src</span>=<span class="string">"이곳에 이미지의 URL을 입력합니다."</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>iframe</code></strong> : 외부 URL 링크의 페이지를 보여주기 위한 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://howardhowonyu.github.io/"</span> <span class="attr">width</span>=<span class="string">"100%;"</span> <span class="attr">height</span>=<span class="string">"400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>input</code></strong> : 여러 형태의 값을 입력받는 요소들을 만드는 태그입니다. - text : 문자를 입력받습니다. - password : 비밀번호(****)형태로 입력 받습니다. - radio : n지 선다의 답을 받습니다. - checkbox : 체크박스를 만듭니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"비밀번호"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"data"</span>&gt;</span>radio 1<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"data"</span>&gt;</span>radio 2<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>checkbox 1<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>select,option</code></strong>: 옵션을 선택할수 있는 드랍다운 형태를 만드는 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/#disqus_thread</comments>
    </item>
    
    <item>
      <title>예외처리</title>
      <link>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-try-except-finally-raise/</link>
      <guid>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-try-except-finally-raise/</guid>
      <pubDate>Fri, 21 Feb 2020 10:30:49 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;try-except&quot;&gt;TRY, EXCEPT&lt;/h1&gt;
&lt;p&gt;에러가 발생해도 코드의 실행을 계속 하고 싶을 때 사용합니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="try-except">TRY, EXCEPT</h1><p>에러가 발생해도 코드의 실행을 계속 하고 싶을 때 사용합니다. <a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># try구문을 실행</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    print(ls[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 오류가 발생해도 코드의 실행을 마치고 e라는 변수에 오류 메세지를 담습니다.</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line">    print(e)</span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># error</span></span><br><span class="line"><span class="comment"># name 'ls' is not defined</span></span><br><span class="line"><span class="comment"># Done!</span></span><br></pre></td></tr></table></figure><h1 id="finally">FINALLY</h1><p>try, except 구문 실행된후 finally 구문이 실행됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"Done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># error</span></span><br><span class="line"><span class="comment"># Done!</span></span><br></pre></td></tr></table></figure><blockquote><p>코딩 실행 중간에 에러가 발생하면 변수안에 계속 데이터를 가지고 있고, 이는 낭비입니다.<br>때문에 try던 except건 간에 어쨋든 &quot;실행 되면 finally 변수안에 데이터 지워줘&quot; 라고 할때 사용합니다.</p></blockquote><h1 id="raise">RAISE</h1><p>강제로 에러를 발생시키는 명령입니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line">    <span class="keyword">raise</span>(e)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>except때문에 코드 실행이 완료 되어야 하지만 raise()떄문에 강제로 에러가 발생됩니다.</p></blockquote><h1 id="에러-메세지-생성">에러 메세지 생성</h1><p><strong>&quot;Number grater than 10&quot;</strong><br>10이상의 숫자가 입력되어야 한다는 에러 메세지를 만들어보면, <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Exception 이라는 클래스를 상속 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lownumber</span><span class="params">(Exception)</span>:</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> <span class="comment">#에러 메세지 오버라이팅</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Number grater than 10"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_number</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">raise</span> Lownumber() <span class="comment">#Lownumber 클래스를 사용</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">input_number(<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">input_number(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 에러메세지 출력</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#Lownumber                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="comment">#&lt;ipython-input-19-8684a0e33c0b&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#----&gt; 1 input_number(8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;ipython-input-17-bf4895dc7d57&gt; in input_number(num)</span></span><br><span class="line"><span class="comment">#      1 def input_number(num):</span></span><br><span class="line"><span class="comment">#      2     if num &lt;= 10:</span></span><br><span class="line"><span class="comment">#----&gt; 3         raise Lownumber() #Lownumber 클래스를 사용</span></span><br><span class="line"><span class="comment">#      4     print("10")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Lownumber: Number grater than 10</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-try-except-finally-raise/#disqus_thread</comments>
    </item>
    
    <item>
      <title>모듈과 패키지</title>
      <link>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-python-module-package/</link>
      <guid>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-python-module-package/</guid>
      <pubDate>Fri, 21 Feb 2020 10:19:18 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;module-package&quot;&gt;Module &amp;amp; Package&lt;/h1&gt;
&lt;p&gt;모듈 : 변수, 함수, 클래스를 모아놓은 (.py)라는 이름의 확장자를 가진 파일입니다. 패키지 : 모듈의 기능을 디렉토리별로 정리해 놓은 개념입니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="module-package">Module &amp; Package</h1><p>모듈 : 변수, 함수, 클래스를 모아놓은 (.py)라는 이름의 확장자를 가진 파일입니다. 패키지 : 모듈의 기능을 디렉토리별로 정리해 놓은 개념입니다. <a id="more"></a></p><h2 id="module모듈">Module(모듈)</h2><p>모듈 생성 &gt; 매직 매서드를 사용한 모듈 생성 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dss.py라는 이름의 모듈 생성</span></span><br><span class="line">%%writefile dss.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈안에 함수 및 클래스를 생성</span></span><br><span class="line">num = <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp1</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"disp1"</span>,msg)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp2</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"disp2"</span>,msg)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(self,*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(args)</span><br></pre></td></tr></table></figure> 모듈 호출 &gt; <code>import &quot;모듈 이름&quot;</code>으로 호출</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dss </span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈 속 변수</span></span><br><span class="line">dss.num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈 속 함수</span></span><br><span class="line">dss.disp1(<span class="string">"python"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클래스로 객체 생성</span></span><br><span class="line">calc = dss.Calc()</span><br></pre></td></tr></table></figure><h2 id="package패키지">Package(패키지)</h2><p>패키지의 생성 - 패키지 생성시 디렉토리에 <strong>init</strong>.py 파일을 추가해야 합니다. - 단, python 3.3버전 이상에서는 필요 없습니다. - 패키지의 위치 : 특정 디렉토리(pip,conda등으로 설치하는 등)에 있는 패키지는 어디에서나 import 가능합니다.</p><p>주피터 노트북에서 패키지 설치 - <code>school $ python setup.py</code> - 커널 리스타트 해야 패키지가 적용됩니다. &gt; develop : 개발자모드, 코드를 수정하면 설치된 패키지도 같이 수정됩니다. &gt; build : 일반모드, 코드로 수정하면 다시 설치해야 수정된 코드가 적용됩니다.</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-python-module-package/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML 파싱을 이용한 크롤링</title>
      <link>https://howardhowonyu.github.io/2020/02/21/TIL-crawling-2020-02-21-crawling/</link>
      <guid>https://howardhowonyu.github.io/2020/02/21/TIL-crawling-2020-02-21-crawling/</guid>
      <pubDate>Fri, 21 Feb 2020 09:52:59 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;html-데이터-파싱을-이용한-크롤링&quot;&gt;HTML 데이터 파싱을 이용한 크롤링&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;웹페이지 분석 : URL 찾기&lt;/li&gt;
&lt;li&gt;요청 -&amp;gt; 응답 : HTML(str) 가져오기&lt;/li&gt;
&lt;li&gt;HTML(str) -&amp;gt; BeautifulSoup 객체에서 css-selector를 통해 내용을 가져옴 -&amp;gt; 데이터프레임으로 변환
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="html-데이터-파싱을-이용한-크롤링">HTML 데이터 파싱을 이용한 크롤링</h2><ol type="1"><li>웹페이지 분석 : URL 찾기</li><li>요청 -&gt; 응답 : HTML(str) 가져오기</li><li>HTML(str) -&gt; BeautifulSoup 객체에서 css-selector를 통해 내용을 가져옴 -&gt; 데이터프레임으로 변환 <a id="more"></a></li></ol><h2 id="크롤링-과정">크롤링 과정</h2><ul><li>BeautifulSoup라는 클래스의 매서드 활용 response안에 있는 애들을 BeautifulSoup으로 HTML로 파싱</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requests.get 매서드로 요철</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># response.content로 내용 선택, html.parser로 HTML로 파싱</span></span><br><span class="line">dom = BeautifulSoup(response.content, <span class="string">"html.parser"</span>)</span><br></pre></td></tr></table></figure><h4 id="bs4.beautifulsoupr"><code>bs4.BeautifulSoupr</code></h4><blockquote><p>select 매서드 : 여러개의 element 객체를 리스트로 가져옴 select_one 매서드 : 하나의 element 객체를 가져옴</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 크롬 개발자 도구에서 copy selector했을때 id가 나올때 까지 찾아 복사함</span></span><br><span class="line"><span class="comment"># 리스트안의 딕셔너리 형태로 만들어줌&#123;"컬럼명":내용&#125;</span></span><br><span class="line">datas = []</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    datas.append(&#123;</span><br><span class="line">        <span class="string">"title"</span>: element.select_one(<span class="string">'.tit_g'</span>).text.strip().replace(<span class="string">"\n"</span>,<span class="string">""</span>), <span class="comment">#tit_g이름의 클래스 안에 텍스트를 잡음</span></span><br><span class="line">        <span class="string">"link"</span> : element.select_one(<span class="string">'a'</span>).get(<span class="string">"href"</span>), <span class="comment">#href속성의 값을 가져옴</span></span><br><span class="line">    &#125;)</span><br><span class="line">article_df = pd.DataFrame(datas)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/21/TIL-crawling-2020-02-21-crawling/#disqus_thread</comments>
    </item>
    
    <item>
      <title>데이터 전처리 기초 1</title>
      <link>https://howardhowonyu.github.io/2020/02/20/TIL-regression-analysis-2020-02-20-regression-analysis/</link>
      <guid>https://howardhowonyu.github.io/2020/02/20/TIL-regression-analysis-2020-02-20-regression-analysis/</guid>
      <pubDate>Thu, 20 Feb 2020 13:32:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;데이터-전처리에-사용하는-패키지&quot;&gt;데이터 전처리에 사용하는 패키지&lt;/h1&gt;
&lt;h2 id=&quot;missingno&quot;&gt;missingno&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;결측데이터를 검색하여 시각화 함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bar()&lt;/code&gt;,
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="데이터-전처리에-사용하는-패키지">데이터 전처리에 사용하는 패키지</h1><h2 id="missingno">missingno</h2><ul><li>결측데이터를 검색하여 시각화 함</li><li><code>.bar()</code>, <code>.matrix()</code>함수로 확인</li></ul><h2 id="scikit-learn-패키지의-simpleimputer-클래스">scikit-learn 패키지의 SimpleImputer 클래스</h2><ul><li><code>SimpleImputer</code>클래스로 객체를 생성할때, 결측값을 채우고자 할때, <code>strategy</code> 인수를 &quot;mean&quot;으로 하면 중앙값 &quot;median&quot;으로 하면 중앙값, <code>most_frequent</code>로 하면 최빈값을 대체값으로 사용한다.</li></ul><h2 id="patsy">patsy</h2><ul><li>데이터를 선택, 변환, 추가, 스케일링 함</li><li><code>dmatrx()</code> 함수를 사용하면 데이터 프레임에 상수항을 추가하거나 원하는 데이터만 선택하거나 변형할 수 있다.</li><li>스케일링을 위한 함수<ul><li><code>center()</code>: 평균을 0으로 스케일링</li><li><code>standardize()</code>: 평균을 0으로하고 표준편차를 1로 스케일링</li><li><code>scale()</code>: <code>standardize()</code> 과 같음</li></ul></li><li><code>design_info</code>라는 속성에 평균등 정보가 입력되어 있다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/20/TIL-regression-analysis-2020-02-20-regression-analysis/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
