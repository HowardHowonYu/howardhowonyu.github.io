<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Howard&#39;s nest</title>
    <link>https://howardhowonyu.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 30 May 2021 15:10:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>http2</title>
      <link>https://howardhowonyu.github.io/2021/05/30/http2/</link>
      <guid>https://howardhowonyu.github.io/2021/05/30/http2/</guid>
      <pubDate>Sun, 30 May 2021 13:43:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;http-메세지-메시지-바디&quot;&gt;HTTP 메세지, 메시지 바디?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;요청하는 측(클라이언트)에서 보내는 HTTP 메세지를 &quot;Request message&quot;, 요청을 받는 측에서 보내는 메세지를 &quot;Response mess
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="http-메세지-메시지-바디">HTTP 메세지, 메시지 바디?</h2><ul><li>요청하는 측(클라이언트)에서 보내는 HTTP 메세지를 "Request message", 요청을 받는 측에서 보내는 메세지를 "Response message"라고 한다</li><li>HTTP 메세지는 "메세지 헤더"와 "메세지 바디"로 구성되어 있다.</li><li>Message Header<ul><li>리퀘스트 라인 : 리퀘스트 메시지에서 사용하는 method, URI, HTTP 버전 등을 포함</li><li>상태 라인 : 리퀘스트 라인과 상응하는 개념으로, 상태코드 (200, 404등)과 설명, HTTP 버전을 포함</li><li>헤더 필드 : 여러 조건과 속성 등을 나타내는 헤더필드가 포함된다. 리퀘스트와 리스폰스에 공존하는 일반헤더필드, 리스폰스헤더필드가 있고 각각 리퀘스트헤더필드, 엔티티헤더필드 총 4종류의 헤더필드가 있다.</li></ul></li><li>Message Body<ul><li>전달하고자 하는 실제 내용</li></ul></li><li>흔히, "HTTP 메세지"를 인터넷 운송 시스템의 "컨테이너" 라고 생각하고, "HTTP 엔티티"는 이에 담기는 "화물"이라고 칭하기도 한다.</li></ul><h2 id="http-엔티티-엔티티-바디">HTTP 엔티티?, 엔티티 바디?</h2><ul><li>위에서 설명했듯, HTTP 엔티티는 "화물"인데, 이를 전송할때,</li></ul><h2 id="http에서-인코딩은">HTTP에서 인코딩은?</h2><ul><li>통신을 할떄 데이터를 그대로 보내기 보다, 변환, 압축, 분할등의 과정을 거쳐 효율을 높이는게 유리하다.</li><li>HTTP 통신역시 인코딩을 통해 효율을 높일수 있다. 단, 인코딩 처리를 위한 CPU등의 리소스를 더 소비하게 된다.</li></ul><h2 id="인코딩-전송">## 인코딩 전송?</h2><h2 id="멀티파트">멀티파트</h2><ul><li>복수의 파일(이미지, 음성 등)을 첨부타일을 붙여서 함께 보낼수 있다.</li><li>각 파트마다 해더를 포함하고,</li></ul><h2 id="레인지리퀘스트">레인지리퀘스트</h2><ul><li>대용량 데이터를 전송할때 중단하게 되면 처음부터 받아야 하는 문제가 발생했고, 이를 해결하기 위해 고안되었다.</li><li>엔티티의 범위를 지정해서 호출을 한다.</li></ul><h2 id="콘텐츠-네고시에이션">콘텐츠 네고시에이션</h2><ul><li>클라이언트와 서버가 리소스 내용에 대해 교섭하는것, 같은 URI에 접근해 다른 언어 등을 표시하려 할때, 이를 사용한다.</li></ul><ol type="1"><li>서버 구동형 네고시에이션 : 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리</li><li>에이전트 구동형 네고시에이션 : 클라리언트 측에서 콘텐츠 네고시에이션을 하는 구조. 유저가 수동으로 선택한다.</li><li>트랜스페이런트 네고시에이션 : 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식</li></ol><h2 id="reference">Reference</h2><p>https://velog.io/<span class="citation" data-cites="ljinsk3/03">@ljinsk3/03</span>.-HTTP-%EC%A0%95%EB%B3%B4%EB%8A%94-HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%97%90-%EC%9E%88%EB%8B%A4</p><p>https://velog.io/<span class="citation" data-cites="akh9804/HTTP">@akh9804/HTTP</span>-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-15-%EC%97%94%ED%84%B0%ED%8B%B0%EC%99%80-%EC%9D%B8%EC%BD%94%EB%94%A9</p><p>https://ideveloper2.dev/blog/2020-01-04--%EC%97%94%ED%84%B0%ED%8B%B0%EC%99%80-%EC%9D%B8%EC%BD%94%EB%94%A9/</p><p>https://web-km.tistory.com/24</p><p>https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=eqelizer&amp;logNo=20134264633</p><p>https://sleepyeyes.tistory.com/25</p><p>https://kthan.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Http-%EC%9D%B8%EC%BD%94%EB%94%A9encoding-Hex-FirstNibble-U-UTF-8-%EB%93%B1%EB%93%B1</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2021/05/30/http2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://howardhowonyu.github.io/2021/05/23/http/</link>
      <guid>https://howardhowonyu.github.io/2021/05/23/http/</guid>
      <pubDate>Sun, 23 May 2021 12:40:11 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;http-hypertext-tranfer-protocol&quot;&gt;HTTP (HyperText Tranfer Protocol)?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;하이퍼텍스트를 교환하기 위한 프로토콜(TCP, SMTP과 같이 서버와 클라이언트 사이에서 어떻게 정보를 교환할지 정해놓은 규약의 일종)&lt;/li&gt;
&lt;li&gt;80번 포트를 사용&lt;/li&gt;
&lt;li&gt;Request(요청), Response(응답)으로 구성&lt;/li&gt;
&lt;li&gt;작성중
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="http-hypertext-tranfer-protocol">HTTP (HyperText Tranfer Protocol)?</h1><ul><li>하이퍼텍스트를 교환하기 위한 프로토콜(TCP, SMTP과 같이 서버와 클라이언트 사이에서 어떻게 정보를 교환할지 정해놓은 규약의 일종)</li><li>80번 포트를 사용</li><li>Request(요청), Response(응답)으로 구성</li><li>작성중 <a id="more"></a></li></ul><h2 id="http의-동작-방식">HTTP의 동작 방식</h2><ul><li>클라이언트가 서버로 요청 -&gt; 서버가 응답</li></ul><h2 id="http-reqeust-메시지-종류">HTTP Reqeust 메시지 종류</h2><ul><li>GET : URL에 해당하는 자료의 전송을 요청</li><li>POST : 서버에서 처리될 자료를 보내는 요청(게시글 작성 등)</li><li>PUT : 지정한 URL에 특정 데이터를 저장할것을 요청</li><li>PATCH : 지정한 URL의 데이터를 부분 수정하는 요청</li><li>DELETE : 지정한 URL의 정보 제거 요청</li><li>TRACE : 요청한 내용을 반환해줄것을 요청</li><li>CONNECT : 특정 종류의 프록시 서버에 연결을 요청</li><li>HEAD : GET 요청을 했을떄 반환되는 데이터중 헤더부분만 요청</li><li>OPRIONS : 지원하는 요청 메세지의 목록을 요청</li></ul><h2 id="url-uri">URL? URI?</h2><ul><li>URI : Uniform Resource Identifier</li><li>URL : Uniform Resource Locator</li><li>웹이라는 세계의 주소 체계. 웹은 수많은 파일이 연결되어 있는 공간인데, 이 수많은 파일을 구분하는 구분자.</li><li>URI &gt; URL : URI가 좀더 포괄 적인 명칭</li><li>https://howardhowonyu.github.io/post 까지는 url이라고 볼수 있고 특정 포스트에 접근하기 위해 /page=3 등을 추가하게 되면 이는 고유한 식별자이기 떄문에 URI로 볼수 있다(그래서 S3object는 URI라고 표현 하는 듯)</li></ul><h2 id="http-1.x">HTTP 1.x</h2><ul><li>HTTP 1.0은 요청을 보낼떄 마다 연결을 했다가 끊는 작업을 반복</li><li>HTTP 1.1에서 keepalive 기능을 추가하여, 연결을 한번 수립하면, 데이터 교환이 끝날떄 까지 연결을 유지하고 데이터 교환이 끊나면 연결을 끊기 떄문에 속도 개선.</li><li>하지만 요청을 받은 순서대로 처리하는 방식이기 떄문에, 동시전송이 불가능</li><li>Head of Line Blocking 문제 발생 : 순서대로 전송하기 떄문에, 특정 응답이 지연 되면 그 이후에 실행되어야할 응답들도 모두 대기하게 됨</li><li>HTTP는 기본적으로 TCP 상에서 동작하기 떄문에, 3-way Handshake가 반복적으로 일어남</li><li>Header에 많은 정보를 실어서 요청 해야 함(user-agent 등)</li></ul><h2 id="http1.1의-속도-개선을-위한-노력들">HTTP/1.1의 속도 개선을 위한 노력들</h2><ul><li>Image Spriting : 웹페이지 안에 들어가는 많은 아이콘을 하나의 큰 이미지로 만들고, CSS로 해당 아이콘의 좌표값을 지정해 표시 하는 방식, 이렇게 하면 큰 이미지 라도 한번만 요청할수 있으므로 속도에서 이득</li><li>HYML, CSS, JavaScript의 코드를 축소하여 전송</li><li>Data URI Scheme : 이미지 리소스를 Base64로 인코딩하여, text의 형태로 전송</li></ul><h2 id="http-2.0">HTTP 2.0</h2><ul><li>SPDY(구글의 비표준 개방형 네트워크 프로토콜)에 기반, HTTP를 완전 대체하는 프로토콜은 아니고, HTTP 전송을 재정의하는 방식</li><li>Multiplexed Streams : HTTP의 keepalive를 개선하여, 한 커넥션으로 동시에 여러개의 메세지를 주고 받고, 응답은 순서에 상관없음.</li><li>Stream Prioritization : 클라이언트가 요청한 HTML 문서안에 무거운 이미지 파일이 존재하고, 이 파일이 다른 CSS파일등보다 수신이 늦어지는 경우, 리소스간의 우선순위를 설정하여 이를 해결하고 있다.</li><li>Server Push : 서버에서 클라이언트가 요청하지 않아도 리소스를 보낼수 있다. 클라이언트가 요청한 HTML 문서에서 페이지를 띄우는데 필요한 리소스(이미지)가 존재하는 경우, 클라이언트는 이 HTML문서를 수신한후 해석하면서 필요한 리소스를 재 요청 한다. 하지만 HTTP 2.0에선, 'server'가 HTML에 포함된 리소스도 함께 'push'함으로서 클라이언트의 요청을 최소화 한다. 이를 Push Promise라고 부르며, 이와같이 서버에서 클라이언트로 전달한 리소스에 대해서 클라이언트는 다시 요청하지 않는다.</li><li>Header Compression : 앞서 말했듯 HTTP 1.1은 상당히 큰 헤더를 가지고 있다. HTTP 2.0에서는 헤더에 중복값이 존재하는 경우, 이를 제외한 값만 전송(Static/Dynamic Header Table 기법)하고, 이 값마저 Huffman Encoding 기법으로 인코딩하여 압축하여 전송한다. 이를 HPACK압축 방식이라고 부른다.</li></ul><h2 id="http-3.0">HTTP 3.0?</h2><ul><li>UDP 기반 https://evan-moon.github.io/2019/10/08/what-is-http3/</li></ul><h2 id="reference">Reference</h2><p>https://smartshk.tistory.com/2</p><p>https://developers.google.com/web/fundamentals/performance/http2?hl=ko</p><p>https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/</p><p>https://www.betterweb.or.kr/blog/url%EC%9D%B4%EB%9E%80/</p><p>https://programming119.tistory.com/194</p><p>모두의 네트워크</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2021/05/23/http/#disqus_thread</comments>
    </item>
    
    <item>
      <title>회귀분석 프로젝트</title>
      <link>https://howardhowonyu.github.io/2020/06/30/regression-project/</link>
      <guid>https://howardhowonyu.github.io/2020/06/30/regression-project/</guid>
      <pubDate>Tue, 30 Jun 2020 06:53:59 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;craiglist-데이터를-활용한-미국-중고차-가격-예측&quot;&gt;Craiglist 데이터를 활용한 미국 중고차 가격 예측&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Kaggle 데이터셋 중 &quot;Craiglist(미국판 중고나라?)&quot;에서 크롤링된 약 51만건의 중고차 가격 정보를 이용하여 &lt;strong&gt;중고차 가격 예측 프로젝트&lt;/strong&gt;를 진행하였습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;footer&gt;&lt;strong&gt;Craiglist 데이터를 활용한 미국 중고차 가격 예측&lt;/strong&gt;&lt;cite&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS91c2VkY2FyX3JlZ3Jlc3Npb25fcHJvamVjdC9ibG9iL2hvd2FyZC9ob3dhcmQvdXNlZF9jYXJfcmVncmVzc2lvbl9maW5hbC5pcHluYg==&quot; title=&quot;https://nbviewer.jupyter.org/github/HowardHowonYu/usedcar_regression_project/blob/howard/howard/used_car_regression_final.ipynb&quot;&gt;notebook 바로가기&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;전반적인 회귀분석 과정은 위의 링크를 참조해 주시고, 이곳에선 진행과정에서 겪은 여러 &lt;strong&gt;시행착오들과 note에 담지 못한 후기등을 공유&lt;/strong&gt;하고자 합니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="craiglist-데이터를-활용한-미국-중고차-가격-예측">Craiglist 데이터를 활용한 미국 중고차 가격 예측</h1><ul><li>Kaggle 데이터셋 중 "Craiglist(미국판 중고나라?)"에서 크롤링된 약 51만건의 중고차 가격 정보를 이용하여 <strong>중고차 가격 예측 프로젝트</strong>를 진행하였습니다.</li></ul><blockquote><footer><strong>Craiglist 데이터를 활용한 미국 중고차 가격 예측</strong><cite><span class="exturl" data-url="aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS91c2VkY2FyX3JlZ3Jlc3Npb25fcHJvamVjdC9ibG9iL2hvd2FyZC9ob3dhcmQvdXNlZF9jYXJfcmVncmVzc2lvbl9maW5hbC5pcHluYg==" title="https://nbviewer.jupyter.org/github/HowardHowonYu/usedcar_regression_project/blob/howard/howard/used_car_regression_final.ipynb">notebook 바로가기<i class="fa fa-external-link"></i></span></cite></footer></blockquote><ul><li>전반적인 회귀분석 과정은 위의 링크를 참조해 주시고, 이곳에선 진행과정에서 겪은 여러 <strong>시행착오들과 note에 담지 못한 후기등을 공유</strong>하고자 합니다. <a id="more"></a></li></ul><h2 id="review-내용">REVIEW 내용</h2><ul><li>데이터 전처리</li><li>범주형 데이터(Categorical data) 처리</li></ul><h2 id="workflow-chart">1. Workflow Chart</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/img12.png" width="1350px"></p><ul><li><p>크게 <strong>'EDA(데이터 탐색)', '데이터 전처리', '모델링', '모델검증'</strong>의 Step을 정하고 분석을 진행했습니다.</p></li><li><p>좌측부터 총 4번의 싸이클이 진행되었습니다.</p></li><li><p>시작부터 이런 구조를 만들어 낸것은 아니었고, 두번째 싸이클을 시작할때, 앞으로 생길 <strong>문제에 유연하게 대처하고, 다양한 방식을 시도해보기 용이한 방법을 고심</strong>하다 이와 같은 구조가 만들어 졌습니다.</p></li><li><p>분석 과정 중 <strong>한가지 방식에 매몰되지 않고 다양한 가능성을 상정하여, 최대한 여러 방면으로 생각을 확장하려 노력</strong>했고, 이점이 만족할만한 결과를 만들어낸 원동력이었다고 생각합니다.</p></li></ul><h2 id="데이터-전처리---vin차대번호를-활용하여..">2. 데이터 전처리 - Vin(차대번호)를 활용하여..</h2><ul><li>최초의 데이터는 결측치가 많았을뿐 아니라, 중고나라적 특성(?)을 가지고 있는 덕분에, 책정된 가격이 비정상적인 경우가 많았고(123456789, 99999.., 36억 달러 등), 주행거리 데이터도 상식적이지 않은 경우가 많았습니다.</li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img1.png" height="400px" withd="100%"></p><ul><li>첫 싸이클에선 도메인 지식을 활용하여, 가격, 주행거리를 제거하였지만 모델성능이 높지 않았고, 이때 <strong>'vin'</strong>이라는 데이터에 주목했습니다.</li></ul><h3 id="vin으로-허위매물-구별">2.1 Vin으로 허위매물 구별</h3><ul><li><p><strong>'vin'</strong>은 미국내에 운행되는 자동차들이 가지는 고유의 번호입니다. 이를 활용한다면 최소한 광고성 허위매물은 거를수 있을거라는 생각으로 Google을 검색합니다.</p></li><li><p>'Vincheck'를 필두로하여 다양한 'vin'을 검색하는 사이트들을 발견하였고, <strong>'이런 사이트에 "vin"을 검색해서 나오는 정보를 이용해 허위매물을 거르자!'</strong>라는 결론에 다다릅니다.</p></li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img2.png" height="300px" withd="100%"></p><h3 id="api-제공-데이터">2.2 api 제공 데이터</h3><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img3.png" height="400px" withd="100%"></p><ul><li><p>미국내 'vin'을 체크하는 사이트들은 모두 'vinaudit.com'이라는 업체가 제공하는 api를 사용하고 있었고, 이 api가 제공하는 데이터의 출처는</p><ul><li>자동차 이력 제공시스템 : (NMVTIS/National Motor Vehicle Title Information System)</li><li>미국 도로교통 안전국 : (NHTSA / National Highway Traffic Safety Administration)</li><li>미국 교통부 연방차량안전국 : (Federal Motor Carrier Safety Administration, FMCSA)</li><li>그외 미국 정부 기관과 관련된 업체 및 파트너사 라고 합니다.</li></ul></li><li><p>이 api에 'vin'을 던져주어 <strong>'error를 반환 받으면 == '허위매물'</strong> 이었기 때문에, 허위매물을 한번에 제거할수 있었습니다.</p></li><li><p>'vin'과 '주행거리'를 api에 옵션으로 던져주면, 현재 차량의 중고차 시장에서의 판매 가격에 대한, <strong>평균가격</strong>, <strong>표준편차</strong>, <strong>실제 주행거리</strong> 등을 반환해 주었습니다.</p></li><li><p>이를 이용해 '주행거리'와 '가격'에 대한 <strong>아웃라이어를 제거</strong>할수 있었습니다.</p></li><li><p>결정적으로 <strong>'실제 운행되고 존재하는 차량'에 관한 데이터</strong>라는걸 검증할수 있었습니다. 이후 분석은 데이터 전처리에 대한 고민없이 진행할수 있었습니다.</p></li></ul><h2 id="범주형-데이터-처리---변수-선택">3.1 범주형 데이터 처리 - 변수 선택</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img5.png" height="400px"></p><ul><li><p>데이터셋에는 <strong>실린더 갯수</strong>, <strong>변속기 자동 여부</strong>, <strong>차량종류</strong>등과 같이 <strong>차량의 '모델명'하나만으로 설명이 되는</strong> 범주형 변수가 많았습니다. <strong>'여러 범주형 변수'와 '모델명'</strong>을 어떻게 처리할지 고심했습니다.</p></li><li><p>결국 <strong>'여러 범주형 변수'를 선택하고 '모델명'변수는 삭제</strong>했습니다.</p></li><li><p>현대의 '아반떼' 라는 변수 하나만 남기고 나머지 범주형 변수를 삭제한다면, '201x년에 사셔서 X만 마일 타신 아반떼는 예상금액이 Y불 입니다' 라는 결론밖에 내지 못하고, <strong>중고차의 어떤 요소들이 가격 예측에 영향을 미쳤는지에 대한 파악을 하지 못하기 때문</strong>입니다.</p></li><li><p>또한, 여러가지 범주형 변수들과 '연식',' 주행거리'등과 같은 연속형 변수간의 Interaction을 통해 모델을 추가적으로 발전시킬수 있는 가능성도 사라지게 됩니다.</p></li></ul><h2 id="범주형-데이터-처리---교차-검증">3.2 범주형 데이터 처리 - 교차 검증</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img4.png" height="400px"></p><blockquote><p><span style="background:yellow;font-weight:800">종속 변수</span> <span style="background:pink;font-weight:800">연속형 변수</span> <span style="background:#ADD8E6;font-weight:800">범주형 변수</span></p></blockquote><ul><li><p>범주형 데이터는 학습데이터와 검증데이터를 나누는 과정에서도 문제가 되었습니다.</p></li><li><p>빈도수가 적은 (여기서는 페라리 같은 고급 차종들에 대한 데이터) 경우 Cross-validation(교차 검증)을 위해 데이터를 나누는 과정에서 한쪽으로 데이터가 쏠리는 경우가 발생하게 됩니다. 이렇게 되면 오류가 발생하게 됩니다.</p></li><li><p>처음엔 임의로 10개 미만의 빈도수를 가지는 데이터를 삭제하고 진행하는 방법, Bootstraping등의 방법을 시도하였습니다.</p></li><li><p>하지만 데이터를 최대한 살리는 방법을 선택해 결국, 빈도수 10개 미만의 데이터를 따로 분류하여, 데이터셋이 나누어 질때마다 각 데이터 셋에 고르게 분배될수 있도록 하였습니다.</p></li></ul><h2 id="후기">4. 후기</h2><ul><li>첫 회귀분석 프로젝트였던 만큼 시행착오가 많았지만, 그만큼 <strong>분석 주제와 목적에 대해 많이 고민</strong>할수 있었습니다.</li><li>향후 머신러닝, 딥러닝등 다양한 기법과 방법론을 학습하고 응용하겠지만 <strong>데이터의 본질을 이해하기 위한 노력</strong>이 선행될때, 이런 방법론들이 최상의 결과로 이어질수 있다는 점도 알게되었습니다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/06/30/regression-project/#disqus_thread</comments>
    </item>
    
    <item>
      <title>표지판 분류 프로젝트</title>
      <link>https://howardhowonyu.github.io/2020/06/30/keras/</link>
      <guid>https://howardhowonyu.github.io/2020/06/30/keras/</guid>
      <pubDate>Tue, 30 Jun 2020 06:07:03 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;표지판-분류-프로젝트&quot;&gt;표지판 분류 프로젝트&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;딥러닝 학습을 위한 표지판 분류 프로젝트에 대한 회고 입니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;전체 코드는 아래 링크를 참조해 주시고, 이곳에선 &lt;strong&gt;프로젝트의 Workflow와 기타 느낀점등을 공유&lt;/strong&gt;하고자 합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;footer&gt;&lt;strong&gt;CNN을 활용한 표지판 분류 프로젝트&lt;/strong&gt;&lt;cite&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS90cmFmZmljLXNpZ24tcmVjb2duaXRpb24vYmxvYi9tYXN0ZXIvdHJhZmljX3NpZ24uaXB5bmI=&quot; title=&quot;https://nbviewer.jupyter.org/github/HowardHowonYu/traffic-sign-recognition/blob/master/trafic_sign.ipynb&quot;&gt;notebook 바로가기&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="표지판-분류-프로젝트">표지판 분류 프로젝트</h1><ul><li><p>딥러닝 학습을 위한 표지판 분류 프로젝트에 대한 회고 입니다.</p></li><li><p>전체 코드는 아래 링크를 참조해 주시고, 이곳에선 <strong>프로젝트의 Workflow와 기타 느낀점등을 공유</strong>하고자 합니다.</p></li></ul><blockquote><footer><strong>CNN을 활용한 표지판 분류 프로젝트</strong><cite><span class="exturl" data-url="aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS90cmFmZmljLXNpZ24tcmVjb2duaXRpb24vYmxvYi9tYXN0ZXIvdHJhZmljX3NpZ24uaXB5bmI=" title="https://nbviewer.jupyter.org/github/HowardHowonYu/traffic-sign-recognition/blob/master/trafic_sign.ipynb">notebook 바로가기<i class="fa fa-external-link"></i></span></cite></footer></blockquote><a id="more"></a><h2 id="review-내용">REVIEW 내용</h2><ul><li>데이터 수집 및 전처리</li><li>모델링</li></ul><h3 id="데이터-수집-및-전처리">데이터 수집 및 전처리</h3><ul><li>"도로교통공단 교통안전표지 일람표”에서 adobe illustrator를 이용 이미지 추출했습니다.</li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras1.png" width="450px"></p><ul><li><p>응? 하고 의문을 가지실수 있다고 생각합니다. 처음 표지판 분류 프로젝트를 진행하고자 했을때, 역시나 데이터를 다루는 분들이 가지는 문제인 <strong>데이터 확보</strong>에 부딪혔습니다.</p></li><li><p>'도로를 다니며 사진을 수집할수 없다면 사진 만들자! 그리고 실제 사진 가져다가 확인해보면 되지 뭐'라는 생각으로 진행해 보았습니다.</p></li><li><p>keras의 <code>ImageDataGenerator</code>를 이용해서 image augementation을 진행합니다.</p></li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras2.png" width="450px"></p><ul><li><p>실제 도로에서 표지판이 찍힐때의 이미지처럼 왜곡, 회전, 명도 등을 설정했습니다.</p></li><li><p>예를 들어 블랙박스 같은 경우 주로 광각을 많이 사용하기 떄문에, 화면 좌측 혹은 우측으로 갈수록 이미지가 왜곡됩니다. 이같은 현상을 참조하여 값을 정했습니다.</p></li></ul><h3 id="모델링">모델링</h3><ul><li><p>이미지 분야에 최적의 성능을 보인다는 <code>CNN(Convolutional Neural Network)</code>기법을 사용해보았습니다.</p></li><li><p><code>EarlyStopping</code>을 사용해 보았습니다.</p></li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras4.png" width="450px"></p><ul><li>loss값과 validation loss 값이 과적합 없이 수렴하는 것을 확인했습니다.</li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras3.png" width="450px"></p><ul><li><p>test데이터로 확인해본 결과 입니다. <img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras5.png" width="450px"></p></li><li><p>그럼에도 불구하고 틀리게 잘못 예측한 이미지를 눈으로 확인해 보았습니다.</p></li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras6.png" width="450px"></p><ul><li>사람의 눈으로도 판단하기 쉽지 않은 이미지들이 보입니다.</li><li>Image Augementation 진행과정에서 판단이 쉽지않게 만들어진 사진들이 주로 보입니다.</li></ul><h3 id="실제-촬영-이미지로-결과-확인">실제 촬영 이미지로 결과 확인</h3><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/Portfolio/keras7.png" width="450px"></p><h2 id="후기">후기</h2><ul><li><p>Image Augementation의 옵션을 더 조정해 모델 성능 개선을 꾀할수도 있겠지만, 결국 모델의 최적의 성능을 뽑아내기 위해선 실제 도로에서 수집된 이미지가 필요하다는 판단을 하게 되었습니다.</p></li><li><p><code>CNN</code>, Image Augementation등 개념적으로 이해하던 분야를 실제로 적용해보고 튜닝해보는 과정을 거쳐 익히게 되었습니다.</p></li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/06/30/keras/#disqus_thread</comments>
    </item>
    
    <item>
      <title>교차엔트로피와 쿨백-라이블러 발산</title>
      <link>https://howardhowonyu.github.io/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/</link>
      <guid>https://howardhowonyu.github.io/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/</guid>
      <pubDate>Mon, 23 Mar 2020 10:59:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;교차엔트로피cross-entropy&quot;&gt;교차엔트로피(cross entropy)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;두 확률분포 &lt;span class=&quot;math inline&quot;&gt;\(p,q\)&lt;/span&gt;의 교차엔트로피 &lt;span class=&quot;math inline&quot;&gt;\(H[p,q]\)&lt;/span&gt;의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;이산확률분포의 경우는 &lt;span class=&quot;math display&quot;&gt;\[H[p,q] = - \sum_{k=1}^{K}p(y_k)log_2q(y_k)\]&lt;/span&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="교차엔트로피cross-entropy">교차엔트로피(cross entropy)</h3><ul><li><p>두 확률분포 <span class="math inline">\(p,q\)</span>의 교차엔트로피 <span class="math inline">\(H[p,q]\)</span>의</p><ul><li><p>이산확률분포의 경우는 <span class="math display">\[H[p,q] = - \sum_{k=1}^{K}p(y_k)log_2q(y_k)\]</span> <a id="more"></a></p></li><li><p>연속확률분포의 경우는 <span class="math display">\[H[p,q] = - \int_y p(y)log_2 q(y)dy\]</span></p></li></ul></li><li><p>교차엔트로피는 <strong>확률분포</strong> 를 인수로</p></li><li><p>엔트로피, 결합엔트로피, 조건부엔트로피는 <strong>확률변수</strong> 를 인수로</p></li><li><p><span class="math inline">\(q\)</span>가 <span class="math inline">\(p\)</span>(기준)를 얼마나 닮았는지를 나타낸다(유사도와는 다름)</p></li><li><p>교차엔트로피는 분류모형의 성능을 측정하는데 사용된다.</p></li><li><p>이진분류문제를 예로들면</p><ul><li><span class="math inline">\(p\)</span>는 <span class="math inline">\(X\)</span>값이 정해졌을 때 정답인 <span class="math inline">\(Y\)</span>의 확률분포다. 따라서 p는<ul><li>정답이 <span class="math inline">\(Y = 1\)</span>일때, <span class="math display">\[p(Y=0) = 0, p(y=1)=1\]</span></li><li>정답이 <span class="math inline">\(Y = 0\)</span>일때, <span class="math display">\[p(Y=0) = 1, p(y=1)=0\]</span></li></ul></li></ul></li><li><p>따라서 분포 <span class="math inline">\(q\)</span>는 <span class="math inline">\(X\)</span>값이 정해졌을때 예측값의 확률분포다. 모수가 <span class="math inline">\(\mu\)</span>인 베르누이분포라고 가정하면 <span class="math display">\[ q(Y=0) =1 - \mu, q(Y=1) = \mu\]</span></p></li><li><p>확률분포 <span class="math inline">\(p\)</span>와 <span class="math inline">\(q\)</span>의 교차엔트로피는</p><ul><li><p>정답이 <span class="math inline">\(Y = 1\)</span>일 때, <span class="math display">\[H[p,q] = -p(Y=0)log_2q(y=0) -p(Y=1)log_2q(y=1) = -log_2\mu\]</span></p></li><li><p>정답이 <span class="math inline">\(Y = 0\)</span>일 때, <span class="math display">\[H[p,q] = -p(Y=0)log_2q(y=0) -p(Y=1)log_2q(y=1) = -log_2(1-\mu)\]</span></p></li><li><p>이 값은 분류성능이 좋을수록 작아지고, 분류성능이 나쁠수록 커진다.</p><ul><li><span class="math inline">\(Y=1\)</span>일 때는 <span class="math inline">\(\mu\)</span>가 작아질수록 즉, 예측이 틀릴수록 <span class="math inline">\(-log_2\mu\)</span>의 값이 커진다</li><li><span class="math inline">\(Y=0\)</span>일 때는 <span class="math inline">\(\mu\)</span>가 작아질수록 즉, 예측이 틀릴수록 <span class="math inline">\(-log_2(1 - \mu)\)</span>의 값이 커진다</li></ul></li></ul></li><li><p>교차엔트로피값은 예측의 틀린 정도를 나타내는 오차함수의 역할을 할수 있다.</p></li><li><p>로그 손실 : <span class="math inline">\(N\)</span>개의 학습데이터 전체에 대해 교차 엔트로피의 평균을 구하면 <span class="math display">\[\text{log loss} = - {1\over 1}\sum_{i=1}^{N}(y_ilog_2\mu_i + (1 - y_i)log_2(1-\mu_i))\]</span></p></li><li><p>카테고리 로그손실 : 다중분류문제의 교차엔트로피의 손실함수 <span class="math display">\[\text{categorical log loss} = -{1\over N}\sum_{i=1}^{N}\sum_{k=1}^{K}(\mathbb{I}(y_i = k)log_2p(y_i=k))\]</span></p><ul><li>위 식에서 <span class="math inline">\(\mathbb{I}(y_i = k)\)</span>는 <span class="math inline">\(y_i\)</span>가 <span class="math inline">\(k\)</span>인 경우에만 1인 지시함수</li><li><span class="math inline">\(p(y_i=k)\)</span>는 <span class="math inline">\(y_i = k\)</span>일 확률이다</li></ul></li></ul><h3 id="쿨벡-라이블러-발산">쿨벡-라이블러 발산</h3><ul><li><p>두 확률분포 <span class="math inline">\(p(y),q(y)\)</span>의 <strong>분포모양이 얼마나 다른지를 숫자로 계산한 값</strong> 이다.</p></li><li><p>이산확률분포에 대해서는 <span class="math display">\[\begin{aligned}KL(p||q) &amp;= H[p,q] - H[p] \\ &amp;= \sum_{i=1}^{K} p(y_i) \log_2 \left(\dfrac{p(y_i)}{q(y_i)}\right)\end{aligned}\]</span></p></li><li><p>연속확률분포에 대해서는 <span class="math display">\[\begin{aligned}KL(p||q) &amp; = H[p,q] - H[p] \\ &amp; = \int p(y) \log_2 \left(p(y)\over q(y)\right)\end{aligned}\]</span></p></li><li><p>쿨백-라이블러 발산은 교차엔트로피에서 기준이 되는 <span class="math inline">\(p\)</span>분포의 엔트로피 값을 뺀 값이므로 상대엔트로피라고도 한다. 값은 항상 양수이며 두 확률분포가 완전히 같은 경우에만 0이된다.</p></li><li><p>쿨백-라이블러 발산은 거리가 아니라 두 확률분포가 얼마나 다른지를 나타내는 값이므로. 두 확률분포의 위치가 달라지면 일반적으로 값이 달라진다.</p></li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>결합엔트로피와 조건부엔트로피</title>
      <link>https://howardhowonyu.github.io/2020/03/10/TIL-mathematics-2020-03-10-entropy/</link>
      <guid>https://howardhowonyu.github.io/2020/03/10/TIL-mathematics-2020-03-10-entropy/</guid>
      <pubDate>Tue, 10 Mar 2020 12:59:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;결합엔트로피&quot;&gt;결합엔트로피&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;결합확률분포를 사용하여 정의한 엔트로피
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="결합엔트로피">결합엔트로피</h3><ul><li><p>결합확률분포를 사용하여 정의한 엔트로피 <a id="more"></a></p></li><li><p>이산확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는</p><ul><li>이 식에서 <span class="math inline">\(K_X,K_Y\)</span>는 각각 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 가질수 있는 값의 개수</li><li><span class="math inline">\(p\)</span>는 확률질량함수</li></ul><p><span class="math display">\[ H[X,Y] = - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} p(x_i,y_j) log_2p(x_i,y_j)\]</span></p></li><li><p>연속확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는</p><ul><li>이 식에서 <span class="math inline">\(p\)</span>는 확률밀도함수</li></ul><p><span class="math display">\[ H[X,Y] = - \int_x \int_y p(x,y)log_2p(x,y)dxdy\]</span></p></li></ul><h3 id="조건부엔트로피">조건부엔트로피</h3><ul><li><p>확률변수 <span class="math inline">\(X\)</span>가 다른 확률변수 <span class="math inline">\(Y\)</span>의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나(상관관계와는 조금 다른 개념)</p></li><li><p>조건부엔트로피는 조건에 따라 나눈 데이터의 엔트로피의 가중평균</p><ul><li>의사결정나무에서 어떤 것이 더 좋은 분류인가를 판단할때 조건부엔트로피를 활용</li><li>조건부엔트로피가 가장 낮은걸 분류 기준으로 두고 다음 의사 결정 과정을 진행</li></ul></li><li><p>이산확률변수일떄의 조건부엔트로피</p></li></ul><p><span class="math display">\[H[Y | X] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(y_i|x_i)\]</span></p><ul><li>연속확률변수일떄의 조건부엔트로피</li></ul><p><span class="math display">\[H[Y | X] = - \int_x \int_y p(x_i,y_j)log_2p(y_i|x_i)\]</span></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/03/10/TIL-mathematics-2020-03-10-entropy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>엔트로피란?</title>
      <link>https://howardhowonyu.github.io/2020/03/09/TIL-mathematics-2020-03-09-entropy1/</link>
      <guid>https://howardhowonyu.github.io/2020/03/09/TIL-mathematics-2020-03-09-entropy1/</guid>
      <pubDate>Mon, 09 Mar 2020 12:12:42 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;엔트로피entropy&quot;&gt;엔트로피(entropy)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;수학적인 엔트로피는 확률분포가 가지는 정보의 확신도 또는 정보량을 수치로 표현한 것.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;확률분포에서 특정한 값이 나올 확률이 높고, 나머지 값의 확률이 낮아진다면 엔트로피는 작아지고, 반대로 확률이 대부분 비슷한 경우 엔트로피가 높아진다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;확률분포의 모양이 어떤지를 나타낼수 있는 특성값중 하나&lt;/strong&gt; 이다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="엔트로피entropy">엔트로피(entropy)</h2><ul><li><p>수학적인 엔트로피는 확률분포가 가지는 정보의 확신도 또는 정보량을 수치로 표현한 것.</p></li><li><p>확률분포에서 특정한 값이 나올 확률이 높고, 나머지 값의 확률이 낮아진다면 엔트로피는 작아지고, 반대로 확률이 대부분 비슷한 경우 엔트로피가 높아진다.</p></li><li><p><strong>확률분포의 모양이 어떤지를 나타낼수 있는 특성값중 하나</strong> 이다. <a id="more"></a></p></li><li><p>엔트로피 역시 범함수의 일종</p><ul><li>범함수(함수를 입력받아 숫자를 출력하는 함수)의 예<ul><li>기대값 : $E[P_X(x)]= $숫자(함수의 중심위치)</li><li>분산 : $Var[P_X(x)] = $숫자 (함수의 폭)</li><li>엔트로피 : $H[P_X(x)] = $숫자(함수가 얼마나 골고루 분포)</li></ul></li></ul></li></ul><h2 id="이산확률변수와-연속확률변수에서의-엔트로피의-정의">이산확률변수와 연속확률변수에서의 엔트로피의 정의</h2><ul><li><p>이산확률변수(카테고리분포 등) <span class="math display">\[ H[Y] = -\sum_{k=1}^{K} p(y_k) log_2 p(y_k)\]</span></p></li><li><p>연속확률변수(정규분포 등) <span class="math display">\[ H[Y] = \int_{-\infty}^{\infty}p(y)log_2p(y)dy\]</span></p></li><li><p><span class="math inline">\(p(x)=0\)</span>인경우 로그값이 정의되지 않으므로 극한값을 사용한다 <span class="math display">\[ \lim_{n \to 0} plog_2p = 0 \]</span></p></li></ul><h2 id="엔트로피의-성질">엔트로피의 성질</h2><ul><li>엔트로피의 최소값은 0(모든 데이터가 동일한 확률값을 가질때)</li><li>엔트로피의 최대값은 이산 확률변수의 클래스의 갯수에 따라 달라진다. 만약 이산확률분포가 가질수 있는 값이 <span class="math inline">\(2^K\)</span>개면 엔트로피의 최대값은 각 값에 대한 확률이 모두 같은 <span class="math inline">\(1\over 2^K\)</span>이다</li></ul><p><span class="math display">\[H = -2^K \cdot {1\over 2^K}log_2{1\over2^K} = K \]</span></p><h2 id="엔트로피의-추정">엔트로피의 추정</h2><ul><li><p>이론적 확률밀도함수가 없고, 데이터만 있는 경우, 데이터에서 확률질량함수를 추정한후 이를 기반으로 엔트로피를 계산한다.</p><ul><li>80개 데이터중 <span class="math inline">\(Y=0\)</span>인 데이터가 40개, <span class="math inline">\(Y=1\)</span>인 데이터가 40개인 경우 엔트로피는 1이다.</li></ul><p><span class="math display">\[P(y=0) = {40\over80} = {1\over2}\]</span></p><p><span class="math display">\[P(y=1) = {40\over80} = {1\over2}\]</span></p><p><span class="math display">\[H[Y] = -{1\over2}log_2 \left( {1\over2} \right) - {1\over2}log_2 \left({1\over2}\right) = {1\over2} + {1\over2} = 1\]</span></p></li></ul><h2 id="결합엔트로피">결합엔트로피</h2><ul><li><p>결합확률분포를 사용하여 정의한 엔트로피 <!--more--></p></li><li><p>이산확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는</p><ul><li>이 식에서 <span class="math inline">\(K_X,K_Y\)</span>는 각각 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 가질수 있는 값의 개수</li><li><span class="math inline">\(p\)</span>는 확률질량함수</li></ul></li></ul><p><span class="math display">\[H[X,Y] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(x_i,y_j)\]</span></p><ul><li>연속확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(p\)</span>는 확률밀도함수</li></ul></li></ul><p><span class="math display">\[H[X,Y] = - \int_x \int_y p(x,y)log_2p(x,y)dxdy\]</span></p><h3 id="조건부엔트로피">조건부엔트로피</h3><ul><li><p>확률변수 <span class="math inline">\(X\)</span>가 다른 확률변수 <span class="math inline">\(Y\)</span>의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나(상관관계와는 조금 다른 개념)</p></li><li><p>조건부엔트로피는 조건에 따라 나눈 데이터의 엔트로피의 가중평균</p><ul><li>의사결정나무에서 어떤 것이 더 좋은 분류인가를 판단할때 조건부엔트로피를 활용</li><li>조건부엔트로피가 가장 낮은걸 분류 기준으로 두고 진행</li></ul></li><li><p>이산확률변수일떄의 조건부엔트로피</p></li></ul><p><span class="math display">\[H[Y | X] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(y_i|x_i)\]</span></p><ul><li>연속확률변수일떄의 조건부엔트로피</li></ul><p><span class="math display">\[H[Y | X] = - \int_x \int_y p(x_i,y_j)log_2p(y_i|x_i)\]</span></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/03/09/TIL-mathematics-2020-03-09-entropy1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SQLAlchemy</title>
      <link>https://howardhowonyu.github.io/2020/02/29/Database-2020-02-29-sqlalchemy/</link>
      <guid>https://howardhowonyu.github.io/2020/02/29/Database-2020-02-29-sqlalchemy/</guid>
      <pubDate>Sat, 29 Feb 2020 11:12:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;sql-alchemy&quot;&gt;SQL Alchemy&lt;/h2&gt;
&lt;p&gt;python 에서 사용하는 ORM 입니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="sql-alchemy">SQL Alchemy</h2><p>python 에서 사용하는 ORM 입니다. <a id="more"></a></p><p><strong>ORM</strong> 이란? : Object Relational Mapping</p><blockquote><p>데이터 베이스를 객체화 시켜서 데이터 베이스에 있는 데이터를 CRUD(create,read,update,delete)할수 있습니다. 쿼리 대신 함수 형태로 CRUD를 할수 있습니다. 사용하는 데이터 베이스를 변경하는 경우 엔진을 바꾸면 됩니다. 따라서 쿼리문을 몰라도 데이터 베이스를 조작할수 있습니다.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker <span class="comment">#sql에 연결 시켜주는 함수</span></span><br></pre></td></tr></table></figure><h3 id="데이터-베이스-연결">데이터 베이스 연결</h3><p><db종류>://유저이름.비밀번호:퍼블릭 ip/데이터 베이스 이름</db종류></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">"mysql://root:***@&lt;퍼블릭 ip&gt;/test"</span>)</span><br></pre></td></tr></table></figure><h3 id="테이블-객체-생성을-위한-클래스-작성">테이블 객체 생성을 위한 클래스 작성</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    </span><br><span class="line">    __tablename__ = <span class="string">"user"</span> <span class="comment">#테이블 이름</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#컬럼 데이터 타입 작성</span></span><br><span class="line">    user_id = Column(Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line">    email = Column(String(<span class="number">30</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    rdate = Column(DateTime)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 생성자 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,email,age,rdate)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.email = email</span><br><span class="line">        self.age = age</span><br><span class="line">        self.rdate = rdate</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># repr 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User &#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&gt;"</span>.format(</span><br><span class="line">            self.name, self.email, self.age, self.rdate)</span><br></pre></td></tr></table></figure><h3 id="데이터-베이스와-객체를-연결">데이터 베이스와 객체를 연결</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># engine에 연결된 데이터 베이스(test)에 테이블 생성</span></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"><span class="comment"># Base를 상속받은 클래스들이 engine에 테이블 형태로 생성됨</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 베이스에 session 연결</span></span><br><span class="line">Session = sessionmaker(engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클래스를 return  받고</span></span><br><span class="line">session = Session()</span><br><span class="line"><span class="comment"># 객체 생성</span></span><br></pre></td></tr></table></figure><p><strong>session</strong> 은 데이터 베이스와 연결된 객체입니다.데이터 베이스 접속 정보가 들어 있습니다. <strong>session</strong>을 통해 데이터 베이스에 데이터를 넣고, 삭제하고 수정해 보겠습니다.</p><blockquote><p>데이터 베이스 연결 -&gt; 테이블 객체 생성을 위한 클래스 작성 -&gt; 데이터 베이스와 객체를 연결후 사용</p></blockquote><h3 id="insert">1. Insert</h3><p>session객체를 통해 데이터 배이스에 데이터를 넣어보겠습니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># insert</span></span><br><span class="line">user = User(<span class="string">"howard"</span>,<span class="string">"howard@thisisemail.com"</span>,<span class="number">27</span>,<span class="string">"2016-03-21"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># session 객체에 데이터가 저장</span></span><br><span class="line">session.add(user)</span><br><span class="line"><span class="comment"># run tranaction : 이순간 데이터 베이스에 저장</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure> 여러 동작을 한 tranction으로 묶어서 tranaction이 실행되는 동안은 다른 Task가 들어오지 못합니다.(예: 은행 계좌 출금 과정)</p><p>insert 여러개 해보면 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">users = [</span><br><span class="line">    User(<span class="string">"alice"</span>,<span class="string">"alice@gmail.com"</span>,<span class="number">25</span>,<span class="string">"2018-02-21"</span>),</span><br><span class="line">    User(<span class="string">"andy"</span>,<span class="string">"andy@daum.net"</span>,<span class="number">33</span>,<span class="string">"2015-10-21"</span>),</span><br><span class="line">]</span><br><span class="line">session.add_all(users) <span class="comment"># 데이터 저장</span></span><br><span class="line">session.commit() <span class="comment"># commit으로 데이터 베이스에 저장</span></span><br></pre></td></tr></table></figure></p><p>rollback : session안에 있는 객체를 초기화 시킵니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.rollback()</span><br></pre></td></tr></table></figure></p><h3 id="select">2. Select</h3><p>SQL의 Select처럼 데이터 프레임의 데이터들을 봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select all</span></span><br><span class="line">results = session.query(User).all()</span><br></pre></td></tr></table></figure></p><p>filter : ==, !=, &gt;, &lt;, &lt;=, &gt;=, like, in 등 SQL의 쿼리문 기능을 다 쓸수 있습니다. SQL WHERE 처럼 사용 가능합니다 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">results = session.query(User).filter(User.name==<span class="string">"howard"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : like</span></span><br><span class="line">results = session.query(User).filter(User.email.like(<span class="string">"%gmail%"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : in_</span></span><br><span class="line">results = session.query(User).filter(User.name.in_([<span class="string">"alice"</span>,<span class="string">"andy"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : or_</span></span><br><span class="line">results = session.query(User).filter(or_(User.name == <span class="string">"howard"</span>, User.age == <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># order by : desc, asc(내림차순, 오름차순 정렬)</span></span><br><span class="line">results = session.query(User).order_by(User.age.desc())</span><br><span class="line"></span><br><span class="line"><span class="comment"># count</span></span><br><span class="line">session.query(User).count()</span><br></pre></td></tr></table></figure></p><h3 id="updata">3. Updata</h3><p>데이터 베이스의 데이터를 수정해봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data에 andy의 row데이터 가져와서</span></span><br><span class="line">data = session.query(User).filter(User.name == <span class="string">"howard"</span>).one()</span><br><span class="line"><span class="comment"># age라는 칸에 30 넣어주고</span></span><br><span class="line">data.age = <span class="number">30</span></span><br><span class="line"><span class="comment"># session에 담아서</span></span><br><span class="line">session.add(data)</span><br><span class="line"><span class="comment"># commit</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="delete">4. Delete</h3><p>데이터를 삭제해 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete row</span></span><br><span class="line">session.query(User).filter(User.name == <span class="string">'jin'</span>).delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete table</span></span><br><span class="line"><span class="comment"># User클래스에서 지정된 테이블인 user만 지워짐</span></span><br><span class="line">User.__table__.drop(engine)</span><br></pre></td></tr></table></figure><h3 id="with-pandas">5. With Pandas</h3><p>판다스와 함께 사용해봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 데이터 프레임을 데이터 베이스에 넣기</span></span><br><span class="line">iris_df = sns.load_dataset(<span class="string">"iris"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># iris_df 데이터를 iris라는 이름으로 </span></span><br><span class="line"><span class="comment"># engine에서 지정된 데이터 베이스로 보냅니다. </span></span><br><span class="line"><span class="comment"># 만약 존재한다면 대체(replace)합니다.</span></span><br><span class="line">iris_df.to_sql(name=<span class="string">"iris"</span>,con=engine,if_exists=<span class="string">"replace"</span>)</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/29/Database-2020-02-29-sqlalchemy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>정규표현식</title>
      <link>https://howardhowonyu.github.io/2020/02/28/TIL-crawling-2020-02-28-crawling/</link>
      <guid>https://howardhowonyu.github.io/2020/02/28/TIL-crawling-2020-02-28-crawling/</guid>
      <pubDate>Fri, 28 Feb 2020 13:38:37 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;정규표현식-regx&quot;&gt;정규표현식 : regx&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;문자열을 처리할때 특정 &lt;strong&gt;패턴&lt;/strong&gt;으로 문자열을 처리하는 방법
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="정규표현식-regx">정규표현식 : regx</h3><ul><li><p>문자열을 처리할때 특정 <strong>패턴</strong>으로 문자열을 처리하는 방법 <a id="more"></a></p></li><li><p>BeautifulSoup같이 html만이 아닌 JS코드 등 여러개 혼합 되어있는 페이지를 크롤링 할때 사용 가능</p></li><li><p>예제</p><ul><li>문자열에서 정규표현식 패턴으로 이메일 찾아내기</li><li>문자열에서 주민등록번호 패턴을 찾아서 마지막 6자리의 숫자를 <code>*</code>로 치환</li><li>중고나라의 전화번호 패턴을 찾아서 숫자로 치환하기</li></ul></li></ul><h3 id="함수">함수</h3><ul><li><code>findall()</code> : 일치하는 패턴의 문자열을 찾아서 리스트로 리턴해주는 함수</li><li><code>sub()</code> : 특정 패턴에 맞는 문자열을 찾아서 특정 규칙에 따라 치환해주는 함수</li></ul><h4 id="패턴">패턴</h4><ul><li><code>[]</code> : 문자</li><li><code>-</code> : 범위</li><li><code>.</code> : 하나의 문자</li><li><code>?</code> : 0또는 1회 반복</li><li><code>*</code> : 0회 이상 반복</li><li><code>+</code> : 1회 이상 반복</li><li><code>{m}</code> : m회 반복</li><li><code>{m,n}</code> : m~n회 반복</li><li><code>()</code> : 그룹핑</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/28/TIL-crawling-2020-02-28-crawling/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Selenium, Pickle</title>
      <link>https://howardhowonyu.github.io/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/</link>
      <guid>https://howardhowonyu.github.io/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/</guid>
      <pubDate>Wed, 26 Feb 2020 08:53:17 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;selenium&quot;&gt;Selenium&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;브라우저를 직접 실행하여 자동화하고 브라우저상에 있는 데이터를 수집
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="selenium">Selenium</h2><ul><li>브라우저를 직접 실행하여 자동화하고 브라우저상에 있는 데이터를 수집 <a id="more"></a></li><li>웹 테스트 자동화를 위해서 만들어진 라이브러리</li><li>다양한 브라우져 지원</li><li>다양한 언어를 지원</li></ul><h1 id="thread를-사용한-데이터-수집">thread를 사용한 데이터 수집</h1><ul><li>원래 파이썬 프로그램은 기본적으로 Single Thread 에서 실행됨. 즉 하나의 쓰레드가 순차적으로 코드를 실행함.</li><li>여기에서 별도의 쓰레드를 생성해 코드를 병렬로 실행하면 컴퓨터의 리소스가 허락하는 한도내에서 코드를 더 빨리 실행시킬수 있음.</li></ul><h1 id="pickle">Pickle</h1><ul><li>객체를 파일로 저장할때 직렬화(Serialization)라는 과정을 거쳐서 저장.</li><li><strong>직렬화</strong><ul><li>객체(데이터타입)과, 저장되는 파일의(데이터타입)은 다릅니다.</li><li>서로 다른 데이터 타입을 맞춰주는 과정이 필요</li></ul></li><li>파일을 읽고 저장하는데 속도가 더 빠릅니다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/#disqus_thread</comments>
    </item>
    
    <item>
      <title>확률론적 선형 회귀모형</title>
      <link>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/</link>
      <guid>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/</guid>
      <pubDate>Wed, 26 Feb 2020 01:17:59 GMT</pubDate>
      <description>
      
        &lt;h4 id=&quot;ols방법을-사용하여-최적의-가중치를-계산할수-있지만-오차범위를-알지-못하면-가중치를-알아도-아무것도-모르는-거랑-같다&quot;&gt;OLS방법을 사용하여 최적의 가중치를 계산할수 있지만, 오차범위를 알지 못하면 가중치를 알아도 아무것도 모르는 거랑 같다!&lt;/h4&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="ols방법을-사용하여-최적의-가중치를-계산할수-있지만-오차범위를-알지-못하면-가중치를-알아도-아무것도-모르는-거랑-같다">OLS방법을 사용하여 최적의 가중치를 계산할수 있지만, 오차범위를 알지 못하면 가중치를 알아도 아무것도 모르는 거랑 같다!</h4><a id="more"></a><ul><li>가중치의 오차 범위 혹은 신뢰 구간을 계산할 수 없다면 OLS 결과로부터 실질적인 결론을 이끌어내기 어렵다.</li></ul><h2 id="부트스트래핑">부트스트래핑</h2><ul><li>OLS로 구한 가중치의 추정값은 표본 데이터에 따라 달라진다.</li><li>여러 다른 표본 데이터 집합이 있다면 넣어보면서 가중치가 어떻게 달라지는지 알아 볼수 있지만, 현실적으로 다시 데이터를 얻기는 힘듦</li><li>따라서 기존 데이터를 재표본화하여(re-sampling)하여 여러가지 다양한 표본 데이터를 만드는 방법을 부트스트래핑이라 한다.</li></ul><h2 id="확률론적-선형-회귀모형">확률론적 선형 회귀모형</h2><p><strong>확률론적 선형회귀모형을 쓰면 빠르고 안정적으로 가중치 추정값의 오차를 구할수 있다.</strong></p><ul><li>확률론적 선형 회귀모형에서는 데이터가 확률 변수로 부터 생성된 표본이라고 가정한다.</li></ul><p><strong>1. 선형 정규 분포 가정</strong></p><ul><li>종속변수 <span class="math inline">\(y\)</span>가 독립변수<span class="math inline">\(x\)</span>의 선형조합으로 결정되는 "기대값"과 고정된 분산<span class="math inline">\(\sigma^2\)</span>를 가지는 "정규 분포"라는 것이다.</li></ul><p><span class="math display">\[y \sim N(w^Tx,\sigma^2)\]</span> <span class="math display">\[\epsilon = y - w^Tx\]</span> <span class="math display">\[p(\epsilon|\theta) = N(0,\sigma^2)\]</span></p><p><strong>2. 외생성 가정</strong></p><ul><li>잡음 <span class="math inline">\(\epsilon\)</span>의 기대값은 독립변수 <span class="math inline">\(x\)</span>의 크기에 상관없이 항상 0이라고 가정.</li></ul><p><span class="math display">\[E[\epsilon|x] = 0\]</span></p><p><strong>3. 조건부 독립 가정</strong></p><ul><li><span class="math inline">\(i\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_i\)</span>와 <span class="math inline">\(j\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_j\)</span>의 공분산 값이 <span class="math inline">\(x\)</span>와 상관없이 항상 0이라고 가정한다.</li></ul><p><span class="math display">\[Cov[\epsilon_i,\epsilon_j]=0 (i,j = 1,2,...,N)\]</span></p><ul><li>이는 서로 독립이라는 가정과 같다.</li></ul><p><span class="math display">\[E[\epsilon_i\epsilon_j]=0(i,j = 1,2,...,N)\]</span></p><ul><li>잡음 벡터 <span class="math inline">\(\epsilon\)</span>의 공분산 행렬이 대각행렬이 되어야 한다.(비대각 성분 모두 0)</li></ul><p><span class="math display">\[Cov[\epsilon] = E[\epsilon\epsilon^T] = Diagonal matrix \]</span></p><p><strong>4. 등분산성 가정</strong></p><ul><li><span class="math inline">\(i\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_i\)</span>와 <span class="math inline">\(j\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_j\)</span>의 분산 값이 표본과 상관없이 항상 같다고 가정</li></ul><p><span class="math display">\[Cov[\epsilon]=E[\epsilon\epsilon^T]=\sigma^2I\]</span></p><ul><li>잡음 벡터 공분산 행렬이 항등행렬 형태가 되어야 한다는 조건과 같다.</li></ul><h2 id="최대-가능도-방법을-사용한-선형-회귀분석">최대 가능도 방법을 사용한 선형 회귀분석</h2><ul><li>최대 가능도 방법(Maximum Likelihood Estimation)을 사용하여 가중치 벡터 𝑤 의 값을 구해보면, OLS의 직교 방정식과 같은 직교 방정식을 얻을 수 있다</li></ul><h2 id="잔차의-분포">잔차의 분포</h2><p>$ e = M$</p><ul><li>M : 잔차행렬</li><li>잔차 <span class="math inline">\(e\)</span>는 잡음 <span class="math inline">\(\epsilon\)</span>의 선형변환이다.</li><li>정규분포의 선형변환은 마찬가지로 정규분포 이므로 잔차는 정규분포를 따른다.</li></ul><h2 id="회귀계수의-표준오차">회귀계수의 표준오차</h2><ul><li>실제 가중치 계수 <span class="math inline">\(w_i\)</span>와 우리가 추정한 가중치 계수 <span class="math inline">\(\hat{w}_i\)</span>의 차이를 표준오차로 나눈값, 즉 <strong>정규화된 모수 오차는 자유도가 <span class="math inline">\(N-K\)</span>인 표준 스튜던트 t분포를 따른다.</strong></li></ul><h2 id="단일-계수-t-검정">단일 계수 t-검정</h2><ul><li>정규화된 모수 오차를 검정통계량으로 사용하면 <span class="math inline">\(w_i\)</span>가 0인지 아닌지에 대한 검정을 실시할수 있다.</li><li>StatsModels summary 메서드가 출력하는 회귀분석 보고서에서 <code>std err</code>로 표시된 열이 모형계수의 표준오차, <code>t</code>로 표시된 열이 단일 계수 t-검정의 검정 통계량, 그리고 <code>P&gt;|t|</code>로 표시된 열이 유의확률을 뜻한다.</li><li><strong>두 독립변수의 계수값을 비교할때도 사용</strong></li><li><strong>범주형 독립변수의 범주값이 가지는 유의성을 판단하는데 유용하다.</strong></li></ul><h2 id="회귀분석-f-검정">회귀분석 F-검정</h2><ul><li>개별 개수가 아닌 전체 회귀 계수가 모두 의미가 있는지 확인하는 경우 사용.</li><li>전체 독립 변수 중 어느 것도 의미를 가진 것이 없다는 귀무가설을 세운다.</li><li>유의확률이 작으면 작을수록 더 강력하게 기각된 것이므로 더 의미가 있는 모형이라고 할 수 있다.</li><li>따라서 여러 모형의 유의 확률을 비교하여 어느 모형이 더 성능이 좋은가를 비교할 때 이 유의 확률을 사용한다</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>부분회귀</title>
      <link>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/</link>
      <guid>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/</guid>
      <pubDate>Wed, 26 Feb 2020 01:03:53 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;부분회귀&quot;&gt;부분회귀&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;회귀분석을 한 후 새로운 독립변수를 추가하여 다시 회귀분석 한다면?
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="부분회귀">부분회귀</h1><ul><li>회귀분석을 한 후 새로운 독립변수를 추가하여 다시 회귀분석 한다면? <a id="more"></a><ul><li>처음에 나온 w1의 값과 두번째 나온 w'1의 값은 다르다.</li><li>종속변수에 영향을 미치는 모든 독립변수들이 회귀모형에 포함되지 않는한, 모형의 가중치는 항상 편향된(biased)값 이다.</li></ul></li></ul><blockquote><p><strong>새로운 독립변수 그룹을 추가해서 다시 회귀분석을 하면, 기존 가중치 벡터의 값이 달라진다.</strong></p></blockquote><h3 id="두가지-회귀분석-결과가-같을수-있는-경우">두가지 회귀분석 결과가 같을수 있는 경우</h3><ul><li><span class="math inline">\(w&#39;2 = 0\)</span>, 즉 <span class="math inline">\(X_2\)</span>와 <span class="math inline">\(y\)</span>의 상관관계가 없는 경우</li><li><span class="math inline">\(X_1^TX_2 = 0\)</span>, 즉 독립변수 <span class="math inline">\(X_1\)</span>과 독립변수 <span class="math inline">\(X_2\)</span>가 직교하는 경우. 서로 상관관계가 없으면 직교할 가능성이 높다.</li></ul><h2 id="프리슈-워-로벨-정리">프리슈-워-로벨 정리</h2><ul><li>1 : 특정한 독립변수 그룸 <span class="math inline">\(X_1\)</span>로 종속변수 <span class="math inline">\(y\)</span>를 선형회귀분석하여 잔차 <span class="math inline">\(y^*\)</span>를 구한다.</li><li>2 : <span class="math inline">\(X_1\)</span>로 다른 독립변수 <span class="math inline">\(x_2\)</span>를 선형 회귀분석하여 나온 잔차 <span class="math inline">\(x^*_2\)</span>를 구한다.</li><li>3 : <span class="math inline">\(y^*\)</span>를 종속변수로 하고 <span class="math inline">\(x^*_2\)</span> 를 독립변수로 하여 선형회귀분석하여 구한 가중치는 <span class="math inline">\(X_1\)</span>과 <span class="math inline">\(x_2\)</span>를 모두 사용하여 <span class="math inline">\(y\)</span>를 선형 회귀분석하였을때 <span class="math inline">\(x_2\)</span>에 대한 가중치와 같다.</li></ul><h2 id="부분회귀-플롯partial-regression-plot-added-variable-plot">부분회귀 플롯(Partial Regression Plot, Added Variable Plot)</h2><ul><li>특정한 하나의 독립변수의 영향력을 시각화하는 방법</li></ul><blockquote><p><strong>순서</strong></p></blockquote><ol type="1"><li>특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 제외한 나머지 독립변수 <span class="math inline">\(𝑋_1\)</span> 들로 종속변수 <span class="math inline">\(𝑦\)</span> 를 선형 회귀분석하여 잔차 <span class="math inline">\(𝑦^∗\)</span> 를 구한다.</li><li>특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 제외한 나머지 독립변수 <span class="math inline">\(𝑋_1\)</span> 들로 특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 선형 회귀분석하여 잔차 <span class="math inline">\(x_2^*\)</span> 를 구한다.</li><li>잔차 <span class="math inline">\(𝑥_2^*\)</span> 를 독립변수로, 잔차 <span class="math inline">\(𝑦^∗\)</span> 를 종속변수로 하여 선형 회귀분석한다. 이렇게 구한 <span class="math inline">\(𝑥_2^*\)</span> , <span class="math inline">\(𝑦^∗\)</span> 의 스캐터 플롯과 회귀분석 결과를 나타낸 것이 부분회귀 플롯이다.</li></ol><ul><li>부분회귀 플롯에서 가로축의 값은 독립변수 자체의 값이 아닌, 다른 독립변수의 영향을 제거한 일종의 "순수한 독립변수 성분"</li></ul><h2 id="ccpr-플롯">CCPR 플롯</h2><ul><li>부분회귀플롯과 마찬가지, "가로축의 값은 독립변수 그대로의 값"</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>범주형 독립변수</title>
      <link>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/</link>
      <guid>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/</guid>
      <pubDate>Tue, 25 Feb 2020 13:36:19 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;풀랭크-방식&quot;&gt;풀랭크 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;더미변수의 값을 원핫인코딩 방식으로 지정.
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="풀랭크-방식">풀랭크 방식</h3><ul><li>더미변수의 값을 원핫인코딩 방식으로 지정. <a id="more"></a> <span class="math display">\[x_1 = A \to d_{1A} = 1, d_{1B} = 0 \]</span> <span class="math display">\[x_1 = B \to d_{1B} = 0, d_{1B} = 1 \]</span></li><li>위 수식을 대입하면 <span class="math display">\[x_1 = A \to \hat{y} = w_{1A} + w_2x_2 + \dots + w_Dx_D\]</span> <span class="math display">\[x_1 = B \to \hat{y} = w_{1B} + w_2x_2 + \dots + w_Dx_D\]</span></li><li><strong>더미변수의 가중치는 상수항이 된다.</strong></li></ul><h3 id="풀랭크-방식과-축소랭크-방식">풀랭크 방식과 축소랭크 방식</h3><ul><li><p>풀랭크 : 더미변수의 값을 원핫인코딩 방식으로 지정.</p></li><li><p>축소랭크 : 특정한 하나의 범주값을 기준값으로 하고 기준값에 대응하는 더미변수의 가중치는 항상 1로 놓는다.</p></li><li><p>월별기온예측</p><ul><li>풀랭크 방식 : 각 월의 대표값</li><li>축소랭크 방식 : 기준값(1월의 평균기온)에서 "차이"가 얼마나 나는가</li></ul></li></ul><h2 id="두개-이상의-범주형-변수가-있는-경우">두개 이상의 범주형 변수가 있는 경우</h2><ul><li>두개 이상의 범주형 변수가 있는 경우 축소형 방식을 사용</li><li>모든 범주형 변수의 가중치는 기준값 상수항에 더해지는 상수항으로 취급.</li></ul><h2 id="범주형-독립변수와-실수-독립변수의-상호작용">범주형 독립변수와 실수 독립변수의 상호작용</h2><p><strong>Case1)</strong></p><ul><li><p>범주형 독립변수 <span class="math inline">\(x_1\)</span>과 실수 독립변수 <span class="math inline">\(x_2\)</span>를 가지는 회귀모형에서 연속값 독립변수 <span class="math inline">\(x_2\)</span>가 미치는 영향, 즉 가중치가 범주형 독립변수 <span class="math inline">\(x_1\)</span>에 따라 달라진다면</p></li><li><p>범주형 독립변수를 더미변수 <span class="math inline">\(d_1\)</span>으로 인코딩하고 연속값 독립변수 <span class="math inline">\(x_2\)</span>는 <span class="math inline">\(d_1\)</span>과의 상호작용항 <code>d_1:x_2</code>를 추가한다.</p></li><li><p><span class="math inline">\(x_1\)</span>범주값에 따라 <span class="math inline">\(x_2\)</span>의 기울기가 달라지는 모형이 된다.</p></li></ul><p><strong>Case2)</strong></p><ul><li><p>범주형 독립변수도 종속변수에 영향을 미치고, 범주형 독립변수와 실수 독립변수의 "상호작용"도 종속변수에 영향을 미치면</p></li><li><p><span class="math inline">\(x_1\)</span>의 범주값에 따라 상수항과 <span class="math inline">\(x_2\)</span>의 기울기가 모두 달라지는 모형이 된다.</p></li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>스케일링</title>
      <link>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/</link>
      <guid>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/</guid>
      <pubDate>Tue, 25 Feb 2020 13:32:52 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;조건수&quot;&gt;조건수&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;가장큰 고유값와 가장 작은 고유값의 비율&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;조건수가 크면 민감도가 커진다. 즉, 오차가 생기면 해에 미치는 영향이 커진다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="조건수">조건수</h2><ul><li><p>가장큰 고유값와 가장 작은 고유값의 비율</p></li><li><p>조건수가 크면 민감도가 커진다. 즉, 오차가 생기면 해에 미치는 영향이 커진다. <a id="more"></a></p></li><li><p>연립방정식을 이루는 행렬의 조건수가 커지면 상수항 오차가 작은 경우라도 연립방정식 해의 오차는 커진다. &gt; <strong>결론 : 공분산 행렬의 조건수가 크면 회귀분석을 사용한 예측값도 오차가 커진다.</strong></p></li></ul><h4 id="조건수가-커지는-경우">조건수가 커지는 경우</h4><ul><li><p>스케일이 크게 다른 경우 -&gt; 스케일링으로 해결</p></li><li><p>다중공선성, 상관관계가 큰 독립변수들이 있는 경우 -&gt; 변수선택(변수를 버리거나), PCA를 이용한 차원 축소로 해결</p></li><li><p>스케일링이 안된경우 독립변수의 분포 모양이 옆이나 위로 퍼져있다. 이를 원에 가깝게 모을수록 조건수가 작아진다.</p></li><li><p>다중공선성이 있을경우 그래프가 상관관계를 보인다.</p></li><li><p><code>scale()</code>명령 formula안에서 사용하여 스케일링을 할수 있다.</p></li><li><p>위 방식으로 스케일하면 스케일링에 사용된 평균과 표준편차를 저장하였다가 나중에 <code>predict()</code>명령을 사용할때 같은 스케일을 사용하기 때문에 편하다.</p></li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>선형회귀분석의 기초</title>
      <link>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/</link>
      <guid>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/</guid>
      <pubDate>Mon, 24 Feb 2020 11:15:23 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;회귀분석&quot;&gt;회귀분석&lt;/h1&gt;
&lt;p&gt;독립변수에 대응하는 종속변수와 가장 비슷한값 &lt;span class=&quot;math inline&quot;&gt;\(\hat{y}\)&lt;/span&gt;을 출력하는 함수를 찾는 과정 만약 함수 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;가 선형함수면, 이 함수를 선형회귀모형(linear regression model)이라 한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="회귀분석">회귀분석</h1><p>독립변수에 대응하는 종속변수와 가장 비슷한값 <span class="math inline">\(\hat{y}\)</span>을 출력하는 함수를 찾는 과정 만약 함수 <span class="math inline">\(f(x)\)</span>가 선형함수면, 이 함수를 선형회귀모형(linear regression model)이라 한다. <a id="more"></a></p><ul><li>만약 <span class="math inline">\(f(x)\)</span>가 선형함수면 이 함수를 선형회귀모형이라고 한다. 선형회귀모형을 사용하는 회귀분석은 선형회귀분석이라고 한다. <span class="math display">\[\hat{y} = w_0 + w_1x_1 + w_2x_2 + ... + w_Dx_D = w_0+w^Tx\]</span></li></ul><h2 id="상수항-결합">상수항 결합</h2><p>회귀분석모형 수식을 간단하게 만들기 위해 상수항을 독립변수 데이터 제일 처음에 추가하는것을 상수항 결합 작업이라 한다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">X0 = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">X = sm.add_constant(X0)</span><br></pre></td></tr></table></figure></p><h2 id="최소자승법">최소자승법</h2><p>최소자승법(OLS)은 잔차제곱합(RSS)을 최소화 하는 가중치 벡터를 구하는 방법. 잔차의 크기(RSS)를 가장 작게 하는 가중치 벡터를 구하기 위해서, 잔차제곱합 식을 미분하여 그레디언트 벡터를 구하고, 이 그레디언트벡터가 영벡터 일때 RSS는 최소가 된다.</p><h2 id="직교방정식">직교방정식</h2><p>여기서 그레디언트 벡터가 0벡터가 되는 관계를 나타내는 식을 직교방정식(normal equation)이라 한다. 1. 모형에 상수항이 있는 경우 잔차벡터의 원소의 합은 0이다. 즉 잔차의 평균은 0이다 2. x데이터의 평균값에 대한 예측값은 y데이터의 평균값이다.</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>범주형 데이터 처리</title>
      <link>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/</link>
      <guid>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/</guid>
      <pubDate>Mon, 24 Feb 2020 11:13:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;범주형-데이터&quot;&gt;범주형 데이터&lt;/h1&gt;
&lt;p&gt;혈액형, 성별과 같이 종류를 표시하는 데이터
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="범주형-데이터">범주형 데이터</h1><p>혈액형, 성별과 같이 종류를 표시하는 데이터 <a id="more"></a></p><h2 id="범주형-데이터의-변형">범주형 데이터의 변형</h2><ul><li>더미변수화</li><li>카테고리 임베딩</li></ul><h2 id="더미변수화">더미변수화</h2><p>0 또는 1만 가지는 값으로 어떤 특징의 존재 여부를 표시. 이진지시자(Boolean indicator),이진변수(binary variable),지시변수(indicator variable),설계변수(design variable),처치(treatment)등으로 불린다.</p><h2 id="patsy를-활용한-더미변수화">patsy를 활용한 더미변수화</h2><ul><li>풀랭크 방식 patsy패키지의 <code>dmatrix()</code>함수는 범주값을 더미변수로 바꿔준다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> patsy <span class="keyword">import</span> dmatrix</span><br><span class="line">df = pd.DataFrame([<span class="string">"A"</span>, <span class="string">"B"</span>], columns=[<span class="string">"x"</span>])</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line">dmatrix(<span class="string">"x + 0"</span>, df1)</span><br></pre></td></tr></table></figure></li><li>축소랭크 방식 특정한 하나의 범주값을 기준값으로 하고 기준값에 대응하는 더미변수의 가중치는 항상 1로 한다. 더미변수화 할떄 <code>dmatrix()</code>함수의 문자열에 +0을 생략함</li></ul><h2 id="두개의-범주형-변수">두개의 범주형 변수</h2><ul><li>통합 축소형 방식</li><li>상호작용 방식</li></ul><h2 id="카테고리-임베딩">카테고리 임베딩</h2><p>범주값 대신 범주값의 특성을 나타내는 연속값 혹은 연속값 벡터를 사용 예를들어 운동선수의 이름을 나타내는 범주값의 경우, 운동선수의 나이, 연봉, 신체능력치 등을 사용하고, 지역명을 나타내느 범주값은 지역의 면적, 인구수 등을 사용한다.</p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS-selector</title>
      <link>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-crawling-css/</link>
      <guid>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-crawling-css/</guid>
      <pubDate>Sat, 22 Feb 2020 12:16:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;css-selector&quot;&gt;CSS Selector&lt;/h1&gt;
&lt;p&gt;HTML 엘리먼트에 CSS 스타일을 적용시킬때 엘리먼트를 선택하는 방법입니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="css-selector">CSS Selector</h1><p>HTML 엘리먼트에 CSS 스타일을 적용시킬때 엘리먼트를 선택하는 방법입니다. <a id="more"></a></p><h4 id="태그-이름으로-선택">1. 태그 이름으로 선택</h4><p>"data 1 엘리먼트를 선택" - css-selector : <code>div</code></p><h4 id="아이디-값으로-선택">2. 아이디 값으로 선택</h4><p>"data 2를 아이디 값으로 선택" - css-selector : <code>#text</code></p><h4 id="클래스-값으로-선택">3.클래스 값으로 선택</h4><p>"data 3를 클래스 값으로 선택" - css-selector : <code>.no1</code> - <code>.dss-txt</code> : data2, data 3가 선택</p><h4 id="속성값으로-선택">4. 속성값으로 선택</h4><p>"data 4를 속성값으로 선택" - css-selector : <code>[val="d4"]</code>, <code>[id="da4"]</code></p><h4 id="혼합해서-사용">5. 혼합해서 사용</h4><p>"span 태그, class 값이 no5인 엘리먼트 선택" - css-selector : <code>span.no5</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"dss-txt no1"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dss-txt no2"</span> <span class="attr">val</span>=<span class="string">"d3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"da4"</span> <span class="attr">val</span>=<span class="string">"d4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"no5"</span> &gt;</span>data 5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="not-selector">6. not selector</h4><p>선택된 엘리먼트에서 특정 조건의 엘리먼트를 제거해서 선택 data 2 엘리먼트만 제외한 ds 클래스를 선택 - css-selector : <code>.ds:not(.dss2)</code></p><h4 id="nth-child">7.nth-child</h4><p>n번째의 엘리먼트를 선택</p><p>data 3 선택하는 방법 - css-selector : <code>.ds:nth-child(3)</code> 뒤의 조건(.ds라는 클래스를 가진 상위 클래스의 자식중에 3번째)이 먼저, 다음 ds라는 클래스를 가진거를 선택</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>data 0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss1"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss2"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> # 얘도 3번째 ds</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss1"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss2"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span> # 얘도 3번째 ds</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds"</span>&gt;</span> data5<span class="tag">&lt;/<span class="name">div</span>&gt;</span> # 얘도 3번째 ds</span><br></pre></td></tr></table></figure><h4 id="계층구조로-엘리먼트-선택">8. 계층구조로 엘리먼트 선택</h4><p>바로 아래 단계의 엘리먼트 선택 - <code>.wrap-1 &gt; h5</code> : inner 1선택 모든 하위 엘리먼트를 선택 - <code>.wrap-1 h5</code> : inner 1,inner 2선택 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>inner 1 <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>inner 2 <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-crawling-css/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML</title>
      <link>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/</link>
      <guid>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/</guid>
      <pubDate>Sat, 22 Feb 2020 10:38:19 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;html&quot;&gt;HTML&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Hyper Text Markup Language&lt;/li&gt;
&lt;li&gt;웹 문서를 작성하는 마크업 언어입니다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="html">HTML</h1><ul><li>Hyper Text Markup Language</li><li>웹 문서를 작성하는 마크업 언어입니다.</li></ul><a id="more"></a><ul><li>웹페이지를 구성하는 언어에는 3종류가 있습니다.<ul><li>HTML : 화면의 레이아웃이나 텍스트</li><li>CSS : 화면의 색상 크기 등의 스타일</li><li>Javascript : 화면의 클릭, 드래그 등등의 이벤트</li></ul></li></ul><h2 id="html의-구성요소">1.1 HTML의 구성요소</h2><p><strong><code>Document</code></strong> - 페이지 전체</p><p><strong><code>element</code></strong> - 계층적 구조로 이루어져 있으며 모여서 Document가 됩니다. - 시작 태그와 끝 태그로 구성되어 있습니다. <code>&lt;div&gt; &lt;/div&gt;</code></p><p><strong><code>Tag</code></strong> - 시작태그와 끝 태그로 엘리먼트를 구성합니다. - 시작 태그에는 여러가지 속성값들이 들어 있습니다. - 태그와 태그 사이에는 문자열 데이터를 가질수 있습니다. - 태그의 이름에 따라서 태그의 목적이 달라집니다.</p><p><strong><code>Attribute</code></strong> - 시작 태그 안에 포함되는 속성값입니다. - <code>id</code>, <code>class</code> : 엘리먼트를 선택하기 위한 목적으로 만들어진 속성값입니다. - 이 외에도 다양한 속성값이 존재 합니다.</p><h3 id="속성값">1.2 속성값</h3><p><strong><code>id</code></strong> : 웹페이지에서 유일한 값입니다.</p><p><strong><code>class</code></strong> : - 웹 페이지 내에서 여러개의 class가 존재합니다. - 하나의 엘리먼트에 여러개의 class를 부여할수 있습니다.</p><p><strong><code>type</code></strong> : 엘리먼트 형태를 결정합니다. (button, checkbox 등)</p><p><strong><code>style</code></strong> : CSS 스타일 값을 적용할수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-1"</span> <span class="attr">class</span>=<span class="string">"bt no1"</span><span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">style</span>=<span class="string">"color:red;"</span> &gt;</span>HTML 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-2"</span> <span class="attr">class</span>=<span class="string">"bt no2"</span><span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>HTML 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="태그의-종류">1.3 태그의 종류</h3><p><strong><code>Head</code></strong> : 제목을 나타낼때 사용합니다. h1부터 숫자가 커질수록 작아집니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>p</code></strong> : 한줄의 문자열을 출력하기 위한 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>파이썬은 재미있습니다.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>내일은 휴강입니다.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>div</code></strong> : 레이아웃을 나타내는 태그이고, 가장 많이 사용됩니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>table</code></strong> : row와 column이 있는 테이블 모양을 나타낼때 사용되는 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>테이블 제목<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>코드<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>회사명<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>0001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>애플<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">td</span>&gt;</span>0002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>네이버<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>ul</code></strong>,<strong><code>li</code></strong> : 리스트를 나타내는 태그입니다. 하나의 ul에 다수의 li태그를 가집니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>a</code></strong> : 링크를 출력하는 태그입니다. <code>href</code> 속성값에 이동할 URL을 입력합니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"howardhowonyu.github.io"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Howard's nest<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>img</code></strong> : 이미지를 불러오는 태그 입니다. <code>src</code> 속성값에 이미지의 URL을 입력합니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span> =<span class="string">"width:200px;"</span><span class="attr">src</span>=<span class="string">"이곳에 이미지의 URL을 입력합니다."</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>iframe</code></strong> : 외부 URL 링크의 페이지를 보여주기 위한 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://howardhowonyu.github.io/"</span> <span class="attr">width</span>=<span class="string">"100%;"</span> <span class="attr">height</span>=<span class="string">"400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>input</code></strong> : 여러 형태의 값을 입력받는 요소들을 만드는 태그입니다.</p><ul><li>text : 문자를 입력받습니다.</li><li>password : 비밀번호(****)형태로 입력 받습니다.</li><li>radio : n지 선다의 답을 받습니다.</li><li>checkbox : 체크박스를 만듭니다.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"비밀번호"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"data"</span>&gt;</span>radio 1<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"data"</span>&gt;</span>radio 2<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>checkbox 1<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>select,option</code></strong>: 옵션을 선택할수 있는 드랍다운 형태를 만드는 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/#disqus_thread</comments>
    </item>
    
    <item>
      <title>예외처리</title>
      <link>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-try-except-finally-raise/</link>
      <guid>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-try-except-finally-raise/</guid>
      <pubDate>Fri, 21 Feb 2020 10:30:49 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;try-except&quot;&gt;TRY, EXCEPT&lt;/h1&gt;
&lt;p&gt;에러가 발생해도 코드의 실행을 계속 하고 싶을 때 사용합니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="try-except">TRY, EXCEPT</h1><p>에러가 발생해도 코드의 실행을 계속 하고 싶을 때 사용합니다. <a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># try구문을 실행</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    print(ls[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 오류가 발생해도 코드의 실행을 마치고 e라는 변수에 오류 메세지를 담습니다.</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line">    print(e)</span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># error</span></span><br><span class="line"><span class="comment"># name 'ls' is not defined</span></span><br><span class="line"><span class="comment"># Done!</span></span><br></pre></td></tr></table></figure><h1 id="finally">FINALLY</h1><p>try, except 구문 실행된후 finally 구문이 실행됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"Done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># error</span></span><br><span class="line"><span class="comment"># Done!</span></span><br></pre></td></tr></table></figure><blockquote><p>코딩 실행 중간에 에러가 발생하면 변수안에 계속 데이터를 가지고 있고, 이는 낭비입니다.<br>때문에 try던 except건 간에 어쨋든 "실행 되면 finally 변수안에 데이터 지워줘" 라고 할때 사용합니다.</p></blockquote><h1 id="raise">RAISE</h1><p>강제로 에러를 발생시키는 명령입니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line">    <span class="keyword">raise</span>(e)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>except때문에 코드 실행이 완료 되어야 하지만 raise()떄문에 강제로 에러가 발생됩니다.</p></blockquote><h1 id="에러-메세지-생성">에러 메세지 생성</h1><p><strong>"Number grater than 10"</strong><br>10이상의 숫자가 입력되어야 한다는 에러 메세지를 만들어보면, <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Exception 이라는 클래스를 상속 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lownumber</span><span class="params">(Exception)</span>:</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> <span class="comment">#에러 메세지 오버라이팅</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Number grater than 10"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_number</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">raise</span> Lownumber() <span class="comment">#Lownumber 클래스를 사용</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">input_number(<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">input_number(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 에러메세지 출력</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#Lownumber                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="comment">#&lt;ipython-input-19-8684a0e33c0b&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#----&gt; 1 input_number(8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;ipython-input-17-bf4895dc7d57&gt; in input_number(num)</span></span><br><span class="line"><span class="comment">#      1 def input_number(num):</span></span><br><span class="line"><span class="comment">#      2     if num &lt;= 10:</span></span><br><span class="line"><span class="comment">#----&gt; 3         raise Lownumber() #Lownumber 클래스를 사용</span></span><br><span class="line"><span class="comment">#      4     print("10")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Lownumber: Number grater than 10</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-try-except-finally-raise/#disqus_thread</comments>
    </item>
    
    <item>
      <title>모듈과 패키지</title>
      <link>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-python-module-package/</link>
      <guid>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-python-module-package/</guid>
      <pubDate>Fri, 21 Feb 2020 10:19:18 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;module-package&quot;&gt;Module &amp;amp; Package&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;모듈&lt;/strong&gt; : 변수, 함수, 클래스를 모아놓은 (.py)라는 이름의 확장자를 가진 파일입니다. &lt;strong&gt;패키지&lt;/strong&gt; : 모듈의 기능을 디렉토리별로 정리해 놓은 개념입니다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="module-package">Module &amp; Package</h1><p><strong>모듈</strong> : 변수, 함수, 클래스를 모아놓은 (.py)라는 이름의 확장자를 가진 파일입니다. <strong>패키지</strong> : 모듈의 기능을 디렉토리별로 정리해 놓은 개념입니다. <a id="more"></a></p><h2 id="module모듈">Module(모듈)</h2><p>모듈 생성</p><blockquote><p>매직 매서드를 사용한 모듈 생성</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dss.py라는 이름의 모듈 생성</span></span><br><span class="line">%%writefile dss.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈안에 함수 및 클래스를 생성</span></span><br><span class="line">num = <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp1</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"disp1"</span>,msg)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp2</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"disp2"</span>,msg)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(self,*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(args)</span><br></pre></td></tr></table></figure><p>모듈 호출 &gt; <code>import "모듈 이름"</code>으로 호출</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dss </span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈 속 변수</span></span><br><span class="line">dss.num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈 속 함수</span></span><br><span class="line">dss.disp1(<span class="string">"python"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클래스로 객체 생성</span></span><br><span class="line">calc = dss.Calc()</span><br></pre></td></tr></table></figure><h2 id="package패키지">Package(패키지)</h2><p><strong>패키지의 생성</strong></p><ul><li>패키지 생성시 디렉토리에 <strong>init</strong>.py 파일을 추가해야 합니다.</li><li>단, python 3.3버전 이상에서는 필요 없습니다.</li><li>패키지의 위치 : 특정 디렉토리(pip,conda등으로 설치하는 등)에 있는 패키지는 어디에서나 import 가능합니다.</li></ul>]]></content:encoded>
      
      <comments>https://howardhowonyu.github.io/2020/02/21/python-2020-02-21-python-module-package/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
