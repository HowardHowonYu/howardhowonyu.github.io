<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>회귀분석 프로젝트</title>
      <link href="/2020/04/23/regression-project/"/>
      <url>/2020/04/23/regression-project/</url>
      
        <content type="html"><![CDATA[<h1 id="craiglist-데이터를-활용한-미국-중고차-가격-예측">Craiglist 데이터를 활용한 미국 중고차 가격 예측</h1><ul><li>Kaggle 데이터셋 중 &quot;Craiglist(미국판 중고나라?)&quot;에서 크롤링된 약 51만건의 중고차 가격 정보를 이용하여 <strong>중고차 가격 예측 프로젝트</strong>를 진행하였습니다.</li></ul><blockquote><footer><strong>Craiglist 데이터를 활용한 미국 중고차 가격 예측</strong><cite><span class="exturl" data-url="aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvSG93YXJkSG93b25ZdS91c2VkY2FyX3JlZ3Jlc3Npb25fcHJvamVjdC9ibG9iL2hvd2FyZC9ob3dhcmQvdXNlZF9jYXJfcmVncmVzc2lvbl9maW5hbC5pcHluYg==" title="https://nbviewer.jupyter.org/github/HowardHowonYu/usedcar_regression_project/blob/howard/howard/used_car_regression_final.ipynb">notebook 바로가기<i class="fa fa-external-link"></i></span></cite></footer></blockquote><ul><li>전반적인 회귀분석 과정은 위의 링크를 참조해 주시고, 이곳에선 진행과정에서 겪은 여러 <strong>시행착오들과 note에 담지 못한 후기등을 공유</strong>하고자 합니다. <a id="more"></a></li></ul><h2 id="review-내용">REVIEW 내용</h2><ul><li>데이터 전처리</li><li>범주형 데이터(Categorical data) 처리</li></ul><h2 id="workflow-chart">1. Workflow Chart</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/img12.png" width="1350px"></p><ul><li><p>크게 <strong>'EDA(데이터 탐색)', '데이터 전처리', '모델링', '모델검증'</strong>의 Step을 정하고 분석을 진행했습니다.</p></li><li><p>좌측부터 총 4번의 싸이클이 진행되었습니다.</p></li><li><p>시작부터 이런 구조를 만들어 낸것은 아니었고, 두번째 싸이클을 시작할때, 앞으로 생길 <strong>문제에 유연하게 대처하고, 다양한 방식을 시도해보기 용이한 방법을 고심</strong>하다 이와 같은 구조가 만들어 졌습니다.</p></li><li><p>분석 과정 중 <strong>한가지 방식에 매몰되지 않고 다양한 가능성을 상정하여, 최대한 여러 방면으로 생각을 확장하려 노력</strong>했고, 이점이 만족할만한 결과를 만들어낸 원동력이었다고 생각합니다.</p></li></ul><h2 id="데이터-전처리---vin차대번호를-활용하여..">2. 데이터 전처리 - Vin(차대번호)를 활용하여..</h2><ul><li>최초의 데이터는 결측치가 많았을뿐 아니라, 중고나라적 특성(?)을 가지고 있는 덕분에, 책정된 가격이 비정상적인 경우가 많았고(123456789, 99999.., 36억 달러 등), 주행거리 데이터도 상식적이지 않은 경우가 많았습니다.</li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img1.png" height="400px" withd="100%"></p><ul><li>첫 싸이클에선 도메인 지식을 활용하여, 가격, 주행거리를 제거하였지만 모델성능이 높지 않았고, 이때 <strong>'vin'</strong>이라는 데이터에 주목했습니다.</li></ul><h3 id="vin으로-허위매물-구별">2.1 Vin으로 허위매물 구별</h3><ul><li><p><strong>'vin'</strong>은 미국내에 운행되는 자동차들이 가지는 고유의 번호입니다. 이를 활용한다면 최소한 광고성 허위매물은 거를수 있을거라는 생각으로 Google을 검색합니다.</p></li><li><p>'Vincheck'를 필두로하여 다양한 'vin'을 검색하는 사이트들을 발견하였고, <strong>'이런 사이트에 &quot;vin&quot;을 검색해서 나오는 정보를 이용해 허위매물을 거르자!'</strong>라는 결론에 다다릅니다.</p></li></ul><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img2.png" height="400px" withd="100%"></p><h3 id="api-제공-데이터">2.2 api 제공 데이터</h3><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img3.png" height="400px" withd="100%"></p><ul><li>미국내 'vin'을 체크하는 사이트들은 모두 'vinaudit.com'이라는 업체가 제공하는 api를 사용하고 있었고, 이 api가 제공하는 데이터의 출처는<ul><li>자동차 이력 제공시스템 : (NMVTIS/National Motor Vehicle Title Information System)</li><li>미국 도로교통 안전국 : (NHTSA / National Highway Traffic Safety Administration)</li><li>미국 교통부 연방차량안전국 : (Federal Motor Carrier Safety Administration, FMCSA)</li><li>그외 미국 정부 기관과 관련된 업체 및 파트너사 라고 합니다.</li></ul></li><li><p>이 api에 'vin'을 던져주어 <strong>'error를 반환 받으면 == '허위매물'</strong> 이었기 때문에, 허위매물을 한번에 제거할수 있었습니다.</p></li><li><p>'vin'과 '주행거리'를 api에 옵션으로 던져주면, 현재 차량의 중고차 시장에서의 판매 가격에 대한, <strong>평균가격</strong>, <strong>표준편차</strong>, <strong>실제 주행거리</strong> 등을 반환해 주었습니다.</p></li><li><p>이를 이용해 '주행거리'와 '가격'에 대한 <strong>아웃라이어를 제거</strong>할수 있었습니다.</p></li><li><p>결정적으로 <strong>'실제 운행되고 존재하는 차량'에 관한 데이터</strong>라는걸 검증할수 있었습니다. 이후 분석은 데이터 전처리에 대한 고민없이 진행할수 있었습니다.</p></li></ul><h2 id="범주형-데이터-처리---변수-선택">3.1 범주형 데이터 처리 - 변수 선택</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img5.png" height="400px"></p><ul><li><p>데이터셋에는 <strong>실린더 갯수</strong>, <strong>변속기 자동 여부</strong>, <strong>차량종류</strong>등과 같이 <strong>차량의 '모델명'하나만으로 설명이 되는</strong> 범주형 변수가 많았습니다. <strong>'여러 범주형 변수'와 '모델명'</strong>을 어떻게 처리할지 고심했습니다.</p></li><li><p>결국 <strong>'여러 범주형 변수'를 선택하고 '모델명'변수는 삭제</strong>했습니다.</p></li><li><p>현대의 '아반떼' 라는 변수 하나만 남기고 나머지 범주형 변수를 삭제한다면, '201x년에 사셔서 X만 마일 타신 아반떼는 예상금액이 Y불 입니다' 라는 결론밖에 내지 못하고, <strong>중고차의 어떤 요소들이 가격 예측에 영향을 미쳤는지에 대한 파악을 하지 못하기 때문</strong>입니다.</p></li><li><p>또한, 여러가지 범주형 변수들과 '연식',' 주행거리'등과 같은 연속형 변수간의 Interaction을 통해 모델을 추가적으로 발전시킬수 있는 가능성도 사라지게 됩니다.</p></li></ul><h2 id="범주형-데이터-처리---교차-검증">3.2 범주형 데이터 처리 - 교차 검증</h2><p><img src="https://myawsbuckethoward.s3.ap-northeast-2.amazonaws.com/regression_img4.png" height="400px"></p><blockquote><p><span style="background:yellow;font-weight:800">종속 변수</span> <span style="background:pink;font-weight:800">연속형 변수</span> <span style="background:#ADD8E6;font-weight:800">범주형 변수</span></p></blockquote><ul><li><p>범주형 데이터는 학습데이터와 검증데이터를 나누는 과정에서도 문제가 되었습니다.</p></li><li><p>빈도수가 적은 (여기서는 페라리 같은 고급 차종들에 대한 데이터) 경우 Cross-validation(교차 검증)을 위해 데이터를 나누는 과정에서 한쪽으로 데이터가 쏠리는 경우가 발생하게 됩니다. 이렇게 되면 오류가 발생하게 됩니다.</p></li><li><p>처음엔 임의로 10개 미만의 빈도수를 가지는 데이터를 삭제하고 진행하는 방법, Bootstraping등의 방법을 시도하였습니다.</p></li><li><p>하지만 데이터를 최대한 살리는 방법을 선택해 결국, 빈도수 10개 미만의 데이터를 따로 분류하여, 데이터셋이 나누어 질때마다 각 데이터 셋에 고르게 분배될수 있도록 하였습니다.</p></li></ul><h2 id="후기">4. 후기</h2><ul><li>첫 회귀분석 프로젝트였던 만큼 시행착오가 많았지만, 그만큼 <strong>분석 주제와 목적에 대해 많이 고민</strong>할수 있었습니다.</li><li>향후 머신러닝, 딥러닝등 다양한 기법과 방법론을 학습하고 응용하겠지만 <strong>데이터의 본질을 이해하기 위한 노력</strong>이 선행될때, 이런 방법론들이 최상의 결과로 이어질수 있다는 점도 알게되었습니다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 회귀분석 </category>
          
          <category> Portfolio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 회귀분석 </tag>
            
            <tag> Data Science </tag>
            
            <tag> Portfolio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>교차엔트로피와 쿨백-라이블러 발산</title>
      <link href="/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/"/>
      <url>/2020/03/23/TIL-mathematics-2020-03-10-entropy-copy/</url>
      
        <content type="html"><![CDATA[<h3 id="교차엔트로피cross-entropy">교차엔트로피(cross entropy)</h3><ul><li>두 확률분포 <span class="math inline">\(p,q\)</span>의 교차엔트로피 <span class="math inline">\(H[p,q]\)</span>의<ul><li><p>이산확률분포의 경우는 <span class="math display">\[H[p,q] = - \sum_{k=1}^{K}p(y_k)log_2q(y_k)\]</span> <a id="more"></a></p></li><li>연속확률분포의 경우는 <span class="math display">\[H[p,q] = - \int_y p(y)log_2 q(y)dy\]</span></li></ul></li><li>교차엔트로피는 <strong>확률분포</strong> 를 인수로</li><li>엔트로피, 결합엔트로피, 조건부엔트로피는 <strong>확률변수</strong> 를 인수로</li><li><p><span class="math inline">\(q\)</span>가 <span class="math inline">\(p\)</span>(기준)를 얼마나 닮았는지를 나타낸다(유사도와는 다름)</p></li><li>교차엔트로피는 분류모형의 성능을 측정하는데 사용된다.</li><li>이진분류문제를 예로들면<ul><li><span class="math inline">\(p\)</span>는 <span class="math inline">\(X\)</span>값이 정해졌을 때 정답인 <span class="math inline">\(Y\)</span>의 확률분포다. 따라서 p는<ul><li>정답이 <span class="math inline">\(Y = 1\)</span>일때, <span class="math display">\[p(Y=0) = 0, p(y=1)=1\]</span></li><li>정답이 <span class="math inline">\(Y = 0\)</span>일때, <span class="math display">\[p(Y=0) = 1, p(y=1)=0\]</span></li></ul></li></ul></li><li><p>따라서 분포 <span class="math inline">\(q\)</span>는 <span class="math inline">\(X\)</span>값이 정해졌을때 예측값의 확률분포다. 모수가 <span class="math inline">\(\mu\)</span>인 베르누이분포라고 가정하면 <span class="math display">\[ q(Y=0) =1 - \mu, q(Y=1) = \mu\]</span></p></li><li><p>확률분포 <span class="math inline">\(p\)</span>와 <span class="math inline">\(q\)</span>의 교차엔트로피는</p><ul><li>정답이 <span class="math inline">\(Y = 1\)</span>일 때, <span class="math display">\[H[p,q] = -p(Y=0)log_2q(y=0) -p(Y=1)log_2q(y=1) = -log_2\mu\]</span></li><li><p>정답이 <span class="math inline">\(Y = 0\)</span>일 때, <span class="math display">\[H[p,q] = -p(Y=0)log_2q(y=0) -p(Y=1)log_2q(y=1) = -log_2(1-\mu)\]</span></p></li><li>이 값은 분류성능이 좋을수록 작아지고, 분류성능이 나쁠수록 커진다.<ul><li><span class="math inline">\(Y=1\)</span>일 때는 <span class="math inline">\(\mu\)</span>가 작아질수록 즉, 예측이 틀릴수록 <span class="math inline">\(-log_2\mu\)</span>의 값이 커진다</li><li><span class="math inline">\(Y=0\)</span>일 때는 <span class="math inline">\(\mu\)</span>가 작아질수록 즉, 예측이 틀릴수록 <span class="math inline">\(-log_2(1 - \mu)\)</span>의 값이 커진다</li></ul></li></ul></li><li>교차엔트로피값은 예측의 틀린 정도를 나타내는 오차함수의 역할을 할수 있다.</li><li>로그 손실 : <span class="math inline">\(N\)</span>개의 학습데이터 전체에 대해 교차 엔트로피의 평균을 구하면 <span class="math display">\[\text{log loss} = - {1\over 1}\sum_{i=1}^{N}(y_ilog_2\mu_i + (1 - y_i)log_2(1-\mu_i))\]</span></li><li>카테고리 로그손실 : 다중분류문제의 교차엔트로피의 손실함수 <span class="math display">\[\text{categorical log loss} = -{1\over N}\sum_{i=1}^{N}\sum_{k=1}^{K}(\mathbb{I}(y_i = k)log_2p(y_i=k))\]</span><ul><li>위 식에서 <span class="math inline">\(\mathbb{I}(y_i = k)\)</span>는 <span class="math inline">\(y_i\)</span>가 <span class="math inline">\(k\)</span>인 경우에만 1인 지시함수</li><li><span class="math inline">\(p(y_i=k)\)</span>는 <span class="math inline">\(y_i = k\)</span>일 확률이다</li></ul></li></ul><h3 id="쿨벡-라이블러-발산">쿨벡-라이블러 발산</h3><ul><li>두 확률분포 <span class="math inline">\(p(y),q(y)\)</span>의 <strong>분포모양이 얼마나 다른지를 숫자로 계산한 값</strong> 이다.</li><li><p>이산확률분포에 대해서는 <span class="math display">\[\begin{aligned}KL(p||q) &amp;= H[p,q] - H[p] \\ &amp;= \sum_{i=1}^{K} p(y_i) \log_2 \left(\dfrac{p(y_i)}{q(y_i)}\right)\end{aligned}\]</span></p></li><li><p>연속확률분포에 대해서는 <span class="math display">\[\begin{aligned}KL(p||q) &amp; = H[p,q] - H[p] \\ &amp; = \int p(y) \log_2 \left(p(y)\over q(y)\right)\end{aligned}\]</span></p></li><li>쿨백-라이블러 발산은 교차엔트로피에서 기준이 되는 <span class="math inline">\(p\)</span>분포의 엔트로피 값을 뺀 값이므로 상대엔트로피라고도 한다. 값은 항상 양수이며 두 확률분포가 완전히 같은 경우에만 0이된다.</li><li><p>쿨백-라이블러 발산은 거리가 아니라 두 확률분포가 얼마나 다른지를 나타내는 값이므로. 두 확률분포의 위치가 달라지면 일반적으로 값이 달라진다.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> Entropy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Entropy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>결합엔트로피와 조건부엔트로피</title>
      <link href="/2020/03/10/TIL-mathematics-2020-03-10-entropy/"/>
      <url>/2020/03/10/TIL-mathematics-2020-03-10-entropy/</url>
      
        <content type="html"><![CDATA[<h3 id="결합엔트로피">결합엔트로피</h3><ul><li><p>결합확률분포를 사용하여 정의한 엔트로피 <a id="more"></a></p></li><li>이산확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(K_X,K_Y\)</span>는 각각 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 가질수 있는 값의 개수</li><li><span class="math inline">\(p\)</span>는 확률질량함수</li></ul><p><span class="math display">\[ H[X,Y] = - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} p(x_i,y_j) log_2p(x_i,y_j)\]</span></p></li><li>연속확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(p\)</span>는 확률밀도함수</li></ul><p><span class="math display">\[ H[X,Y] = - \int_x \int_y p(x,y)log_2p(x,y)dxdy\]</span></p></li></ul><h3 id="조건부엔트로피">조건부엔트로피</h3><ul><li><p>확률변수 <span class="math inline">\(X\)</span>가 다른 확률변수 <span class="math inline">\(Y\)</span>의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나(상관관계와는 조금 다른 개념)</p></li><li>조건부엔트로피는 조건에 따라 나눈 데이터의 엔트로피의 가중평균<ul><li>의사결정나무에서 어떤 것이 더 좋은 분류인가를 판단할때 조건부엔트로피를 활용</li><li>조건부엔트로피가 가장 낮은걸 분류 기준으로 두고 다음 의사 결정 과정을 진행</li></ul></li><li><p>이산확률변수일떄의 조건부엔트로피</p></li></ul><p><span class="math display">\[H[Y | X] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(y_i|x_i)\]</span></p><ul><li>연속확률변수일떄의 조건부엔트로피</li></ul><p><span class="math display">\[H[Y | X] = - \int_x \int_y p(x_i,y_j)log_2p(y_i|x_i)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> Entropy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Entropy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>엔트로피란?</title>
      <link href="/2020/03/09/TIL-mathematics-2020-03-09-entropy1/"/>
      <url>/2020/03/09/TIL-mathematics-2020-03-09-entropy1/</url>
      
        <content type="html"><![CDATA[<h2 id="엔트로피entropy">엔트로피(entropy)</h2><ul><li>수학적인 엔트로피는 확률분포가 가지는 정보의 확신도 또는 정보량을 수치로 표현한 것.</li><li>확률분포에서 특정한 값이 나올 확률이 높고, 나머지 값의 확률이 낮아진다면 엔트로피는 작아지고, 반대로 확률이 대부분 비슷한 경우 엔트로피가 높아진다.</li><li><p><strong>확률분포의 모양이 어떤지를 나타낼수 있는 특성값중 하나</strong> 이다. <a id="more"></a></p></li><li>엔트로피 역시 범함수의 일종<ul><li>범함수(함수를 입력받아 숫자를 출력하는 함수)의 예<ul><li>기대값 : $E[P_X(x)]= $숫자(함수의 중심위치)</li><li>분산 : $Var[P_X(x)] = $숫자 (함수의 폭)</li><li>엔트로피 : $H[P_X(x)] = $숫자(함수가 얼마나 골고루 분포)</li></ul></li></ul></li></ul><h2 id="이산확률변수와-연속확률변수에서의-엔트로피의-정의">이산확률변수와 연속확률변수에서의 엔트로피의 정의</h2><ul><li><p>이산확률변수(카테고리분포 등) <span class="math display">\[ H[Y] = -\sum_{k=1}^{K} p(y_k) log_2 p(y_k)\]</span></p></li><li><p>연속확률변수(정규분포 등) <span class="math display">\[ H[Y] = \int_{-\infty}^{\infty}p(y)log_2p(y)dy\]</span></p></li><li><p><span class="math inline">\(p(x)=0\)</span>인경우 로그값이 정의되지 않으므로 극한값을 사용한다 <span class="math display">\[ \lim_{n \to 0} plog_2p = 0 \]</span></p></li></ul><h2 id="엔트로피의-성질">엔트로피의 성질</h2><ul><li>엔트로피의 최소값은 0(모든 데이터가 동일한 확률값을 가질때)</li><li>엔트로피의 최대값은 이산 확률변수의 클래스의 갯수에 따라 달라진다. 만약 이산확률분포가 가질수 있는 값이 <span class="math inline">\(2^K\)</span>개면 엔트로피의 최대값은 각 값에 대한 확률이 모두 같은 <span class="math inline">\(1\over 2^K\)</span>이다</li></ul><p><span class="math display">\[H = -2^K \cdot {1\over 2^K}log_2{1\over2^K} = K \]</span></p><h2 id="엔트로피의-추정">엔트로피의 추정</h2><ul><li>이론적 확률밀도함수가 없고, 데이터만 있는 경우, 데이터에서 확률질량함수를 추정한후 이를 기반으로 엔트로피를 계산한다.<ul><li>80개 데이터중 <span class="math inline">\(Y=0\)</span>인 데이터가 40개, <span class="math inline">\(Y=1\)</span>인 데이터가 40개인 경우 엔트로피는 1이다.</li></ul><p><span class="math display">\[P(y=0) = {40\over80} = {1\over2}\]</span></p><p><span class="math display">\[P(y=1) = {40\over80} = {1\over2}\]</span></p><p><span class="math display">\[H[Y] = -{1\over2}log_2 \left( {1\over2} \right) - {1\over2}log_2 \left({1\over2}\right) = {1\over2} + {1\over2} = 1\]</span></p></li></ul><h2 id="결합엔트로피">결합엔트로피</h2><ul><li><p>결합확률분포를 사용하여 정의한 엔트로피 <!--more--></p></li><li>이산확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(K_X,K_Y\)</span>는 각각 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 가질수 있는 값의 개수</li><li><span class="math inline">\(p\)</span>는 확률질량함수</li></ul></li></ul><p><span class="math display">\[H[X,Y] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(x_i,y_j)\]</span></p><ul><li>연속확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합엔트로피는<ul><li>이 식에서 <span class="math inline">\(p\)</span>는 확률밀도함수</li></ul></li></ul><p><span class="math display">\[H[X,Y] = - \int_x \int_y p(x,y)log_2p(x,y)dxdy\]</span></p><h3 id="조건부엔트로피">조건부엔트로피</h3><ul><li><p>확률변수 <span class="math inline">\(X\)</span>가 다른 확률변수 <span class="math inline">\(Y\)</span>의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나(상관관계와는 조금 다른 개념)</p></li><li>조건부엔트로피는 조건에 따라 나눈 데이터의 엔트로피의 가중평균<ul><li>의사결정나무에서 어떤 것이 더 좋은 분류인가를 판단할때 조건부엔트로피를 활용</li><li>조건부엔트로피가 가장 낮은걸 분류 기준으로 두고 진행</li></ul></li><li><p>이산확률변수일떄의 조건부엔트로피</p></li></ul><p><span class="math display">\[H[Y | X] = - \sum_{i=1}^{K_X}\sum_{j=1}^{K_Y}p(x_i,y_j)log_2p(y_i|x_i)\]</span></p><ul><li>연속확률변수일떄의 조건부엔트로피</li></ul><p><span class="math display">\[H[Y | X] = - \int_x \int_y p(x_i,y_j)log_2p(y_i|x_i)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> Entropy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Entropy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLAlchemy</title>
      <link href="/2020/02/29/Database-2020-02-29-sqlalchemy/"/>
      <url>/2020/02/29/Database-2020-02-29-sqlalchemy/</url>
      
        <content type="html"><![CDATA[<h2 id="sql-alchemy">SQL Alchemy</h2><p>python 에서 사용하는 ORM 입니다. <a id="more"></a></p><p><strong>ORM</strong> 이란? : Object Relational Mapping &gt; 데이터 베이스를 객체화 시켜서 데이터 베이스에 있는 데이터를 CRUD(create,read,update,delete)할수 있습니다. &gt; 쿼리 대신 함수 형태로 CRUD를 할수 있습니다. &gt; 사용하는 데이터 베이스를 변경하는 경우 엔진을 바꾸면 됩니다. &gt; 따라서 쿼리문을 몰라도 데이터 베이스를 조작할수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker <span class="comment">#sql에 연결 시켜주는 함수</span></span><br></pre></td></tr></table></figure><h3 id="데이터-베이스-연결">데이터 베이스 연결</h3><p><db종류>://유저이름.비밀번호:퍼블릭 ip/데이터 베이스 이름</db종류></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">"mysql://root:***@&lt;퍼블릭 ip&gt;/test"</span>)</span><br></pre></td></tr></table></figure><h3 id="테이블-객체-생성을-위한-클래스-작성">테이블 객체 생성을 위한 클래스 작성</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    </span><br><span class="line">    __tablename__ = <span class="string">"user"</span> <span class="comment">#테이블 이름</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#컬럼 데이터 타입 작성</span></span><br><span class="line">    user_id = Column(Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line">    email = Column(String(<span class="number">30</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    rdate = Column(DateTime)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 생성자 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,email,age,rdate)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.email = email</span><br><span class="line">        self.age = age</span><br><span class="line">        self.rdate = rdate</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># repr 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User &#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&gt;"</span>.format(</span><br><span class="line">            self.name, self.email, self.age, self.rdate)</span><br></pre></td></tr></table></figure><h3 id="데이터-베이스와-객체를-연결">데이터 베이스와 객체를 연결</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># engine에 연결된 데이터 베이스(test)에 테이블 생성</span></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"><span class="comment"># Base를 상속받은 클래스들이 engine에 테이블 형태로 생성됨</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 베이스에 session 연결</span></span><br><span class="line">Session = sessionmaker(engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클래스를 return  받고</span></span><br><span class="line">session = Session()</span><br><span class="line"><span class="comment"># 객체 생성</span></span><br></pre></td></tr></table></figure><p><strong>session</strong> 은 데이터 베이스와 연결된 객체입니다.데이터 베이스 접속 정보가 들어 있습니다. <strong>session</strong>을 통해 데이터 베이스에 데이터를 넣고, 삭제하고 수정해 보겠습니다.</p><blockquote><p>데이터 베이스 연결 -&gt; 테이블 객체 생성을 위한 클래스 작성 -&gt; 데이터 베이스와 객체를 연결후 사용</p></blockquote><h3 id="insert">1. Insert</h3><p>session객체를 통해 데이터 배이스에 데이터를 넣어보겠습니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># insert</span></span><br><span class="line">user = User(<span class="string">"howard"</span>,<span class="string">"howard@thisisemail.com"</span>,<span class="number">27</span>,<span class="string">"2016-03-21"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># session 객체에 데이터가 저장</span></span><br><span class="line">session.add(user)</span><br><span class="line"><span class="comment"># run tranaction : 이순간 데이터 베이스에 저장</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure> 여러 동작을 한 tranction으로 묶어서 tranaction이 실행되는 동안은 다른 Task가 들어오지 못합니다.(예: 은행 계좌 출금 과정)</p><p>insert 여러개 해보면 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">users = [</span><br><span class="line">    User(<span class="string">"alice"</span>,<span class="string">"alice@gmail.com"</span>,<span class="number">25</span>,<span class="string">"2018-02-21"</span>),</span><br><span class="line">    User(<span class="string">"andy"</span>,<span class="string">"andy@daum.net"</span>,<span class="number">33</span>,<span class="string">"2015-10-21"</span>),</span><br><span class="line">]</span><br><span class="line">session.add_all(users) <span class="comment"># 데이터 저장</span></span><br><span class="line">session.commit() <span class="comment"># commit으로 데이터 베이스에 저장</span></span><br></pre></td></tr></table></figure></p><p>rollback : session안에 있는 객체를 초기화 시킵니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.rollback()</span><br></pre></td></tr></table></figure></p><h3 id="select">2. Select</h3><p>SQL의 Select처럼 데이터 프레임의 데이터들을 봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select all</span></span><br><span class="line">results = session.query(User).all()</span><br></pre></td></tr></table></figure></p><p>filter : ==, !=, &gt;, &lt;, &lt;=, &gt;=, like, in 등 SQL의 쿼리문 기능을 다 쓸수 있습니다. SQL WHERE 처럼 사용 가능합니다 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">results = session.query(User).filter(User.name==<span class="string">"howard"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : like</span></span><br><span class="line">results = session.query(User).filter(User.email.like(<span class="string">"%gmail%"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : in_</span></span><br><span class="line">results = session.query(User).filter(User.name.in_([<span class="string">"alice"</span>,<span class="string">"andy"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter : or_</span></span><br><span class="line">results = session.query(User).filter(or_(User.name == <span class="string">"howard"</span>, User.age == <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># order by : desc, asc(내림차순, 오름차순 정렬)</span></span><br><span class="line">results = session.query(User).order_by(User.age.desc())</span><br><span class="line"></span><br><span class="line"><span class="comment"># count</span></span><br><span class="line">session.query(User).count()</span><br></pre></td></tr></table></figure></p><h3 id="updata">3. Updata</h3><p>데이터 베이스의 데이터를 수정해봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data에 andy의 row데이터 가져와서</span></span><br><span class="line">data = session.query(User).filter(User.name == <span class="string">"howard"</span>).one()</span><br><span class="line"><span class="comment"># age라는 칸에 30 넣어주고</span></span><br><span class="line">data.age = <span class="number">30</span></span><br><span class="line"><span class="comment"># session에 담아서</span></span><br><span class="line">session.add(data)</span><br><span class="line"><span class="comment"># commit</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="delete">4. Delete</h3><p>데이터를 삭제해 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete row</span></span><br><span class="line">session.query(User).filter(User.name == <span class="string">'jin'</span>).delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete table</span></span><br><span class="line"><span class="comment"># User클래스에서 지정된 테이블인 user만 지워짐</span></span><br><span class="line">User.__table__.drop(engine)</span><br></pre></td></tr></table></figure><h3 id="with-pandas">5. With Pandas</h3><p>판다스와 함께 사용해봅시다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 데이터 프레임을 데이터 베이스에 넣기</span></span><br><span class="line">iris_df = sns.load_dataset(<span class="string">"iris"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># iris_df 데이터를 iris라는 이름으로 </span></span><br><span class="line"><span class="comment"># engine에서 지정된 데이터 베이스로 보냅니다. </span></span><br><span class="line"><span class="comment"># 만약 존재한다면 대체(replace)합니다.</span></span><br><span class="line">iris_df.to_sql(name=<span class="string">"iris"</span>,con=engine,if_exists=<span class="string">"replace"</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
            <tag> SQLALchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>정규표현식</title>
      <link href="/2020/02/28/TIL-crawling-2020-02-28-crawling/"/>
      <url>/2020/02/28/TIL-crawling-2020-02-28-crawling/</url>
      
        <content type="html"><![CDATA[<h3 id="정규표현식-regx">정규표현식 : regx</h3><ul><li><p>문자열을 처리할때 특정 <strong>패턴</strong>으로 문자열을 처리하는 방법 <a id="more"></a></p></li><li>BeautifulSoup같이 html만이 아닌 JS코드 등 여러개 혼합 되어있는 페이지를 크롤링 할때 사용 가능</li><li>예제<ul><li>문자열에서 정규표현식 패턴으로 이메일 찾아내기</li><li>문자열에서 주민등록번호 패턴을 찾아서 마지막 6자리의 숫자를 <code>*</code>로 치환</li><li>중고나라의 전화번호 패턴을 찾아서 숫자로 치환하기</li></ul></li></ul><h3 id="함수">함수</h3><ul><li><code>findall()</code> : 일치하는 패턴의 문자열을 찾아서 리스트로 리턴해주는 함수</li><li><code>sub()</code> : 특정 패턴에 맞는 문자열을 찾아서 특정 규칙에 따라 치환해주는 함수</li></ul><h4 id="패턴">패턴</h4><ul><li><code>[]</code> : 문자</li><li><code>-</code> : 범위</li><li><code>.</code> : 하나의 문자</li><li><code>?</code> : 0또는 1회 반복</li><li><code>*</code> : 0회 이상 반복</li><li><code>+</code> : 1회 이상 반복</li><li><code>{m}</code> : m회 반복</li><li><code>{m,n}</code> : m~n회 반복</li><li><code>()</code> : 그룹핑</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Crawling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium</title>
      <link href="/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/"/>
      <url>/2020/02/26/TIL-crawling-2020-02-26-crawling-selenium/</url>
      
        <content type="html"><![CDATA[<h2 id="selenium">Selenium</h2><ul><li>브라우저를 직접 실행하여 자동화하고 브라우저상에 있는 데이터를 수집 <a id="more"></a></li><li>웹 테스트 자동화를 위해서 만들어진 라이브러리</li><li>다양한 브라우져 지원</li><li>다양한 언어를 지원</li></ul><h1 id="thread를-사용한-데이터-수집">thread를 사용한 데이터 수집</h1><ul><li>원래 파이썬 프로그램은 기본적으로 Single Thread 에서 실행됨. 즉 하나의 쓰레드가 순차적으로 코드를 실행함.</li><li>여기에서 별도의 쓰레드를 생성해 코드를 병렬로 실행하면 컴퓨터의 리소스가 허락하는 한도내에서 코드를 더 빨리 실행시킬수 있음.</li></ul><h1 id="pickle">Pickle</h1><ul><li>객체를 파일로 저장할때 직렬화(Serialization)라는 과정을 거쳐서 저장.</li><li><strong>직렬화</strong><ul><li>객체(데이터타입)과, 저장되는 파일의(데이터타입)은 다릅니다.</li><li>서로 다른 데이터 타입을 맞춰주는 과정이 필요</li></ul></li><li>파일을 읽고 저장하는데 속도가 더 빠릅니다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Crawling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>확률론적 선형 회귀모형</title>
      <link href="/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/"/>
      <url>/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning2/</url>
      
        <content type="html"><![CDATA[<h4 id="ols방법을-사용하여-최적의-가중치를-계산할수-있지만-오차범위를-알지-못하면-가중치를-알아도-아무것도-모르는-거랑-같다">OLS방법을 사용하여 최적의 가중치를 계산할수 있지만, 오차범위를 알지 못하면 가중치를 알아도 아무것도 모르는 거랑 같다!</h4><a id="more"></a><ul><li>가중치의 오차 범위 혹은 신뢰 구간을 계산할 수 없다면 OLS 결과로부터 실질적인 결론을 이끌어내기 어렵다.</li></ul><h2 id="부트스트래핑">부트스트래핑</h2><ul><li>OLS로 구한 가중치의 추정값은 표본 데이터에 따라 달라진다.</li><li>여러 다른 표본 데이터 집합이 있다면 넣어보면서 가중치가 어떻게 달라지는지 알아 볼수 있지만, 현실적으로 다시 데이터를 얻기는 힘듦</li><li>따라서 기존 데이터를 재표본화하여(re-sampling)하여 여러가지 다양한 표본 데이터를 만드는 방법을 부트스트래핑이라 한다.</li></ul><h2 id="확률론적-선형-회귀모형">확률론적 선형 회귀모형</h2><p><strong>확률론적 선형회귀모형을 쓰면 빠르고 안정적으로 가중치 추정값의 오차를 구할수 있다.</strong></p><ul><li>확률론적 선형 회귀모형에서는 데이터가 확률 변수로 부터 생성된 표본이라고 가정한다.</li></ul><p><strong>1. 선형 정규 분포 가정</strong></p><ul><li>종속변수 <span class="math inline">\(y\)</span>가 독립변수<span class="math inline">\(x\)</span>의 선형조합으로 결정되는 &quot;기대값&quot;과 고정된 분산<span class="math inline">\(\sigma^2\)</span>를 가지는 &quot;정규 분포&quot;라는 것이다.</li></ul><p><span class="math display">\[y \sim N(w^Tx,\sigma^2)\]</span> <span class="math display">\[\epsilon = y - w^Tx\]</span> <span class="math display">\[p(\epsilon|\theta) = N(0,\sigma^2)\]</span></p><p><strong>2. 외생성 가정</strong></p><ul><li>잡음 <span class="math inline">\(\epsilon\)</span>의 기대값은 독립변수 <span class="math inline">\(x\)</span>의 크기에 상관없이 항상 0이라고 가정.</li></ul><p><span class="math display">\[E[\epsilon|x] = 0\]</span></p><p><strong>3. 조건부 독립 가정</strong></p><ul><li><span class="math inline">\(i\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_i\)</span>와 <span class="math inline">\(j\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_j\)</span>의 공분산 값이 <span class="math inline">\(x\)</span>와 상관없이 항상 0이라고 가정한다.</li></ul><p><span class="math display">\[Cov[\epsilon_i,\epsilon_j]=0 (i,j = 1,2,...,N)\]</span></p><ul><li>이는 서로 독립이라는 가정과 같다.</li></ul><p><span class="math display">\[E[\epsilon_i\epsilon_j]=0(i,j = 1,2,...,N)\]</span></p><ul><li>잡음 벡터 <span class="math inline">\(\epsilon\)</span>의 공분산 행렬이 대각행렬이 되어야 한다.(비대각 성분 모두 0)</li></ul><p><span class="math display">\[Cov[\epsilon] = E[\epsilon\epsilon^T] = Diagonal matrix \]</span></p><p><strong>4. 등분산성 가정</strong></p><ul><li><span class="math inline">\(i\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_i\)</span>와 <span class="math inline">\(j\)</span>번쨰 표본의 잡음 <span class="math inline">\(\epsilon_j\)</span>의 분산 값이 표본과 상관없이 항상 같다고 가정</li></ul><p><span class="math display">\[Cov[\epsilon]=E[\epsilon\epsilon^T]=\sigma^2I\]</span></p><ul><li>잡음 벡터 공분산 행렬이 항등행렬 형태가 되어야 한다는 조건과 같다.</li></ul><h2 id="최대-가능도-방법을-사용한-선형-회귀분석">최대 가능도 방법을 사용한 선형 회귀분석</h2><ul><li>최대 가능도 방법(Maximum Likelihood Estimation)을 사용하여 가중치 벡터 𝑤 의 값을 구해보면, OLS의 직교 방정식과 같은 직교 방정식을 얻을 수 있다</li></ul><h2 id="잔차의-분포">잔차의 분포</h2><p>$ e = M$</p><ul><li>M : 잔차행렬</li><li>잔차 <span class="math inline">\(e\)</span>는 잡음 <span class="math inline">\(\epsilon\)</span>의 선형변환이다.</li><li>정규분포의 선형변환은 마찬가지로 정규분포 이므로 잔차는 정규분포를 따른다.</li></ul><h2 id="회귀계수의-표준오차">회귀계수의 표준오차</h2><ul><li>실제 가중치 계수 <span class="math inline">\(w_i\)</span>와 우리가 추정한 가중치 계수 <span class="math inline">\(\hat{w}_i\)</span>의 차이를 표준오차로 나눈값, 즉 <strong>정규화된 모수 오차는 자유도가 <span class="math inline">\(N-K\)</span>인 표준 스튜던트 t분포를 따른다.</strong></li></ul><h2 id="단일-계수-t-검정">단일 계수 t-검정</h2><ul><li>정규화된 모수 오차를 검정통계량으로 사용하면 <span class="math inline">\(w_i\)</span>가 0인지 아닌지에 대한 검정을 실시할수 있다.</li><li>StatsModels summary 메서드가 출력하는 회귀분석 보고서에서 <code>std err</code>로 표시된 열이 모형계수의 표준오차, <code>t</code>로 표시된 열이 단일 계수 t-검정의 검정 통계량, 그리고 <code>P&gt;|t|</code>로 표시된 열이 유의확률을 뜻한다.</li><li><strong>두 독립변수의 계수값을 비교할때도 사용</strong></li><li><strong>범주형 독립변수의 범주값이 가지는 유의성을 판단하는데 유용하다.</strong></li></ul><h2 id="회귀분석-f-검정">회귀분석 F-검정</h2><ul><li>개별 개수가 아닌 전체 회귀 계수가 모두 의미가 있는지 확인하는 경우 사용.</li><li>전체 독립 변수 중 어느 것도 의미를 가진 것이 없다는 귀무가설을 세운다.</li><li>유의확률이 작으면 작을수록 더 강력하게 기각된 것이므로 더 의미가 있는 모형이라고 할 수 있다.</li><li>따라서 여러 모형의 유의 확률을 비교하여 어느 모형이 더 성능이 좋은가를 비교할 때 이 유의 확률을 사용한다</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>부분회귀</title>
      <link href="/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/"/>
      <url>/2020/02/26/TIL-machine-learning-2020-02-26-machine-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="부분회귀">부분회귀</h1><ul><li>회귀분석을 한 후 새로운 독립변수를 추가하여 다시 회귀분석 한다면? <a id="more"></a><ul><li>처음에 나온 w1의 값과 두번째 나온 w'1의 값은 다르다.</li><li>종속변수에 영향을 미치는 모든 독립변수들이 회귀모형에 포함되지 않는한, 모형의 가중치는 항상 편향된(biased)값 이다.</li></ul></li></ul><blockquote><p><strong>새로운 독립변수 그룹을 추가해서 다시 회귀분석을 하면, 기존 가중치 벡터의 값이 달라진다.</strong></p></blockquote><h3 id="두가지-회귀분석-결과가-같을수-있는-경우">두가지 회귀분석 결과가 같을수 있는 경우</h3><ul><li><span class="math inline">\(w&#39;2 = 0\)</span>, 즉 <span class="math inline">\(X_2\)</span>와 <span class="math inline">\(y\)</span>의 상관관계가 없는 경우</li><li><span class="math inline">\(X_1^TX_2 = 0\)</span>, 즉 독립변수 <span class="math inline">\(X_1\)</span>과 독립변수 <span class="math inline">\(X_2\)</span>가 직교하는 경우. 서로 상관관계가 없으면 직교할 가능성이 높다.</li></ul><h2 id="프리슈-워-로벨-정리">프리슈-워-로벨 정리</h2><ul><li>1 : 특정한 독립변수 그룸 <span class="math inline">\(X_1\)</span>로 종속변수 <span class="math inline">\(y\)</span>를 선형회귀분석하여 잔차 <span class="math inline">\(y^*\)</span>를 구한다.</li><li>2 : <span class="math inline">\(X_1\)</span>로 다른 독립변수 <span class="math inline">\(x_2\)</span>를 선형 회귀분석하여 나온 잔차 <span class="math inline">\(x^*_2\)</span>를 구한다.</li><li>3 : <span class="math inline">\(y^*\)</span>를 종속변수로 하고 <span class="math inline">\(x^*_2\)</span> 를 독립변수로 하여 선형회귀분석하여 구한 가중치는 <span class="math inline">\(X_1\)</span>과 <span class="math inline">\(x_2\)</span>를 모두 사용하여 <span class="math inline">\(y\)</span>를 선형 회귀분석하였을때 <span class="math inline">\(x_2\)</span>에 대한 가중치와 같다.</li></ul><h2 id="부분회귀-플롯partial-regression-plot-added-variable-plot">부분회귀 플롯(Partial Regression Plot, Added Variable Plot)</h2><ul><li>특정한 하나의 독립변수의 영향력을 시각화하는 방법</li></ul><blockquote><p><strong>순서</strong></p></blockquote><ol type="1"><li>특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 제외한 나머지 독립변수 <span class="math inline">\(𝑋_1\)</span> 들로 종속변수 <span class="math inline">\(𝑦\)</span> 를 선형 회귀분석하여 잔차 <span class="math inline">\(𝑦^∗\)</span> 를 구한다.</li><li>특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 제외한 나머지 독립변수 <span class="math inline">\(𝑋_1\)</span> 들로 특정한 독립변수 <span class="math inline">\(𝑥_2\)</span> 를 선형 회귀분석하여 잔차 <span class="math inline">\(x_2^*\)</span> 를 구한다.</li><li>잔차 <span class="math inline">\(𝑥_2^*\)</span> 를 독립변수로, 잔차 <span class="math inline">\(𝑦^∗\)</span> 를 종속변수로 하여 선형 회귀분석한다. 이렇게 구한 <span class="math inline">\(𝑥_2^*\)</span> , <span class="math inline">\(𝑦^∗\)</span> 의 스캐터 플롯과 회귀분석 결과를 나타낸 것이 부분회귀 플롯이다.</li></ol><ul><li>부분회귀 플롯에서 가로축의 값은 독립변수 자체의 값이 아닌, 다른 독립변수의 영향을 제거한 일종의 &quot;순수한 독립변수 성분&quot;</li></ul><h2 id="ccpr-플롯">CCPR 플롯</h2><ul><li>부분회귀플롯과 마찬가지, &quot;가로축의 값은 독립변수 그대로의 값&quot;</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>범주형 독립변수</title>
      <link href="/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/"/>
      <url>/2020/02/25/TIL-machine-learning-2020-02-25-machinelearning2/</url>
      
        <content type="html"><![CDATA[<h3 id="풀랭크-방식">풀랭크 방식</h3><ul><li>더미변수의 값을 원핫인코딩 방식으로 지정. <a id="more"></a> <span class="math display">\[x_1 = A \to d_{1A} = 1, d_{1B} = 0 \]</span> <span class="math display">\[x_1 = B \to d_{1B} = 0, d_{1B} = 1 \]</span></li><li>위 수식을 대입하면 <span class="math display">\[x_1 = A \to \hat{y} = w_{1A} + w_2x_2 + \dots + w_Dx_D\]</span> <span class="math display">\[x_1 = B \to \hat{y} = w_{1B} + w_2x_2 + \dots + w_Dx_D\]</span></li><li><strong>더미변수의 가중치는 상수항이 된다.</strong></li></ul><h3 id="풀랭크-방식과-축소랭크-방식">풀랭크 방식과 축소랭크 방식</h3><ul><li>풀랭크 : 더미변수의 값을 원핫인코딩 방식으로 지정.</li><li>축소랭크 : 특정한 하나의 범주값을 기준값으로 하고 기준값에 대응하는 더미변수의 가중치는 항상 1로 놓는다.</li></ul><blockquote><p>월별기온예측 - 풀랭크 방식: 각 월의 대표값 - 축소랭크 방식: 기준값(1월의 평균기온)에서 &quot;차이&quot;가 얼마나 나는가</p></blockquote><h2 id="두개-이상의-범주형-변수가-있는-경우">두개 이상의 범주형 변수가 있는 경우</h2><ul><li>두개 이상의 범주형 변수가 있는 경우 축소형 방식을 사용</li><li>모든 범주형 변수의 가중치는 기준값 상수항에 더해지는 상수항으로 취급.</li></ul><h2 id="범주형-독립변수와-실수-독립변수의-상호작용">범주형 독립변수와 실수 독립변수의 상호작용</h2><p>Case1) - 범주형 독립변수 <span class="math inline">\(x_1\)</span>과 실수 독립변수 <span class="math inline">\(x_2\)</span>를 가지는 회귀모형에서 연속값 독립변수 <span class="math inline">\(x_2\)</span>가 미치는 영향, 즉 가중치가 범주형 독립변수 <span class="math inline">\(x_1\)</span>에 따라 달라진다면</p><ul><li>범주형 독립변수를 더미변수 <span class="math inline">\(d_1\)</span>으로 인코딩하고 연속값 독립변수 <span class="math inline">\(x_2\)</span>는 <span class="math inline">\(d_1\)</span>과의 상호작용항 <code>d_1:x_2</code>를 추가한다.</li><li><span class="math inline">\(x_1\)</span>범주값에 따라 <span class="math inline">\(x_2\)</span>의 기울기가 달라지는 모형이 된다.</li></ul><p>Case2) - 범주형 독립변수도 종속변수에 영향을 미치고, 범주형 독립변수와 실수 독립변수의 &quot;상호작용&quot;도 종속변수에 영향을 미치면</p><ul><li><span class="math inline">\(x_1\)</span>의 범주값에 따라 상수항과 <span class="math inline">\(x_2\)</span>의 기울기가 모두 달라지는 모형이 된다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>스케일링</title>
      <link href="/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/"/>
      <url>/2020/02/25/TIL-machine-learning-2020-02-25-machine-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="조건수">조건수</h2><ul><li>가장큰 고유값와 가장 작은 고유값의 비율</li><li><p>조건수가 크면 민감도가 커진다. 즉, 오차가 생기면 해에 미치는 영향이 커진다. <a id="more"></a></p></li><li><p>연립방정식을 이루는 행렬의 조건수가 커지면 상수항 오차가 작은 경우라도 연립방정식 해의 오차는 커진다. &gt; <strong>결론 : 공분산 행렬의 조건수가 크면 회귀분석을 사용한 예측값도 오차가 커진다.</strong></p></li></ul><h4 id="조건수가-커지는-경우">조건수가 커지는 경우</h4><ul><li>스케일이 크게 다른 경우 -&gt; 스케일링으로 해결</li><li><p>다중공선성, 상관관계가 큰 독립변수들이 있는 경우 -&gt; 변수선택(변수를 버리거나), PCA를 이용한 차원 축소로 해결</p></li><li>스케일링이 안된경우 독립변수의 분포 모양이 옆이나 위로 퍼져있다. 이를 원에 가깝게 모을수록 조건수가 작아진다.</li><li><p>다중공선성이 있을경우 그래프가 상관관계를 보인다.</p></li><li><code>scale()</code>명령 formula안에서 사용하여 스케일링을 할수 있다.</li><li><p>위 방식으로 스케일하면 스케일링에 사용된 평균과 표준편차를 저장하였다가 나중에 <code>predict()</code>명령을 사용할때 같은 스케일을 사용하기 때문에 편하다.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>데이터 전처리 기초 2</title>
      <link href="/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning/"/>
      <url>/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="sklearn.preprocessing-패키지">sklearn.preprocessing 패키지</h2><p>스케일링 및 변수변환을 위한 <code>StandardScaler</code> 클래스에서 <a id="more"></a></p><ul><li><code>fit()</code>: 학습용 데이터를 입력으로 실행하면 평균값과 표준편차를 계산하여 객체내에 저장</li><li><code>transform()</code>: 저장했던 평균값을 빼서 새로운 평균값이 0이 되도록 만들고, 저장한 표준편차로 나누어 새로운 표준편차가 1이 되도록 데이터를 변환하여 출력</li><li><code>fit_transform()</code>: 1,2단계를 합친것</li></ul><p>데이터에 아웃라이어가 있을 경우 <code>RobustScaler</code> 클래스를 사용 - 중앙값이 0, IQR(interquartile range)이 1이 되도록 변환하여, 아웃라이어가 섞여 있어도 데이터는 0주위에 남게 된다.</p><p><code>FunctionTransformer</code>클래스와 <code>PolynomialFeatures</code>클래스 - <code>PolynomialFeatures</code>클래스는 입력데이터를 여러개의 다항식으로 변환 - degree: 차수 - include_bias: 상수항 생성 여부 - <code>FunctionTransformer</code>클래스는 사용자가 지정한 함수를 사용하여 입력값을 변환 - 각도 0도와 360도를 구분하기위한 sin,cos함수 사용 예제</p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>선형회귀분석의 기초</title>
      <link href="/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/"/>
      <url>/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning3/</url>
      
        <content type="html"><![CDATA[<h1 id="회귀분석">회귀분석</h1><p>독립변수에 대응하는 종속변수와 가장 비슷한값 y^을 출력하는 함수를 찾는 과정 만약 함수 f(x)가 선형함수면, 이 함수를 선형회귀모형(linear regression model)이라 한다. <a id="more"></a></p><ul><li>만약 <span class="math inline">\(f(x)\)</span>가 선형함수면 이 함수를 선형회귀모형이라고 한다. 선형회귀모형을 사용하는 회귀분석은 선형회귀분석이라고 한다. <span class="math display">\[\hat{y} = w_0 + w_1x_1 + w_2x_2 + ... + w_Dx_D = w_0+w^Tx\]</span></li></ul><h2 id="상수항-결합">상수항 결합</h2><p>회귀분석모형 수식을 간단하게 만들기 위해 상수항을 독립변수 데이터 제일 처음에 추가하는것을 상수항 결합 작업이라 한다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">X0 = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">X = sm.add_constant(X0)</span><br></pre></td></tr></table></figure></p><h2 id="최소자승법">최소자승법</h2><p>최소자승법(OLS)은 잔차제곱합(RSS)을 최소화 하는 가중치 벡터를 구하는 방법. 잔차의 크기(RSS)를 가장 작게 하는 가중치 벡터를 구하기 위해서, 잔차제곱합 식을 미분하여 그레디언트 벡터를 구하고, 이 그레디언트벡터가 영벡터 일때 RSS는 최소가 된다.</p><h2 id="직교방정식">직교방정식</h2><p>여기서 그레디언트 벡터가 0벡터가 되는 관계를 나타내는 식을 직교방정식(normal equation)이라 한다. 1. 모형에 상수항이 있는 경우 잔차벡터의 원소의 합은 0이다. 즉 잔차의 평균은 0이다 2. x데이터의 평균값에 대한 예측값은 y데이터의 평균값이다.</p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>범주형 데이터 처리</title>
      <link href="/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/"/>
      <url>/2020/02/24/TIL-machine-learning-2020-02-24-machine-learning2/</url>
      
        <content type="html"><![CDATA[<h1 id="범주형-데이터">범주형 데이터</h1><p>혈액형, 성별과 같이 종류를 표시하는 데이터 <a id="more"></a></p><h2 id="범주형-데이터의-변형">범주형 데이터의 변형</h2><ul><li>더미변수화</li><li>카테고리 임베딩</li></ul><h2 id="더미변수화">더미변수화</h2><p>0 또는 1만 가지는 값으로 어떤 특징의 존재 여부를 표시. 이진지시자(Boolean indicator),이진변수(binary variable),지시변수(indicator variable),설계변수(design variable),처치(treatment)등으로 불린다.</p><h2 id="patsy를-활용한-더미변수화">patsy를 활용한 더미변수화</h2><ul><li>풀랭크 방식 patsy패키지의 <code>dmatrix()</code>함수는 범주값을 더미변수로 바꿔준다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> patsy <span class="keyword">import</span> dmatrix</span><br><span class="line">df = pd.DataFrame([<span class="string">"A"</span>, <span class="string">"B"</span>], columns=[<span class="string">"x"</span>])</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line">dmatrix(<span class="string">"x + 0"</span>, df1)</span><br></pre></td></tr></table></figure></li><li>축소랭크 방식 특정한 하나의 범주값을 기준값으로 하고 기준값에 대응하는 더미변수의 가중치는 항상 1로 한다. 더미변수화 할떄 <code>dmatrix()</code>함수의 문자열에 +0을 생략함</li></ul><h2 id="두개의-범주형-변수">두개의 범주형 변수</h2><ul><li>통합 축소형 방식</li><li>상호작용 방식</li></ul><h2 id="카테고리-임베딩">카테고리 임베딩</h2><p>범주값 대신 범주값의 특성을 나타내는 연속값 혹은 연속값 벡터를 사용 예를들어 운동선수의 이름을 나타내는 범주값의 경우, 운동선수의 나이, 연봉, 신체능력치 등을 사용하고, 지역명을 나타내느 범주값은 지역의 면적, 인구수 등을 사용한다.</p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-selector</title>
      <link href="/2020/02/22/TIL-crawling-2020-02-22-crawling-css/"/>
      <url>/2020/02/22/TIL-crawling-2020-02-22-crawling-css/</url>
      
        <content type="html"><![CDATA[<h1 id="css-selector">CSS Selector</h1><p>HTML 엘리먼트에 CSS 스타일을 적용시킬때 엘리먼트를 선택하는 방법입니다. <a id="more"></a></p><h4 id="태그-이름으로-선택">1. 태그 이름으로 선택</h4><p>&quot;data 1 엘리먼트를 선택&quot; - css-selector : <code>div</code></p><h4 id="아이디-값으로-선택">2. 아이디 값으로 선택</h4><p>&quot;data 2를 아이디 값으로 선택&quot; - css-selector : <code>#text</code></p><h4 id="클래스-값으로-선택">3.클래스 값으로 선택</h4><p>&quot;data 3를 클래스 값으로 선택&quot; - css-selector : <code>.no1</code> - <code>.dss-txt</code> : data2, data 3가 선택</p><h4 id="속성값으로-선택">4. 속성값으로 선택</h4><p>&quot;data 4를 속성값으로 선택&quot; - css-selector : <code>[val=&quot;d4&quot;]</code>, <code>[id=&quot;da4&quot;]</code></p><h4 id="혼합해서-사용">5. 혼합해서 사용</h4><p>&quot;span 태그, class 값이 no5인 엘리먼트 선택&quot; - css-selector : <code>span.no5</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"dss-txt no1"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dss-txt no2"</span> <span class="attr">val</span>=<span class="string">"d3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"da4"</span> <span class="attr">val</span>=<span class="string">"d4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"no5"</span> &gt;</span>data 5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="not-selector">6. not selector</h4><p>선택된 엘리먼트에서 특정 조건의 엘리먼트를 제거해서 선택 data 2 엘리먼트만 제외한 ds 클래스를 선택 - css-selector : <code>.ds:not(.dss2)</code></p><h4 id="nth-child">7.nth-child</h4><p>n번째의 엘리먼트를 선택</p><p>data 3 선택하는 방법 - css-selector : <code>.ds:nth-child(3)</code> 뒤의 조건(.ds라는 클래스를 가진 상위 클래스의 자식중에 3번째)이 먼저, 다음 ds라는 클래스를 가진거를 선택</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>data 0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss1"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss2"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> # 얘도 3번째 ds</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss1"</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss2"</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss3"</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span> # 얘도 3번째 ds</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"ds dss4"</span>&gt;</span>data 4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds"</span>&gt;</span> data5<span class="tag">&lt;/<span class="name">div</span>&gt;</span> # 얘도 3번째 ds</span><br></pre></td></tr></table></figure><h4 id="계층구조로-엘리먼트-선택">8. 계층구조로 엘리먼트 선택</h4><p>바로 아래 단계의 엘리먼트 선택 - <code>.wrap-1 &gt; h5</code> : inner 1선택 모든 하위 엘리먼트를 선택 - <code>.wrap-1 h5</code> : inner 1,inner 2선택 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>inner 1 <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap-2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>inner 2 <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/"/>
      <url>/2020/02/22/TIL-crawling-2020-02-22-html-css-selector/</url>
      
        <content type="html"><![CDATA[<h1 id="html">HTML</h1><ul><li>Hyper Text Markup Language</li><li>웹 문서를 작성하는 마크업 언어입니다.</li></ul><a id="more"></a><ul><li>웹페이지를 구성하는 언어에는 3종류가 있습니다.<ul><li>HTML : 화면의 레이아웃이나 텍스트</li><li>CSS : 화면의 색상 크기 등의 스타일</li><li>Javascript : 화면의 클릭, 드래그 등등의 이벤트</li></ul></li></ul><h2 id="html의-구성요소">1.1 HTML의 구성요소</h2><p><strong><code>Document</code></strong> - 페이지 전체 <strong><code>element</code></strong> - 계층적 구조로 이루어져 있으며 모여서 Document가 됩니다. - 시작 태그와 끝 태그로 구성되어 있습니다. <code>&lt;div&gt; &lt;/div&gt;</code> <strong><code>Tag</code></strong> - 시작태그와 끝 태그로 엘리먼트를 구성합니다. - 시작 태그에는 여러가지 속성값들이 들어 있습니다. - 태그와 태그 사이에는 문자열 데이터를 가질수 있습니다. - 태그의 이름에 따라서 태그의 목적이 달라집니다. <strong><code>Attribute</code></strong> - 시작 태그 안에 포함되는 속성값입니다. - <code>id</code>, <code>class</code> : 엘리먼트를 선택하기 위한 목적으로 만들어진 속성값입니다. - 이 외에도 다양한 속성값이 존재 합니다.</p><h3 id="속성값">1.2 속성값</h3><p><strong><code>id</code></strong> : 웹페이지에서 유일한 값입니다. <strong><code>class</code></strong> : - 웹 페이지 내에서 여러개의 class가 존재합니다. - 하나의 엘리먼트에 여러개의 class를 부여할수 있습니다. <strong><code>type</code></strong> : 엘리먼트 형태를 결정합니다. (button, checkbox 등) <strong><code>style</code></strong> : CSS 스타일 값을 적용할수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-1"</span> <span class="attr">class</span>=<span class="string">"bt no1"</span><span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">style</span>=<span class="string">"color:red;"</span> &gt;</span>HTML 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-2"</span> <span class="attr">class</span>=<span class="string">"bt no2"</span><span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>HTML 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="태그의-종류">1.3 태그의 종류</h3><p><strong><code>Head</code></strong> : 제목을 나타낼때 사용합니다. h1부터 숫자가 커질수록 작아집니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>p</code></strong> : 한줄의 문자열을 출력하기 위한 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>파이썬은 재미있습니다.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>내일은 휴강입니다.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>div</code></strong> : 레이아웃을 나타내는 태그이고, 가장 많이 사용됩니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>html 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>table</code></strong> : row와 column이 있는 테이블 모양을 나타낼때 사용되는 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>테이블 제목<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>코드<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>회사명<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>0001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>애플<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">td</span>&gt;</span>0002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>네이버<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>ul</code></strong>,<strong><code>li</code></strong> : 리스트를 나타내는 태그입니다. 하나의 ul에 다수의 li태그를 가집니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>data 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>a</code></strong> : 링크를 출력하는 태그입니다. <code>href</code> 속성값에 이동할 URL을 입력합니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"howardhowonyu.github.io"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Howard's nest<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>img</code></strong> : 이미지를 불러오는 태그 입니다. <code>src</code> 속성값에 이미지의 URL을 입력합니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span> =<span class="string">"width:200px;"</span><span class="attr">src</span>=<span class="string">"이곳에 이미지의 URL을 입력합니다."</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>iframe</code></strong> : 외부 URL 링크의 페이지를 보여주기 위한 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://howardhowonyu.github.io/"</span> <span class="attr">width</span>=<span class="string">"100%;"</span> <span class="attr">height</span>=<span class="string">"400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure> <strong><code>input</code></strong> : 여러 형태의 값을 입력받는 요소들을 만드는 태그입니다. - text : 문자를 입력받습니다. - password : 비밀번호(****)형태로 입력 받습니다. - radio : n지 선다의 답을 받습니다. - checkbox : 체크박스를 만듭니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"비밀번호"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"data"</span>&gt;</span>radio 1<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"data"</span>&gt;</span>radio 2<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>checkbox 1<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>select,option</code></strong>: 옵션을 선택할수 있는 드랍다운 형태를 만드는 태그입니다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>data 1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>data 2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>예외처리</title>
      <link href="/2020/02/21/python-2020-02-21-try-except-finally-raise/"/>
      <url>/2020/02/21/python-2020-02-21-try-except-finally-raise/</url>
      
        <content type="html"><![CDATA[<h1 id="try-except">TRY, EXCEPT</h1><p>에러가 발생해도 코드의 실행을 계속 하고 싶을 때 사용합니다. <a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># try구문을 실행</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    print(ls[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 오류가 발생해도 코드의 실행을 마치고 e라는 변수에 오류 메세지를 담습니다.</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line">    print(e)</span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># error</span></span><br><span class="line"><span class="comment"># name 'ls' is not defined</span></span><br><span class="line"><span class="comment"># Done!</span></span><br></pre></td></tr></table></figure><h1 id="finally">FINALLY</h1><p>try, except 구문 실행된후 finally 구문이 실행됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"Done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># error</span></span><br><span class="line"><span class="comment"># Done!</span></span><br></pre></td></tr></table></figure><blockquote><p>코딩 실행 중간에 에러가 발생하면 변수안에 계속 데이터를 가지고 있고, 이는 낭비입니다.<br>때문에 try던 except건 간에 어쨋든 &quot;실행 되면 finally 변수안에 데이터 지워줘&quot; 라고 할때 사용합니다.</p></blockquote><h1 id="raise">RAISE</h1><p>강제로 에러를 발생시키는 명령입니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"error"</span>)</span><br><span class="line">    <span class="keyword">raise</span>(e)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"Done!"</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>except때문에 코드 실행이 완료 되어야 하지만 raise()떄문에 강제로 에러가 발생됩니다.</p></blockquote><h1 id="에러-메세지-생성">에러 메세지 생성</h1><p><strong>&quot;Number grater than 10&quot;</strong><br>10이상의 숫자가 입력되어야 한다는 에러 메세지를 만들어보면, <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Exception 이라는 클래스를 상속 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lownumber</span><span class="params">(Exception)</span>:</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> <span class="comment">#에러 메세지 오버라이팅</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Number grater than 10"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_number</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">raise</span> Lownumber() <span class="comment">#Lownumber 클래스를 사용</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">input_number(<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">input_number(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 에러메세지 출력</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#Lownumber                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="comment">#&lt;ipython-input-19-8684a0e33c0b&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#----&gt; 1 input_number(8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;ipython-input-17-bf4895dc7d57&gt; in input_number(num)</span></span><br><span class="line"><span class="comment">#      1 def input_number(num):</span></span><br><span class="line"><span class="comment">#      2     if num &lt;= 10:</span></span><br><span class="line"><span class="comment">#----&gt; 3         raise Lownumber() #Lownumber 클래스를 사용</span></span><br><span class="line"><span class="comment">#      4     print("10")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Lownumber: Number grater than 10</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 예외처리 </tag>
            
            <tag> try </tag>
            
            <tag> except </tag>
            
            <tag> finally </tag>
            
            <tag> raise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>모듈과 패키지</title>
      <link href="/2020/02/21/python-2020-02-21-python-module-package/"/>
      <url>/2020/02/21/python-2020-02-21-python-module-package/</url>
      
        <content type="html"><![CDATA[<h1 id="module-package">Module &amp; Package</h1><p>모듈 : 변수, 함수, 클래스를 모아놓은 (.py)라는 이름의 확장자를 가진 파일입니다. 패키지 : 모듈의 기능을 디렉토리별로 정리해 놓은 개념입니다. <a id="more"></a></p><h2 id="module모듈">Module(모듈)</h2><p>모듈 생성 &gt; 매직 매서드를 사용한 모듈 생성 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dss.py라는 이름의 모듈 생성</span></span><br><span class="line">%%writefile dss.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈안에 함수 및 클래스를 생성</span></span><br><span class="line">num = <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp1</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"disp1"</span>,msg)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp2</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"disp2"</span>,msg)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(self,*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(args)</span><br></pre></td></tr></table></figure> 모듈 호출 &gt; <code>import &quot;모듈 이름&quot;</code>으로 호출</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dss </span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈 속 변수</span></span><br><span class="line">dss.num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모듈 속 함수</span></span><br><span class="line">dss.disp1(<span class="string">"python"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클래스로 객체 생성</span></span><br><span class="line">calc = dss.Calc()</span><br></pre></td></tr></table></figure><h2 id="package패키지">Package(패키지)</h2><p>패키지의 생성 - 패키지 생성시 디렉토리에 <strong>init</strong>.py 파일을 추가해야 합니다. - 단, python 3.3버전 이상에서는 필요 없습니다. - 패키지의 위치 : 특정 디렉토리(pip,conda등으로 설치하는 등)에 있는 패키지는 어디에서나 import 가능합니다.</p><p>주피터 노트북에서 패키지 설치 - <code>school $ python setup.py</code> - 커널 리스타트 해야 패키지가 적용됩니다. &gt; develop : 개발자모드, 코드를 수정하면 설치된 패키지도 같이 수정됩니다. &gt; build : 일반모드, 코드로 수정하면 다시 설치해야 수정된 코드가 적용됩니다.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 객체 지향 </tag>
            
            <tag> module </tag>
            
            <tag> package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 파싱을 이용한 크롤링</title>
      <link href="/2020/02/21/TIL-crawling-2020-02-21-crawling/"/>
      <url>/2020/02/21/TIL-crawling-2020-02-21-crawling/</url>
      
        <content type="html"><![CDATA[<h2 id="html-데이터-파싱을-이용한-크롤링">HTML 데이터 파싱을 이용한 크롤링</h2><ol type="1"><li>웹페이지 분석 : URL 찾기</li><li>요청 -&gt; 응답 : HTML(str) 가져오기</li><li>HTML(str) -&gt; BeautifulSoup 객체에서 css-selector를 통해 내용을 가져옴 -&gt; 데이터프레임으로 변환 <a id="more"></a></li></ol><h2 id="크롤링-과정">크롤링 과정</h2><ul><li>BeautifulSoup라는 클래스의 매서드 활용 response안에 있는 애들을 BeautifulSoup으로 HTML로 파싱</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requests.get 매서드로 요철</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># response.content로 내용 선택, html.parser로 HTML로 파싱</span></span><br><span class="line">dom = BeautifulSoup(response.content, <span class="string">"html.parser"</span>)</span><br></pre></td></tr></table></figure><h4 id="bs4.beautifulsoupr"><code>bs4.BeautifulSoupr</code></h4><blockquote><p>select 매서드 : 여러개의 element 객체를 리스트로 가져옴 select_one 매서드 : 하나의 element 객체를 가져옴</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 크롬 개발자 도구에서 copy selector했을때 id가 나올때 까지 찾아 복사함</span></span><br><span class="line"><span class="comment"># 리스트안의 딕셔너리 형태로 만들어줌&#123;"컬럼명":내용&#125;</span></span><br><span class="line">datas = []</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    datas.append(&#123;</span><br><span class="line">        <span class="string">"title"</span>: element.select_one(<span class="string">'.tit_g'</span>).text.strip().replace(<span class="string">"\n"</span>,<span class="string">""</span>), <span class="comment">#tit_g이름의 클래스 안에 텍스트를 잡음</span></span><br><span class="line">        <span class="string">"link"</span> : element.select_one(<span class="string">'a'</span>).get(<span class="string">"href"</span>), <span class="comment">#href속성의 값을 가져옴</span></span><br><span class="line">    &#125;)</span><br><span class="line">article_df = pd.DataFrame(datas)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Crawling </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>데이터 전처리 기초 1</title>
      <link href="/2020/02/20/TIL-regression-analysis-2020-02-20-regression-analysis/"/>
      <url>/2020/02/20/TIL-regression-analysis-2020-02-20-regression-analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="데이터-전처리에-사용하는-패키지">데이터 전처리에 사용하는 패키지</h1><h2 id="missingno">missingno</h2><ul><li>결측데이터를 검색하여 시각화 함</li><li><code>.bar()</code>, <code>.matrix()</code>함수로 확인</li></ul><h2 id="scikit-learn-패키지의-simpleimputer-클래스">scikit-learn 패키지의 SimpleImputer 클래스</h2><ul><li><code>SimpleImputer</code>클래스로 객체를 생성할때, 결측값을 채우고자 할때, <code>strategy</code> 인수를 &quot;mean&quot;으로 하면 중앙값 &quot;median&quot;으로 하면 중앙값, <code>most_frequent</code>로 하면 최빈값을 대체값으로 사용한다.</li></ul><h2 id="patsy">patsy</h2><ul><li>데이터를 선택, 변환, 추가, 스케일링 함</li><li><code>dmatrx()</code> 함수를 사용하면 데이터 프레임에 상수항을 추가하거나 원하는 데이터만 선택하거나 변형할 수 있다.</li><li>스케일링을 위한 함수<ul><li><code>center()</code>: 평균을 0으로 스케일링</li><li><code>standardize()</code>: 평균을 0으로하고 표준편차를 1로 스케일링</li><li><code>scale()</code>: <code>standardize()</code> 과 같음</li></ul></li><li><code>design_info</code>라는 속성에 평균등 정보가 입력되어 있다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 머신러닝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth, fake_useragent 활용</title>
      <link href="/2020/02/20/TIL-crawling-2020-02-20-Oauth/"/>
      <url>/2020/02/20/TIL-crawling-2020-02-20-Oauth/</url>
      
        <content type="html"><![CDATA[<h2 id="oauth">Oauth</h2><ul><li>서비스(서드파티)에서 페이스북, 구글등의 서비스에 접근할수 있는 권한을 요청하고 이를 사용할수 있는 키를 발급 해줍니다 <a id="more"></a></li></ul><blockquote><p>1단계: 서비스에서 페이스북, 구글등에 등록을 요청하면, request_token을 발급</p></blockquote><blockquote><p>2단계: 유저가 서비스에서 서드파티의 데이터를 가져오고자 하면, 서드파티에 oauth page를 띄움, 수락하면 이 유저에 대한 access_token을 발급</p></blockquote><blockquote><p>3단계: 서비스는 request_token과 access_token으로 서드파티에 데이터를 요청하고 받아옴</p></blockquote><h2 id="oauth를-활용한-구글-스프레드시트-데이터-업로드-작업-순서">Oauth를 활용한 구글 스프레드시트 데이터 업로드 작업 순서</h2><ol type="1"><li>oauth 인증 파일 생성</li><li>프로젝트 생성<ul><li>라이브러리 탭선택: Google Drive API, Google sheet API 사용설정</li><li>Oauth 동의화면<ul><li>어플리케이션 이름 설정</li><li>google api 범위 추가: drive, spreadsheets</li><li>저장</li></ul></li><li>사용자 인증정보<ul><li>Oauth클라이언트 ID 만들기</li></ul></li></ul></li><li>스프레드 시트에 크롤링한 데이터 저장 및 로드</li></ol><h2 id="fake_useragent">fake_useragent</h2><ul><li>user_agent를 랜덤으로 생성하는 패키지</li><li>headers에 임의로 값을 지정해주고 requests해주는 방법으로 데이터 접근 가능</li><li>user-agent외에도 refere(접근 이전에 방문했던 페이지의 URL)등도 지정 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://finance.daum.net/api/exchanges/summaries"</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">"user-agent"</span> : UserAgent().chrome,</span><br><span class="line">    <span class="string">"referer"</span> : <span class="string">"https://finance.daum.net/exchanges"</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url,headers=headers)</span><br><span class="line">response</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Crawling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth </tag>
            
            <tag> crawling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>데이터 크롤링, 시각화, 정규화</title>
      <link href="/2020/02/20/TIL-crawling-2020-02-20-crawling/"/>
      <url>/2020/02/20/TIL-crawling-2020-02-20-crawling/</url>
      
        <content type="html"><![CDATA[<h2 id="web-crawling">web crawling</h2><ol type="1"><li>requests : json : 동적페이지(URL 변경 없이 데이터를 수정 및 추가)</li><li>requests : html : 정적페이지(URL 변경 으로 데이터를 수정 및 추가)</li><li>selenium : web browser : 1,2 번 방법을 사용하지 못할때 사용, 브라우저를 직접 조작 <a id="more"></a></li></ol><h2 id="json">json</h2><ul><li>문자열 데이터를 dict로 바꿔서 저장</li></ul><h2 id="크롤링-절차">크롤링 절차</h2><ol type="1"><li>웹서비스 분석 : URL 분석하기,</li><li>request, response 하기 : json을 얻음</li><li>문자열 json 데이터를 dict로 파싱후 데이터 프레임으로 생성</li></ol><h2 id="requests.geturlheadersparams">requests.get(url,headers=params)</h2><ul><li>params라는 변수에 딕셔너리 형해로, user agent, cookie등을 임의로 설정을 해주는 방식으로 해결</li></ul><h2 id="정규화-normalization">정규화 : Normalization</h2><ul><li><code>z = (x - min(x)) / (max(x) - min(x))</code></li><li>같은 기준을 놓고 비교하기 위한 절차</li></ul><h2 id="api로-날씨-정보-가져오기">API로 날씨 정보 가져오기</h2><ul><li>darksky.net 서비스를 이용</li><li>restAPI : 키값을 감춰서 깔끔한 URL을 만들수 있다.</li></ul><h2 id="직방-데이터-크롤링">직방 데이터 크롤링</h2><ul><li>동이름을 입력하여 아파트 메물을 데이터 프레임으로 만드는 작업</li><li><code>%%writefile</code> -&gt; 모듈화 하여 저장</li></ul><h2 id="robots.txt">robots.txt</h2><ul><li>각 도메인 별로 접근 권한 등의 규칙을 저장해 놓은 파일 &gt; 예) User-agent : * &gt; Allow : /</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Crawling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crawling </tag>
            
            <tag> json </tag>
            
            <tag> 정규화 </tag>
            
            <tag> 시각화 </tag>
            
            <tag> robots.txt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>데이터 분석이란?</title>
      <link href="/2020/02/18/TIL-regression-analysis-2020-02-18-regression-analysis/"/>
      <url>/2020/02/18/TIL-regression-analysis-2020-02-18-regression-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="데이터-분석이란">데이터 분석이란?</h2><ul><li>데이터 간의 관계를 사용하여 우리가 원하는 새로운 출력데이터를 만들어 내는 과정</li></ul><h2 id="예측">예측</h2><ul><li>여러가지 입력 데이터를 주면, 데이터 분석의 결과로 다른 데이터를 출력</li></ul><h2 id="입력데이터input-data-출력데이터output-data">입력데이터(input data), 출력데이터(output data)</h2><ul><li>독립변수, 특징, 설명변수</li><li>종속변수, 라벨, 클라스(카테고리 값)</li></ul><h2 id="규칙기반과-학습기반">규칙기반과 학습기반</h2><ul><li>규칙기반 방법은 사람이 규칙을 미리 만들어 놓는 방법</li><li>학습기반 방법은 규칙을 기계가 만들도록 하는 방법</li></ul><h2 id="지도학습">지도학습</h2><ul><li>목표값이 있어야 학습가능하기 때문에, 입력데이터에 목표값을 붙여주는 작업이 필요하고 이를 레이블링이라 한다.</li><li>지도학습에서 가장 힘든 작업이 레이블링</li></ul><h2 id="인코딩">인코딩</h2><ul><li>현실의 데이터를 컴퓨터가 처리할수 있는 데이터로 바꾸는것</li><li>이미지는 벡터화 시키고, 문서는 BOW방식을 사용<ul><li>BOW(Bag of words): 특정 단어가 몇번 나왔는지를 세어 빈도를 벡터로 표시하는 방법, 단어장을 만들어 각 단어별 번호를 메긴후 문서별로 번호를 셈</li></ul></li></ul><h2 id="입력차원">입력차원</h2><ul><li>데이터를 입력받는 구멍, 한번 정하면 바꾸기 힘듦</li></ul><h2 id="카테고리값">카테고리값</h2><ul><li>범주형 값이라고 하며, 비교가 불가능한 데이터</li></ul><h2 id="회기분석과-분류문제">회기분석과 분류문제</h2><ul><li>회기분석은 답이 되는 숫자를 써야하는 단답형 문제를 푸는것</li><li>분류 문제는 4지 선다 문제 같이 답을 정하는 것</li></ul><h2 id="비지도-학습">비지도 학습</h2><ul><li>지도학습을 제외한 모든 머신러닝 방식</li><li>클러스터링 : 비슷한 데이터를 같은 그룹으로 모으는것</li><li>imputation(impating): 빠진 그림을 채우는 등의 작업</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 머신러닝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 머신러닝 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>검정과 유의확률</title>
      <link href="/2020/02/17/TIL-mathematics-2020-02-17-math/"/>
      <url>/2020/02/17/TIL-mathematics-2020-02-17-math/</url>
      
        <content type="html"><![CDATA[<h2 id="검정">검정</h2><ul><li>확률분포에 대한 어떤 주장: 가설</li><li>검정: 가설을 증명하는 행위</li></ul><h2 id="귀무가설과-대립가설">귀무가설과 대립가설</h2><ul><li>귀무가설(우리가 부정하고자 하는 가설 - 우리가 주장하려는 가설의 반대, 긍정문으로 표현.</li><li>귀무가설과 함께 고려하는 대립가설은, 진실임을 증명하고자 하는 가설.</li></ul><h2 id="검정통계량">검정통계량</h2><ul><li>표본데이터 집합을 입력으로 계산되는 함수의 값.</li><li>베르누이분포 확률변수의 검정통계량은 이항분포를 따른다.</li><li>분산 <span class="math inline">\(\sigma^2\)</span>값을 알고있는 정규분포 확률변수는, 표본평균 m을 분산으로 정규화한 값을 정규통계량으로 쓰고, 이 검정통계량은 표준정규분포를 따른다.</li><li>분산 <span class="math inline">\(\sigma^2\)</span>값을 모르는 정규분포 확률변수는, 자유도가 N-1인 스튜던트 t분포를 따른다.</li></ul><h2 id="유의확률p-value">유의확률(P-value)</h2><ul><li>확률분포와 확률분포의 표본값이 주어졌을때, 그 확률분포에서 해당 표본값 혹은 더 희귀한 값이 나올수 있는 확률</li><li>유의확률값이 작으면 귀무가설을 기각하고 대립가설을 채택할수 있다.</li></ul><h2 id="유의수준과-기각역">유의수준과 기각역</h2><ul><li>유의확률값이 작으면 귀무가설을 기각하고 대립가설을 채택할수 있다, 에서 &quot;작다&quot;는 판단을 하는 기준.</li><li>기각역 : 유의수준에 대해 계산된 검정통계량</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL과 파이썬, SQLAlchemy</title>
      <link href="/2020/02/15/Database-2020-02-15-mysql-with-python/"/>
      <url>/2020/02/15/Database-2020-02-15-mysql-with-python/</url>
      
        <content type="html"><![CDATA[<h2 id="sql-in-python">SQL in python</h2><p>SQL을 주피터 노트북을 이용해 파이썬으로 조작해 봅시다.</p><a id="more"></a><p><strong>데이터 베이스 연결</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line">db = MySQLdb.connect(</span><br><span class="line">    <span class="string">"&lt;퍼블릭 ip&gt;"</span>,     <span class="comment"># database server public ip</span></span><br><span class="line">    <span class="string">"root"</span>,          <span class="comment"># user</span></span><br><span class="line">    <span class="string">"test"</span>,          <span class="comment"># password</span></span><br><span class="line">    <span class="string">"world"</span>,         <span class="comment"># database name</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><strong>쿼리 작성</strong> : 쿼리를 작성해서 변수에 담은후 실행합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QUERY = <span class="string">"""</span></span><br><span class="line"><span class="string">    SHOW TABLES;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p><strong>쿼리 실행</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curs = db.cursor()</span><br><span class="line">curs.execute(QUERY)</span><br></pre></td></tr></table></figure></p><p><strong>데이터 베이스의 테이블들의 이름을 출력</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows = curs.fetchall()</span><br></pre></td></tr></table></figure></p><h2 id="판다스-데이터프레임으로-가져오기">판다스 데이터프레임으로 가져오기</h2><p>데이터 프레임의 데이터를 SQL 쿼리문으로 불러온후 판다스의 데이터 프레임으로 불러와 사용할수 있습니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">QUERY = <span class="string">"""</span></span><br><span class="line"><span class="string">    SELECT *</span></span><br><span class="line"><span class="string">    FROM city_population_languages</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">df = pd.read_sql(QUERY,db)</span><br></pre></td></tr></table></figure> 판다스의 <code>read_sql</code> 함수를 사용하면 멋지게 불러올수 있습니다.</p>]]></content>
      
      
      <categories>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2020/02/14/Database-2020-02-14-mongdb/"/>
      <url>/2020/02/14/Database-2020-02-14-mongdb/</url>
      
        <content type="html"><![CDATA[<h2 id="rdbms-vs-nosql">RDBMS vs NoSQL</h2><a id="more"></a><table><thead><tr class="header"><th><strong>RDBMS</strong></th><th><strong>NoSQL(Not Only SQL)</strong></th></tr></thead><tbody><tr class="odd"><td>Database</td><td>Database</td></tr><tr class="even"><td>Table</td><td>Collection</td></tr><tr class="odd"><td>Row / Record</td><td>Document</td></tr><tr class="even"><td>Column</td><td>Key / Filed</td></tr></tbody></table><h3 id="컬렉션-생성">컬렉션 생성</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use dss</span><br><span class="line">db.createCollection(<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.createCollection(<span class="string">"user2"</span>,</span><br><span class="line">    &#123;<span class="attr">autoIndexId</span>:<span class="literal">true</span>, <span class="attr">capped</span>:<span class="literal">true</span>, <span class="attr">size</span>:<span class="number">50</span>, <span class="attr">max</span>:<span class="number">5</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  지우기</span></span><br><span class="line">db.user.drop()</span><br></pre></td></tr></table></figure><p>크기가 500바이트, document 최대 5개 까지만 생성합니다. 5개가 되기전에 용량이 50바이트를 넘기면, 제일 과거의 데이터를 삭제하면서 들어갑니다.</p><h3 id="insert">Insert</h3><p>데이터를 넣어 보겠습니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.user1.insert(&#123;<span class="string">"subject"</span>:<span class="string">"python"</span>,<span class="string">"level"</span>:<span class="number">3</span>&#125;)</span><br><span class="line">db.user1.insert(&#123;<span class="string">"subject"</span>:<span class="string">"web"</span>,<span class="string">"level"</span>:<span class="number">2</span>&#125;)</span><br><span class="line">db.user1.insert(&#123;<span class="string">"subject"</span>:<span class="string">"sql"</span>,<span class="string">"level"</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>여러개를 Insert 해보겠습니다. SQL 처럼 collection 생성하고 넣을 필요 없이. 이름 정해서 데이터 바로 넣으면 그냥 생성됩니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert([</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"python"</span>,<span class="string">"level"</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"web"</span>,<span class="string">"level"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"sql"</span>,<span class="string">"level"</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"python"</span>,<span class="string">"level"</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"web"</span>,<span class="string">"level"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"sql"</span>,<span class="string">"level"</span>:<span class="number">1</span>&#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>위에서 설정한 것과 같은 제약조건이 있으면 remove 함수는 쓸수 없습니다. 지우려면 전체를 다 지워야 합니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.user1.remove(&#123;<span class="attr">level</span>:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error ; cannot remove from a capped collection: dss.user1</span></span><br></pre></td></tr></table></figure></p><h2 id="find-필터링">FIND (필터링)</h2><p><code>find(query, projection)</code> <strong>query</strong> : SQL의 where 절 <strong>projection</strong> : SQL의 select, 보여지는 filed</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;<span class="string">"subject"</span>:<span class="string">"python"</span>&#125;)</span><br></pre></td></tr></table></figure><p>lte : 작거나 같다 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;<span class="string">"level"</span>:  &#123;<span class="attr">$lte</span>:<span class="number">2</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>in : 선택 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;<span class="string">"subject"</span>: &#123;<span class="attr">$in</span>: [<span class="string">"java"</span>,<span class="string">"python"</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>논리연산자 : $or, $and, $not, $nor <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;<span class="attr">$and</span> : [&#123;<span class="string">"subject"</span>:<span class="string">"python"</span>&#125;,&#123;<span class="string">"level"</span>:&#123;<span class="attr">$gte</span>:<span class="number">3</span>&#125;&#125;]&#125;)</span><br><span class="line">db.info.find(&#123;<span class="attr">$nor</span> : [&#123;<span class="string">"subject"</span>:<span class="string">"python"</span>&#125;,&#123;<span class="string">"level"</span>:&#123;<span class="attr">$gte</span>:<span class="number">3</span>&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure></p><p>자바스크립트 문법을 그대로 사용 가능합니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;<span class="attr">$where</span>:<span class="string">"this.level == 1"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>projection : mysql에서 select 할때 column 지정하는 것과 같습니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;&#125;,&#123;<span class="string">"_id"</span>:<span class="literal">false</span>,<span class="string">"level"</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">db.info.find(&#123;&#125;,&#123;<span class="string">"subject"</span>:<span class="literal">true</span>,<span class="string">"level"</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">db.info.find(&#123;&#125;,&#123;<span class="string">"subject"</span>:<span class="literal">true</span>,<span class="string">"level"</span>:<span class="literal">true</span>,<span class="string">"_id"</span>:<span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>sort : 1(오름차순),-1(내림차순) <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.info.find().sort(&#123;<span class="string">"level"</span>:<span class="number">1</span>&#125;)</span><br><span class="line">db.info.find().sort(&#123;<span class="string">"level"</span>:<span class="number">-1</span>&#125;)</span><br><span class="line">db.info.find().sort(&#123;<span class="string">"level"</span>:<span class="number">-1</span>,<span class="string">"subject"</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>limit &amp; skip : limit는 아래로 n개를 선택합니다. skip은 n개 뛰어넘고 그 다음 부터 시작합니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- limit</span><br><span class="line">db.info.find().limit(<span class="number">3</span>)</span><br><span class="line">db.info.find().sort(&#123;<span class="string">"level"</span>:<span class="number">1</span>&#125;).limit(<span class="number">3</span>)</span><br><span class="line">-- skip </span><br><span class="line">db.info.find().skip(<span class="number">2</span>).limit(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h2 id="update">UPDATE</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.info.update(</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"html"</span>&#125;,<span class="comment">//query</span></span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"sass"</span>,<span class="string">"level"</span>:<span class="number">2</span>&#125;<span class="comment">//수정할내용</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>upsert : 데이터가 있으면 update, 없으면 insert를 합니다. 기본적으로 1개만 업데이트. multi:true 해줘야 여러개 데이터를 업데이트 합니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.info.update(</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"less"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subject"</span>:<span class="string">"less"</span>,<span class="string">"level"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"upsert"</span>:<span class="literal">true</span>&#125; </span><br><span class="line">    <span class="comment">// subject에 less가 없는데 upsert: true이므로 &#123;"subject":"less","level":2&#125;로 데이터 입력했음</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="set-unset">$set, $unset</h2><p>특정 데이터를 수정합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.info.update(</span><br><span class="line">    &#123;<span class="string">"level"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"$set"</span>:&#123;<span class="string">"level"</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">multi</span>:<span class="literal">true</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="function">function</h2><p>자바스크립트로 함수를 사용할수 있습니다. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showSkip = <span class="function"><span class="keyword">function</span>(<span class="params">start</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> db.info.find().skip(start<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showSkip(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL quiz</title>
      <link href="/2020/02/14/TIL-Database-2020-02-14-mySQL/"/>
      <url>/2020/02/14/TIL-Database-2020-02-14-mySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="world.sql-데이터로-푼-퀴즈">world.sql 데이터로 푼 퀴즈</h1><a id="more"></a><h2 id="quiz">QUIZ</h2><p>사용하는 언어가 3가지 이하인 국가중 도시인구가 300만 이상인 도시를 아래와 같이 조회하세요.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> country.code, city_population_languages.city_name, city_population_languages.population, country.name, city_population_languages.language_count, city_population_languages.languages</span><br><span class="line"><span class="keyword">from</span> country</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">city_population_languages</span><br><span class="line"><span class="keyword">on</span> country.code = city_population_languages.countrycode</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> city_population_languages.population <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><blockquote><p>VIEW를 이용한 분할관리 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> city_population_languages <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> city_population.name <span class="keyword">as</span> city_name, countrylanguage.countrycode,</span><br><span class="line"><span class="keyword">count</span>(countrylanguage.language) <span class="keyword">as</span> language_count, </span><br><span class="line"><span class="keyword">group_concat</span>(countrylanguage.language) <span class="keyword">as</span> languages, city_population.population</span><br><span class="line"><span class="keyword">from</span> countrylanguage</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span>, population, countrycode</span><br><span class="line"><span class="keyword">from</span> city</span><br><span class="line"><span class="keyword">where</span> population &gt;= <span class="number">3000000</span>) <span class="keyword">as</span> city_population</span><br><span class="line"><span class="keyword">on</span> countrylanguage.countrycode = city_population.countrycode</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> countrylanguage.CountryCode, city_population.population, city_population.name </span><br><span class="line"><span class="keyword">having</span> language_count &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>group by 할때 ,로 여러개 동시에 group by 할수 있음 group by countrylanguage.CountryCode, city_population.population, city_population.name 처럼 여러개로 했었으면 더 빨리 풀수 있었음</p></blockquote><h2 id="quiz-1">QUIZ</h2><p>,로 구분해서 좌측부터 겹치는 부분만 걸러가면서 오른쪽으로 진행 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> category.name, <span class="keyword">sum</span>(payment.amount) <span class="keyword">as</span> total_amount</span><br><span class="line"><span class="keyword">from</span> payment, rental, inventory, film_category, <span class="keyword">category</span></span><br><span class="line"><span class="keyword">where</span> payment.rental_id = rental.rental_id</span><br><span class="line"><span class="keyword">and</span> rental.inventory_id = inventory.inventory_id</span><br><span class="line"><span class="keyword">and</span> inventory.film_id = film_category.film_id</span><br><span class="line"><span class="keyword">and</span> film_category.category_id = category.category_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> category.name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total_amount <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
            <tag> quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL 공부 퀴즈 정리</title>
      <link href="/2020/02/13/TIL-Database-2020-02-13-mysql-study/"/>
      <url>/2020/02/13/TIL-Database-2020-02-13-mysql-study/</url>
      
        <content type="html"><![CDATA[<h1 id="world.sql-데이터로-푼-퀴즈">world.sql 데이터로 푼 퀴즈</h1><a id="more"></a><h4 id="멕시코보다-인구가-많은-나라이름과-인구수를-조회후-인구수-순으로-내림차순-정리">멕시코보다 인구가 많은 나라이름과 인구수를 조회후, 인구수 순으로 내림차순 정리</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> ,population</span><br><span class="line"><span class="keyword">from</span> country</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> population <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="국가별-몇개의-도시가-있는지-조회하고-도시수-순으로-10위까지-내림차순-정렬">국가별 몇개의 도시가 있는지 조회하고 도시수 순으로 10위까지 내림차순 정렬</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> country.name, <span class="keyword">count</span>(city.countrycode) <span class="keyword">as</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">from</span> city</span><br><span class="line"><span class="keyword">join</span> country</span><br><span class="line"><span class="keyword">on</span> city.countrycode = country.code</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> country.name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span> <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="언어별-사용인구를-출력하고-사용인구-순으로-10위까지-내림차순">언어별 사용인구를 출력하고 사용인구 순으로 10위까지 내림차순</h4><p><strong>언어별 퍼센트가 있어서 계산후 합산 했었어야 함</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> countrylanguage.Language,  <span class="keyword">round</span>(<span class="keyword">sum</span>(country.population * countrylanguage.Percentage)) <span class="keyword">as</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">from</span> countrylanguage</span><br><span class="line"><span class="keyword">join</span> country</span><br><span class="line"><span class="keyword">on</span> country.Code = countrylanguage.CountryCode</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> countrylanguage.Language</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span> <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="나라-전체-인구의-10-이상인-도시에서-도시인구가-500만이-넘는-도시를-아래와-같이-조사">나라 전체 인구의 10% 이상인 도시에서 도시인구가 500만이 넘는 도시를 아래와 같이 조사</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city.name, city.countrycode, country.name, <span class="keyword">round</span>((city.population / country.population * <span class="number">100</span>),<span class="number">2</span>) <span class="keyword">as</span> percentage</span><br><span class="line"><span class="keyword">from</span> country</span><br><span class="line"><span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,countrycode, population</span><br><span class="line"><span class="keyword">from</span> city</span><br><span class="line"><span class="keyword">where</span> population &gt;= <span class="number">5000000</span>) <span class="keyword">as</span> city</span><br><span class="line"><span class="keyword">on</span> city.countrycode = country.code</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> percentage <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="면적이-10000km2이상인-국가의-인구밀도1km2당-인구수를-구하고-인구밀도가-200이상인-국가들이-사용하고-있는-언어수가-5가지-이상인-라라를-조회하세요.">면적이 10000km^2이상인 국가의 인구밀도(1km^2당 인구수)를 구하고 인구밀도가 200이상인 국가들이 사용하고 있는 언어수가 5가지 이상인 라라를 조회하세요.</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(<span class="keyword">language</span>) <span class="keyword">as</span> language_count</span><br><span class="line"><span class="keyword">from</span> countrylanguage</span><br><span class="line"><span class="keyword">join</span> (</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> country.code, country.name, <span class="keyword">round</span>((country.population /surfacearea.SurfaceArea)) <span class="keyword">as</span> density</span><br><span class="line"><span class="keyword">from</span> country</span><br><span class="line"><span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> code, <span class="keyword">name</span>, surfacearea</span><br><span class="line"><span class="keyword">from</span> country</span><br><span class="line"><span class="keyword">where</span> surfacearea &gt; <span class="number">10000</span>) <span class="keyword">as</span> surfacearea</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> country.code = surfacearea.code</span><br><span class="line"><span class="keyword">having</span> density &gt;= <span class="number">200</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> density <span class="keyword">DESC</span>) <span class="keyword">as</span> <span class="keyword">test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> test.code = countrylanguage.countrycode</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">having</span> language_count &gt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> language_count <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="가장-돈을-많이-지불한-상위-5명의-고객의-이름과-지불-금액-출력">가장 돈을 많이 지불한 상위 5명의 고객의 이름과 지불 금액 출력</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customer.customer_id,<span class="keyword">concat</span>(customer.first_name,<span class="string">' '</span>,customer.last_name) <span class="keyword">as</span> full_name,<span class="keyword">sum</span>(payment.amount) <span class="keyword">as</span> amount</span><br><span class="line"><span class="keyword">from</span> customer</span><br><span class="line"><span class="keyword">join</span> payment</span><br><span class="line"><span class="keyword">on</span> payment.customer_id = customer.customer_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customer.customer_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> amount <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="배우별-영화-출연-횟수-출력-상위-10개">배우별 영화 출연 횟수 출력 (상위 10개)</h4><blockquote><ul><li>컬럼: 배우이름, 출연횟수</li><li>출연횟수 순으로 내림차순 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> actor.actor_id, <span class="keyword">concat</span>(actor.first_name, <span class="string">' '</span>, actor.last_name) <span class="keyword">as</span> full_name, <span class="keyword">count</span>(<span class="keyword">concat</span>(actor.first_name, <span class="string">' '</span>, actor.last_name)) <span class="keyword">as</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">from</span> actor</span><br><span class="line"><span class="keyword">join</span> film_actor</span><br><span class="line"><span class="keyword">on</span> actor.actor_id = film_actor.actor_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> actor.actor_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span> <span class="keyword">DESC</span>, full_name</span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure> #### 영화 카테고리별 수입 데이터를 내림차순으로 정렬 payment,rental,inventory,film_category,category <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> merged_rental_id.name, <span class="keyword">sum</span>(payment.amount) <span class="keyword">as</span> total_amount</span><br><span class="line"><span class="keyword">from</span> payment</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> rental.rental_id, merged_inventory_id.name</span><br><span class="line"><span class="keyword">from</span> rental</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> inventory.inventory_id, inventory.film_id, merged_film_id.name</span><br><span class="line"><span class="keyword">from</span> inventory</span><br><span class="line"><span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> category.category_id, category.name, film_category.film_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">category</span></span><br><span class="line"><span class="keyword">join</span> film_category</span><br><span class="line"><span class="keyword">on</span> category.category_id = film_category.category_id) <span class="keyword">as</span> merged_film_id</span><br><span class="line"><span class="comment"># as에서 지정해준 이름으로 안의 컬럼을 찾아 들어간다</span></span><br><span class="line"><span class="keyword">on</span> inventory.film_id = merged_film_id.film_id) <span class="keyword">as</span> merged_inventory_id</span><br><span class="line"><span class="keyword">on</span> merged_inventory_id.inventory_id = rental.inventory_id) <span class="keyword">as</span> merged_rental_id</span><br><span class="line"><span class="keyword">on</span> merged_rental_id.rental_id = payment.rental_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total_amount <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">11</span>;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
            <tag> quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL 2</title>
      <link href="/2020/02/13/Database-2020-02-13-mySQL-md/"/>
      <url>/2020/02/13/Database-2020-02-13-mySQL-md/</url>
      
        <content type="html"><![CDATA[<h1 id="join">JOIN</h1><h3 id="left-join">left join</h3><p>왼쪽 테이블을 기준으로 왼쪽 테이블의 모든 데이터가 출력되고 매핑되는 키값이 없으면 NULL로 출력된다. <a id="more"></a></p><blockquote><p>두 테이블을 합쳐 id, name, addr 출력 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> addr.id ,addr.addr, <span class="keyword">IFNULL</span>(user.name,<span class="string">"-"</span>) <span class="keyword">as</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> addr</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ON</span> user.user_id = addr.user_id;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="right-join">right join</h3><p>오른쪽 테이블을 기준으로 왼쪽 테이블의 모든 데이터가 출력되고 매핑되는 키값이 없으면 NULL로 출력된다. &gt; 두 테이블을 합쳐 id, name, addr 출력 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> addr.id, user.name, <span class="keyword">IFNULL</span>(addr.addr,<span class="string">'='</span>) <span class="keyword">as</span> addr</span><br><span class="line"><span class="keyword">FROM</span> addr</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ON</span> user.user_id = addr.user_id;</span><br></pre></td></tr></table></figure> ### union(outer join) select 문의 결과를 합쳐서 출력 &gt; 자동으로 중복을 제거 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> addr</span><br><span class="line"><span class="keyword">from</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> addr</span><br><span class="line"><span class="keyword">from</span> addr;</span><br></pre></td></tr></table></figure> ### outer join <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name, addr.addr, addr.user_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> addr</span><br><span class="line"><span class="keyword">on</span> user.user_id = addr.user_id</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> user.name, addr.addr, addr.user_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> addr</span><br><span class="line"><span class="keyword">on</span> user.user_id = addr.user_id;</span><br></pre></td></tr></table></figure> # SUB-QUERY 쿼리문 안에 쿼리가 있는 문법</p><h3 id="select-from-where">select, from, where</h3><blockquote><p>전체 나라수, 전체 도시수, 전체 언어수를 출력</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span> country) <span class="keyword">as</span> total_country,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span> city) <span class="keyword">as</span> total_city,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span>(<span class="keyword">language</span>))</span><br><span class="line"><span class="keyword">from</span> countrylanguage) <span class="keyword">as</span> total_language;</span><br></pre></td></tr></table></figure><blockquote><p>800만 이상이 되는 도시의 국가 코드, 도시이름, 도시인구수를 출력</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> countrycode, <span class="keyword">name</span>, population</span><br><span class="line"><span class="keyword">from</span> city</span><br><span class="line"><span class="keyword">where</span> population &gt;= <span class="number">8000000</span>) <span class="keyword">as</span> city</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> code, <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> country) <span class="keyword">as</span> country</span><br><span class="line"><span class="keyword">on</span> city.countrycode = country.code;</span><br></pre></td></tr></table></figure><blockquote><p>800만 이상 도시의 국가코드, 국가 이름, 대통령 이름 출력</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> code, <span class="keyword">name</span>, HeadOfState</span><br><span class="line"><span class="keyword">from</span> country</span><br><span class="line"><span class="keyword">where</span> code <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(Countrycode)</span><br><span class="line"><span class="keyword">from</span> city</span><br><span class="line"><span class="keyword">where</span> population &gt;= <span class="number">8000000</span>);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># INDEX</span></span><br><span class="line">데이터를 검색할때 바르게 찾을수 있도록 해주는 기능</span><br><span class="line">index를 해주면 <span class="keyword">insert</span>가 느려짐. 아무때나 쓰는건 아님</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`SQL</span></span><br><span class="line"><span class="string">use employees;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">explain</span></span><br><span class="line"><span class="string">select count(*)</span></span><br><span class="line"><span class="string">from salaries</span></span><br><span class="line"><span class="string">where to_date &gt; "2000-01-01";</span></span><br></pre></td></tr></table></figure><h3 id="index-추가">index 추가</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> tdate</span><br><span class="line"><span class="comment">-- salaries 테이블에  to_data에 인덱스를 만든다.</span></span><br><span class="line"><span class="keyword">on</span> salaries (<span class="keyword">to_date</span>);</span><br></pre></td></tr></table></figure><h3 id="index-삭제">index 삭제</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> tdate</span><br><span class="line"><span class="keyword">on</span> salaries;</span><br></pre></td></tr></table></figure><h1 id="view">VIEW</h1><p>쿼리문에 대한 결과를 저장하는 개념 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> code_name <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> code, <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> country;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>찍어주면 code_name라는 view에서 만들어진 country.code 와 country.name을 불러줌 즉 </em>는 (select code, name from country) as code_name 임 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> city</span><br><span class="line"><span class="keyword">join</span> code_name</span><br><span class="line"><span class="keyword">on</span> city.countrycode = code_name.code;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL 공부 퀴즈 정리</title>
      <link href="/2020/02/12/TIL-Database-2020-02-12-mysql-md/"/>
      <url>/2020/02/12/TIL-Database-2020-02-12-mysql-md/</url>
      
        <content type="html"><![CDATA[<h1 id="world.sql-데이터로-푼-퀴즈">world.sql 데이터로 푼 퀴즈</h1><a id="more"></a><h3 id="quiz1-country-테이블에서-중복을-제거">quiz1 : country 테이블에서 중복을 제거</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(Continent)</span><br><span class="line"><span class="keyword">FROM</span> country;</span><br></pre></td></tr></table></figure><h3 id="quiz2-한국-도시-중에서-인구가-100만명-이상인-도시를-내림차순-으로-정리">quiz2 : 한국 도시 중에서 인구가 100만명 이상인 도시를 내림차순 으로 정리</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>, Population</span><br><span class="line"><span class="keyword">FROM</span> city</span><br><span class="line"><span class="keyword">WHERE</span> CountryCode = <span class="string">"KOR"</span> <span class="keyword">AND</span> Population &gt; <span class="number">1000000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Population <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="quiz3-city-테이블에서-인구가-800만에서-1000만-사이의-도시이름-나라-코드를-출력하고-인구수순-내림차순으로-정리">quiz3 : city 테이블에서 인구가 800만에서 1000만 사이의 도시이름, 나라 코드를 출력하고, 인구수순 내림차순으로 정리</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>, CountryCode, Population</span><br><span class="line"><span class="keyword">FROM</span> city</span><br><span class="line"><span class="keyword">WHERE</span> Population <span class="keyword">BETWEEN</span> <span class="number">8000000</span> <span class="keyword">AND</span> <span class="number">10000000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Population <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="quiz4-country-테이블에서-1940년-부터-1950년까지-독립한-국가를-조회하고-인구수순-내림차순으로-정리">quiz4: country 테이블에서 1940년 부터 1950년까지 독립한 국가를 조회하고 인구수순 내림차순으로 정리</h3><p>NameIndep이란 컬럼을 새로 만들어서 이름(독립연도)가 들어가도록 만들었음 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Code, <span class="keyword">concat</span>(<span class="keyword">Name</span>,<span class="string">"("</span>,IndepYear,<span class="string">")"</span>) <span class="keyword">as</span> NameIndep, Continent, Population</span><br><span class="line"><span class="keyword">FROM</span> country</span><br><span class="line"><span class="keyword">WHERE</span> IndepYear <span class="keyword">BETWEEN</span> <span class="number">1940</span> <span class="keyword">AND</span> <span class="number">1950</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> IndepYear <span class="keyword">ASC</span>, Population <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p><h3 id="quiz5-countrylanguage-테이블에서-영어-스페인어-한국어를-95이상-사용하는-나라를-오름차순으로-정리">quiz5 : countrylanguage 테이블에서 영어, 스페인어, 한국어를 95%이상 사용하는 나라를 오름차순으로 정리</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CountryCode, <span class="keyword">Language</span>, Percentage </span><br><span class="line"><span class="comment">-- / 100 붙여서 브로드캐스팅 연산으로 1 = 100% 로 변경 가능</span></span><br><span class="line"><span class="keyword">FROM</span> countrylanguage</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Language</span> <span class="keyword">in</span> (<span class="string">"English"</span>,<span class="string">"Spanish"</span>,<span class="string">"Korean"</span>) <span class="keyword">AND</span> Percentage &gt;= <span class="number">95.0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Percentage;</span><br></pre></td></tr></table></figure><h3 id="quiz6-country테이블에서-code가-a로-시작하고-governmentform에-republic이-포함되는-데이터를-조회">quiz6 : country테이블에서 code가 A로 시작하고 governmentform에 Republic이 포함되는 데이터를 조회</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Code, <span class="keyword">Name</span>, Continent, GovernmentForm, Population</span><br><span class="line"><span class="keyword">FROM</span> country</span><br><span class="line"><span class="keyword">WHERE</span> Code <span class="keyword">like</span> <span class="string">"A%"</span> <span class="keyword">AND</span> GovernmentForm <span class="keyword">like</span> <span class="string">'%Republic%'</span>;</span><br></pre></td></tr></table></figure><h3 id="city-테이블에서-나라별-도시의-갯수를-출력">city 테이블에서 나라별 도시의 갯수를 출력</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CountryCode, <span class="keyword">count</span>(CountryCode)</span><br><span class="line"><span class="keyword">FROM</span> city</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CountryCode;</span><br></pre></td></tr></table></figure><h3 id="countrylanguage-테이블에서-전체-언어의-갯수를-출력">countrylanguage 테이블에서 전체 언어의 갯수를 출력</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">distinct</span>(<span class="keyword">Language</span>))</span><br><span class="line"><span class="keyword">FROM</span> countrylanguage;</span><br></pre></td></tr></table></figure><h3 id="대륙별-인구수와-gnp의-최대값을-출력">대륙별 인구수와 GNP의 최대값을 출력</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> continent, <span class="keyword">sum</span>(population)</span><br><span class="line"><span class="keyword">FROM</span> country</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> continent;</span><br></pre></td></tr></table></figure><h3 id="대륙별-전체인구를-구하고-5억-이상인-대륙만-출력">대륙별 전체인구를 구하고 5억 이상인 대륙만 출력</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> continent,<span class="keyword">sum</span>(population) <span class="keyword">as</span> TotalPopulation</span><br><span class="line"><span class="keyword">FROM</span> country</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> continent</span><br><span class="line"><span class="keyword">HAVING</span> TotalPopulation &gt; <span class="number">500000000</span>;</span><br></pre></td></tr></table></figure><h2 id="having-group-by가-실행되고-난-결과에-조건을-추가-즉-group-by-밑에where는-group-by전에위에필터링">HAVING : GROUP BY가 실행되고 난 결과에 조건을 추가, 즉 GROUP BY 밑에(WHERE는 GROUP BY전에(위에)필터링)</h2>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
            <tag> quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL 1</title>
      <link href="/2020/02/12/Database-2020-02-12-mySQL-md/"/>
      <url>/2020/02/12/Database-2020-02-12-mySQL-md/</url>
      
        <content type="html"><![CDATA[<h1 id="기본-명령">1. 기본 명령</h1><h2 id="확인">확인</h2><ul><li><code>SHOW DATABASE</code> : 현재 데이터 베이스 확인 <a id="more"></a></li></ul><h2 id="생성">생성</h2><ul><li><code>CREATE DATABASE</code></li><li><code>CREATE TABLE</code></li></ul><h2 id="데이터-베이스-선택-확인">데이터 베이스 선택 확인</h2><ul><li><code>SELECT DATABASE()</code></li></ul><h1 id="테이블-생성">2. 테이블 생성</h1><ul><li>좌측이 컬럼의 이름, 우측이 컬럼에 들어갈 데이터 타입 &gt; ;(세미콜론) 단위로 끊어서 실행하니. 꼭 주의해서 붙여줄것!</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user1(</span><br><span class="line">    user_id <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    age <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">    rdate <span class="built_in">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>데이터 타입에 추가로 조건을 줄수 있다. <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user2(</span><br><span class="line">user_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="comment">-- PRIMARY KEY : unique + not null 조건을 가짐</span></span><br><span class="line">  <span class="comment">-- AUTO_INCREMENT : 1씩 증가한다</span></span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 데이터가 없으면 '30 들어간다'</span></span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 현재시간이 자동으로 들어가는 데이터 타입</span></span><br><span class="line">rdate <span class="built_in">TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="수정-alter">3. 수정 Alter</h1><h4 id="데이터-베이스-수정">데이터 베이스 수정</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"character_set_database"</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8;</span><br></pre></td></tr></table></figure><h4 id="테이블-추가-수정-삭제">테이블 추가, 수정, 삭제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user2 <span class="keyword">ADD</span> tmp <span class="built_in">TEXT</span>;</span><br><span class="line"><span class="comment">-- user2 테이블에 텍스트 타입을 가지고 있는 tmp라는 컬럼 추가</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user2 <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> tmp <span class="built_in">INT</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">-- tmp컬럼을 인트타입으로 변경</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user2 <span class="keyword">DROP</span> tmp;</span><br><span class="line"><span class="comment">-- tmp 컬럼을 삭제</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user1 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8;</span><br><span class="line"><span class="comment">-- user1테이블을 utf8로 변경</span></span><br></pre></td></tr></table></figure><h2 id="drop">Drop</h2><h4 id="데이터-베이스-삭제">데이터 베이스 삭제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> tmp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> tmp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> test3;</span><br></pre></td></tr></table></figure><h4 id="테이블-삭제">테이블 삭제</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> user3;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br></pre></td></tr></table></figure><h2 id="insert-데이터-추가">Insert : 데이터 추가</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user1(user_id, <span class="keyword">name</span>, email, age, rdate)</span><br><span class="line"><span class="comment">-- user1 테이블에 각 컬럼에다</span></span><br><span class="line"><span class="keyword">VALUE</span>(<span class="number">2</span>,<span class="string">"howard2"</span>,<span class="string">'yoohowon@gmail.com'</span>,<span class="number">31</span>,<span class="keyword">now</span>()),</span><br><span class="line">(<span class="number">3</span>,<span class="string">"a"</span>,<span class="string">'owon@gmail.com'</span>,<span class="number">15</span>,<span class="keyword">now</span>()),</span><br><span class="line">(<span class="number">4</span>,<span class="string">"peter"</span>,<span class="string">'yoohowon@gmail.com'</span>,<span class="number">12</span>,<span class="keyword">now</span>()),</span><br><span class="line">(<span class="number">5</span>,<span class="string">"po"</span>,<span class="string">'yohowon@gmail.com'</span>,<span class="number">2</span>,<span class="keyword">now</span>()),</span><br><span class="line">(<span class="number">6</span>,<span class="string">"hord"</span>,<span class="string">'yoohowon@gmail.com'</span>,<span class="number">56</span>,<span class="keyword">now</span>());</span><br><span class="line"><span class="comment">-- 이런 값들을 준다, </span></span><br><span class="line"><span class="comment">-- rdate는 TIMESTAMP 타입, now()는 현재 시간을 입력</span></span><br></pre></td></tr></table></figure><h1 id="select-데이터-조회">4. SELECT : 데이터 조회</h1><blockquote><p>컬럼명, 불러올때 as로 이름 지정 가능 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 컬럼이름, 불러올때 as로 이름 지정 가능</span></span><br><span class="line"><span class="keyword">SELECT</span> user_id <span class="keyword">as</span> <span class="string">"아이디"</span>, <span class="keyword">name</span> <span class="keyword">as</span> <span class="string">"이름"</span>, age <span class="keyword">as</span> <span class="string">"나이"</span></span><br><span class="line"><span class="comment">-- 테이블 이름</span></span><br><span class="line"><span class="keyword">FROM</span> user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 전체 선택</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="distinct-중복제거">5. DISTINCT 중복제거</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">FROM</span> user1;</span><br></pre></td></tr></table></figure><h1 id="where-조건검색">6. WHERE 조건검색</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 30세 이상인 사용자를 검색해서 이름의 종류(UNIQUE 한) 개수를 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">name</span>))</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> age &gt;= <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> age &gt;= <span class="number">20</span> <span class="keyword">AND</span> age &lt; <span class="number">40</span>;</span><br><span class="line"><span class="comment">-- AND 가능</span></span><br></pre></td></tr></table></figure><h2 id="범위데이터-가져오기-between-a-and-b">범위데이터 가져오기 : BETWEEN A AND B</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">39</span>;</span><br></pre></td></tr></table></figure><h2 id="order-by-정렬">ORDER BY ,정렬</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>, age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><blockquote><p>내림차순, 오름차순 정렬 &gt; ASC: asending &gt; DESC : descending</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 나이가 20세 에서 40세 사이에 있는 사용자를 이름 순으로 정렬하고, 중복데이터를 제거 해서 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h2 id="concat">concat</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, age, <span class="keyword">concat</span>(<span class="keyword">name</span>,<span class="string">"("</span>,age,<span class="string">")"</span>) <span class="keyword">as</span> name_age</span><br><span class="line"><span class="keyword">FROM</span> user1;</span><br></pre></td></tr></table></figure><h2 id="like-where-절에서-특정-문자열이-들어간-데이터-조회">like : where 절에서 특정 문자열이 들어간 데이터 조회</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="comment">-- %%앞 뒤에 어떤 문자나 숫자가 온다는 뜻</span></span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">like</span> <span class="string">"%@gmail.%"</span>;</span><br><span class="line"><span class="comment">-- WHERE email not like "%@gmail.%"</span></span><br><span class="line"><span class="comment">-- # 처음부터 시작</span></span><br><span class="line"><span class="comment">-- WHERE email like "p%"</span></span><br></pre></td></tr></table></figure><h2 id="in-여러-개의-조건을-조회할때-사용">in : 여러 개의 조건을 조회할때 사용</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="comment">-- WHERE name ="howard" or name="po" or name="hord" 보다 아래가 나음</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'howard'</span>,<span class="string">'po'</span>,<span class="string">'hord'</span>);</span><br></pre></td></tr></table></figure><h2 id="in의-활용-서브-쿼리">in의 활용 : 서브 쿼리</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">from</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">30</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="limit-출력-갯수-제한">LIMIT : 출력 갯수 제한</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1</span><br><span class="line"><span class="comment">-- 3번째 부터 밑으로 5개 </span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="update-데이터를-수정">6. UPDATE : 데이터를 수정</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user1</span><br><span class="line"><span class="keyword">SET</span> age=<span class="number">30</span>, rdate=<span class="string">"2019-12-12"</span></span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">39</span>;</span><br><span class="line"><span class="comment">-- age 컬럼의 값이 30~39인 경우 age=30으로 하고, rdate="2019-12-12로 바꾼다</span></span><br></pre></td></tr></table></figure><h2 id="delete">7. DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user1</span><br><span class="line"><span class="keyword">WHERE</span> rdate &lt; <span class="string">"2020-02-12"</span>;</span><br><span class="line"><span class="comment">-- rdate가 "2020-02-12"보다 낮은경우 지워라</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> user1;</span><br></pre></td></tr></table></figure><h2 id="having">HAVING</h2><blockquote><p>GROUP BY가 실행되고 난 결과에 조건을 추가, 즉 GROUP BY 밑에(WHERE는 GROUP BY전에(위에)필터링)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>정규분포에서 파생된 분포, 모수추정이란?</title>
      <link href="/2020/02/11/TIL-mathematics-2020-02-11-math-md/"/>
      <url>/2020/02/11/TIL-mathematics-2020-02-11-math-md/</url>
      
        <content type="html"><![CDATA[<h1 id="정규-분포에서-파생된-분포">정규 분포에서 파생된 분포</h1><h2 id="스튜던트-t분포">스튜던트 t분포</h2><ul><li>펫테일을 보이는 데이터모형에 적합(주식 데이터 등)</li><li>스튜던트 t 분포는 의 확률밀도 함수 <span class="math display">\[t \sim (x;\mu(모수),\lambda(표준편차), \nu(자유도))\]</span></li><li>자유도가 1이면 코시분포, 코시분포의 양수인 부분을 하프코시분포</li><li>정규분포를 따르는 확률 변수의 <span class="math inline">\(N\)</span> 개의 표본의 합(또는 평균)은 표본 분산으로 정규화하면 스튜던트 t분포를 따른다</li></ul><h2 id="t-통계량">t 통계량</h2><ul><li>정규분포로 부터 얻은 <span class="math inline">\(N\)</span> 개의 표본에서 계산한 <strong>표본평균</strong>을 <strong>표본표준편차</strong>로 정규화한 값</li></ul><h2 id="카이제곱분포">카이제곱분포</h2><ul><li>정규분포를 따르는 확률 변수의 <span class="math inline">\(N\)</span> 개의 표본을 제곱하여 더하면 <strong>양수값만을 가지는 분포가 된다.</strong></li><li><span class="math inline">\(N\)</span>이 커질수록(여러개를 더할수록, 중심극한정리에 의해) 정규분포 처럼 된다.</li></ul><h2 id="f분포">F분포</h2><ul><li>카이제곱분포를 따르는 독립적인 두 개의 확률 변수의 확률 변수 표본을 각각 <span class="math inline">\(x_{1}, x_{2}\)</span> 라고 할때, 이를 각각 표본의 갯수 <span class="math inline">\(N_{1}, N_{2}\)</span>로 나눈뒤 비율을 구한 분포를 F분포라고 한다.</li></ul><h2 id="가지-통계량-공식">5가지 통계량 공식</h2><h2 id="다변수-정규분포">다변수 정규분포</h2><ul><li>고유값분해 : 다변수정규분포 함수의 정밀도행렬이 가지는 고유값: 타원의 폭, 고유벡터: 타원의 방향</li><li>고유값 분해해서 나온 공분산 행렬 <span class="math inline">\(\Sigma\)</span>를 변환행렬로 생각하고, 새로운 기저벡터를 만든다. (회전하고 이동한다)</li><li>다변수 정규분포의 조건부 확률분포(자른다): 다변수 정규분포인 확률변수벡터 중 어떤 원소의 값이 주어지면 다른 확률변수의 조건부 확률 분포는 다변수 정규분포이다.</li><li>다변수 정규분포의 주변 확률분포(누른다): 다변수 정규분포의 주변확률분포는 다변수 정규분포이다.</li></ul><h2 id="베타분포">베타분포</h2><ul><li>0~1까지 가질수 있는 베르누이 분포의 모수 <span class="math inline">\(\mu\)</span>의 값을 베이지안 추정한 결과로 표현한것.</li><li><span class="math inline">\(Beta \sim (x;a,b)\)</span> : a,b가 커질수록 모수추정의 정확도가 높아짐(그래프가 더 뾰족)</li></ul><h2 id="감마분포">감마분포</h2><ul><li>0부터 무한대의 값을 가지는 양수값을 추정하는데 사용</li></ul><h2 id="디리클레-분포">디리클레 분포</h2><ul><li>디리클레분포는 베타분포의 확장판. 베타분포는 0과 1사이의 값을 가지는 단일(univariate) 확률변수의 베이지안 모형에 사용되고 디리클레분포는 0과 1사이의 사이의 값을 가지는 다변수(multivariate) 확률변수의 베이지안 모형에 사용된다.</li><li>베타분포는 변수의 갯수 k=2인 디리클레 분포</li></ul><h2 id="하이퍼모수">하이퍼모수</h2><ul><li>베타분포, 디리클레분포의 모수 (=&gt; 베르누이분포, 카테고리분포의 모수의 모수)</li></ul><h1 id="확률분포의-추정">확률분포의 추정</h1><ul><li>데이터로 부터 확률변수의 분포를 알아내는 과정</li><li>step1 : 확률변수가 어떤 확률분포를 따르는지 확인</li><li>step2 : 모수추정</li></ul><h2 id="모수추정">모수추정</h2><ul><li>모수의 값으로 가장 가능성이 높은 하나의 숫자를 찾아내는 작업</li><li>모멘트 방법: 표본자료의 &quot;표본 모멘트&quot;와 확률분포의 &quot;이론적 모멘트&quot;가 같다고 가정<ul><li>베르누의 분포의 모수추정</li><li>정규분포의 모수추정</li><li>베타분포의 모수추정</li></ul></li></ul><h1 id="최대-가능도-추정법">최대 가능도 추정법</h1><ul><li>가능도 함수를 사용</li></ul><h2 id="가능도-함수">가능도 함수</h2><ul><li>확률 밀도 함수는 일반적으로 모수를 알고 표본값을 찾아내지만</li><li>가능도 함수는 표본값을 가지고 있고 이를 뽑아내는 모수를 찾아내는 함수</li></ul><h2 id="최대가능도-추정법">최대가능도 추정법</h2><ul><li>주어진 표본에 대해 가능도를 가장 크게 하는 모수를 찾는 방법</li></ul><h2 id="로그-가능도-함수">로그 가능도 함수</h2><ul><li>반복시행으로 인한 복수데이터는 pdf들의 곱으로 나타내야 하는데, 로그를 취하면 더하기로 표현 가능</li></ul><h2 id="각-분포별-최대가능도-모수추정">각 분포별 최대가능도 모수추정</h2><ul><li>베르누이 분포 : 모수는 1이 나온 횟수와 전체 시행횟수의 비율</li><li>카테고리 분포 : 모수는 각 범주값이 나온 횟수와 전체 시행횟수의 비율</li><li>정규분포 : 기대값은 표본평균, 분산은 (편향)표본평균</li><li>다변수 정규분포 : 기대값은 표본평균벡터, 분산은 표본공분산 행렬</li></ul><h1 id="베이즈-추정법">베이즈 추정법</h1><ul><li>모수를 숫자 하나로 얘기하지 않고, 모수값을 가질수 있는 모든 가능성의 분포를 계산</li></ul><h2 id="베이즈-추정법의-기본-원리">베이즈 추정법의 기본 원리</h2><ul><li>사전분포, 사후분포, 가능도 분포로 구성</li><li>모수적 방법, 비모수적 방법(MCMC - 몬테 카를로 방법)</li></ul><h2 id="베이즈-추정법의-모수적-방법">베이즈 추정법의 모수적 방법</h2><ul><li>켤레 사전확률 분포 : 사전분포와 사후분포가 형태는 같고, 모수값만 다른 경우</li><li>베르누이 분포의 모수 추정<ul><li>베타분포라고 가정</li></ul></li><li>카테고리 분포의 모수추정<ul><li>디리클레 분포라고 가정</li></ul></li><li>정규분포의 기대값, 모수추정</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>정규분포와 중심극한정리</title>
      <link href="/2020/02/11/TIL-mathematics-2020-03-03-probability4/"/>
      <url>/2020/02/11/TIL-mathematics-2020-03-03-probability4/</url>
      
        <content type="html"><![CDATA[<h2 id="정규분포normal-distribution">정규분포(normal distribution)</h2><ul><li>자연 현상에서 나타나는 숫자를 확률모형으로 모형화 할때 사용한다.</li><li>정규분포는 평균 <span class="math inline">\(\mu\)</span>와 분산<span class="math inline">\(\sigma^2\)</span>이라는 두 모수만으로 정의된다.</li><li>정규분포의 확률밀도함수(pdf)</li></ul><p><span class="math display">\[\mathcal{N}(x;\mu,\sigma^2) = {1 \over \sqrt{2\pi\sigma^2}}\exp\left(-{(x-\mu)^2\over 2\sigma^2}\right) \]</span></p><h2 id="표준정규분포standard-normal-distribution">표준정규분포(standard normal distribution)</h2><ul><li>정규분포 중에서 평균이 0이고 분산이 1인<span class="math inline">\((\mu = 0, \sigma^2 = 1)\)</span>정규분포를 표준정규분포라고 한다.</li><li>표준정규분포의 확률밀도함수의 값<span class="math inline">\(x\)</span>는<ul><li><span class="math inline">\(x = \mu\)</span>일때 확률밀도가 최대가 된다.</li><li><span class="math inline">\(x = \infty\)</span>로 다가가거나 <span class="math inline">\(x = -\infty\)</span>로 다가갈수록 확률밀도가 작아진다.</li></ul></li></ul><h2 id="로그정규분포">로그정규분포</h2><ul><li>데이터에 로그를 한 값 또는 변화율이 정규분포가 되는 분포를 말한다.</li><li>로그정규분포를 띄는 데이터는 항상 양수다. 따라서 로그변환한 다음 사용한다.</li></ul><h3 id="q-q플롯">Q-Q플롯</h3><ul><li>어떤 확률변수의 분포가 정규분포인지를 판단하는 방법.</li><li>표본데이터의 분포와 정규분포의 분포형태를 비교하는 시각적 도구.</li></ul><h3 id="중심극한정리central-limit-theorem">중심극한정리(Central Limit Theorem)</h3><ul><li>여러 확률변수의 합이 정규분포와 비슷한 분포를 이루는 현상을 말한다.</li><li>확률이론의 중심이라고 말할정도로 중요하다고 해서 &quot;중심&quot;이라는 표현을 사용함.</li><li>중심극한정리 &gt; <span class="math inline">\(N\)</span>개의 임의의 분포로부터 얻은 표본의 평균은 <span class="math inline">\(N\)</span>이 증가할수록 기대값이 <span class="math inline">\(\mu\)</span>, 분산이 <span class="math inline">\(\sigma^2 \over N\)</span>인 정규분포로 수렴한다.</li></ul><p><span class="math display">\[\bar X_N \buildrel d \over \rightarrow \mathcal{N} \left(x;\mu,{\sigma^2\over N} \right)\]</span></p><ul><li><p>$d $는 표본개수 <span class="math inline">\(N\)</span>이 커질수록 분포의 모양이 특정한 분포(여기선 정규분포)에 수렴한다는 뜻.</p></li><li><p>평균이 0, 분산이 1이 되도록 표준정규분포로 정규화 하면 &gt; <span class="math inline">\(N\)</span>개의 임의의 분포로 부터 얻은 표본의 평균을 정규화하면 <span class="math inline">\(N\)</span>이 증가할수록 표준정규분포로 수렴한다.</p></li></ul><p><span class="math display">\[{\bar X_N - \mu \over{\sigma \over \sqrt N}}\buildrel d \over \rightarrow \mathcal{N}(x;0,1)\]</span></p><h3 id="정규분포의-통계량-분포">정규분포의 통계량 분포</h3><ul><li>임의의 분포가 아닌 정규분포로 부터 데이터를 얻으면 &gt; <span class="math inline">\(N\)</span>개의 정규분포로부터 얻은 표본의 합은 <span class="math inline">\(N\)</span>과 상관없이 기대값이 <span class="math inline">\(N\mu\)</span>,분산이 <span class="math inline">\(N\sigma^2\)</span>인 정규분포다</li></ul><p><span class="math display">\[x_i \sim \mathcal{N}(\mu,\sigma^2) \rightarrow  \sum_{i=1}^{N}x_i \sim \mathcal{N}(N\mu,N\sigma^2)\]</span></p><ul><li>정규분포의 표본에 상수를 빼거나 곱해도 표본은 여전히 정규분포를 따른다. 따라서 표준정규분포로 정규화 할수 있다. 이떄, 정규분포 표본의 평균을 정규화한 통계량을 <span class="math inline">\(z\)</span>통계량이라고 한다.</li></ul><p><span class="math display">\[x_i \sim \mathcal{N}(\mu,\sigma^2) \rightarrow z = {\bar x - \mu \over{\sigma \over \sqrt N}}\sim \mathcal{N}(x;0,1)\]</span></p><ul><li>중심극한정리에서는 표준정규분포로 점점 다가갈 뿐이고, 표본개수가 무한대가 되기 전에는 정확한 정규분포가 아니다.</li><li><span class="math inline">\(z\)</span>통계량은 개수 N에 상관없이 항상 정확하게 표준정규분포 이다.</li></ul><h3 id="선형회귀모형과-정규분포">선형회귀모형과 정규분포</h3><ul><li>정규분포는 선형회귀모형에서 잡음 <span class="math inline">\(\epsilon\)</span>을 모형화 하는데 사용된다.</li><li>선형회귀모형이란 입력번수 <span class="math inline">\(x_1,\dots,x_N\)</span>이 종속변수 <span class="math inline">\(y\)</span>에 선형적으로 영향을 미치는 모형이다. <span class="math display">\[y = w_1x_1 + \dots + w_Nx_n + \epsilon\]</span></li><li>이떄 잡음 <span class="math inline">\(\epsilon\)</span>은 우리가 측정할수 없는 양이다. 선형회귀모형을 만들때, 측정하기 힘들어 무시하는 무한한 변수들의 영향을 하나로 합친것이 잡음이다.</li><li>중심극한정리에 의해 임의의 확률변수의 합은 정규분포와 비슷한 형태가 되고, 여기서 잡음 <span class="math inline">\(\epsilon\)</span>또한 기대값이 0인 정규분포라고 가정하고 갈수 있다.</li></ul><p><span class="math display">\[\epsilon \sim \mathcal{N}(0,\sigma^2)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>카테고리분포와 다항분포</title>
      <link href="/2020/02/10/TIL-mathematics-2020-03-03-probability3/"/>
      <url>/2020/02/10/TIL-mathematics-2020-03-03-probability3/</url>
      
        <content type="html"><![CDATA[<h2 id="카테고리-확률변수">카테고리 확률변수</h2><ul><li>카테고리 확률변수는 1부터 <span class="math inline">\(K\)</span>까지의 <span class="math inline">\(K\)</span>개 정수값 중 하나가 나온다. 이 정수값을 범주값, 카테고리, 클래스 등으로 부른다. (주사위를 던져서 나오는 눈금 수는 <span class="math inline">\(K=6\)</span>인 카테고리분포다)</li></ul><h3 id="원핫인코딩one-hot-encoding">원핫인코딩(One-Hot-Encoding)</h3><ul><li>카테고리는 스칼라값이지만, 카테고리 확률변수는 1과0으로만 이루어진 다차원 벡터를 출력한다.</li><li>스칼라값을 이렇게 벡터로 변환하는 것을 원핫인코딩이라고 한다.</li></ul><p><span class="math display">\[x = 1 \rightarrow x = (1,0,0,0,0,0) \\x = 2 \rightarrow x = (0,1,0,0,0,0) \\x = 3 \rightarrow x = (0,0,1,0,0,0) \\x = 4 \rightarrow x = (0,0,0,1,0,0) \\x = 5 \rightarrow x = (0,0,0,0,1,0) \\x = 6 \rightarrow x = (0,0,0,0,0,1) \\\]</span></p><ul><li>따라서 카테고리 확률변수의 값도 벡터로 표시한다. <span class="math display">\[x = (x_1,x_2,x_3,x_4,x_5,x_6)\]</span><ul><li>벡터의 원소 <span class="math inline">\(x_k\)</span>값으로 0 또는 1만 가능하고,</li><li>벡터의 원소 <span class="math inline">\(x_k\)</span>중 하나만 1일수 있다.</li></ul></li><li>각각의 <span class="math inline">\(x_k\)</span>는 베르누이 확률변수로 볼 수 잇기 때문에, 1이 나올 확률을 나타내는 모수 <span class="math inline">\(\mu_k\)</span>를 가진다. 따라서 카테고리분포의 모수는 벡터로 나타낸다</li></ul><p><span class="math display">\[\mu = (\mu_1,\dots,\mu_k)\]</span></p><ul><li>모수벡터의 조건은 <span class="math display">\[0 \leq \mu_i \leq 1\]</span> <span class="math display">\[\sum_{k=1}^{K}\mu_k = 1\]</span><ul><li>모수값 <span class="math inline">\(\mu_k\)</span>는 0과 1사이의 값이고</li><li>모수값 <span class="math inline">\(\mu_k\)</span>의 전체 합은 1이다</li></ul></li></ul><h2 id="카테고리-확률분포">카테고리 확률분포</h2><p><span class="math display">\[Cat(x_1,x_2,\dots,x_k;\mu_1,\dots,\mu_k)\]</span></p><p>로 표기하거나 벡터 <span class="math inline">\(x,mu\)</span>를 이용하여</p><p><span class="math display">\[Cat(x;mu)\]</span> 로 표기한다</p><ul><li>카테고리 확률변수의 확률질량함수는 원핫인코딩을 사용해보면</li></ul><p><span class="math display">\[Cat(x;\mu) = \mu_1^{x_1}\mu_2^{x_2}\dots \mu_k^{x_k} = \prod_{k=1}^{k}\mu_k^{x_k}\]</span></p><h2 id="카테고리분포의-모멘트">카테고리분포의 모멘트</h2><ul><li>기대값</li></ul><p><span class="math display">\[E[x_k] = \mu_k\]</span></p><ul><li>분산</li></ul><p><span class="math display">\[Var[x_k] = \mu_k(1-\mu_k)\]</span></p><h2 id="다항분포">다항분포</h2><ul><li>베르누이 확률변수의 데이터가 복수이면 이 데이터의 합은 : 이항분포</li><li><p>카테고리 확률변수의 데이터가 복수이면 이 데이터의 합은 : 다항분포</p></li><li>동전을 <span class="math inline">\(N\)</span>번 던져 앞면이 나온 횟수의 분포 = 이항분포</li><li><p>주사위를 <span class="math inline">\(N\)</span>번 던져 각 면이 나온 횟수의 집합의 분포 = 다항분포</p></li><li>다항분포는 카테고리가 <span class="math inline">\(K\)</span>개인 카테고리 확률변수의 표본데이터를 <span class="math inline">\(N\)</span>개 얻었을 때, 각각의 카테고리 <span class="math inline">\(k = (x_1,\dots,x_k)\)</span>가 각각 <span class="math inline">\(x_k\)</span>번 나올 확률분포, 즉 표본값이 벡터 <span class="math inline">\(x = (x_1,\dots,x_k)\)</span>가 되는 확률분포이다.<ul><li><span class="math inline">\(x = (1,2,1,2,3,1)\)</span>은 주사위를 10번 던져서 1인면이 1번, 2인면이 2번, 3인면이 1번 ... 나왔다는 뜻이다.</li></ul></li><li><p>다항분포의 확률질량함수는</p></li></ul><p><span class="math display">\[Mu(x;N,\mu) = \begin{pmatrix}N \\ x \end{pmatrix} \prod_{k=1}^{k}\mu_k^{x_k} = \begin{pmatrix}N \\ x_1,\dots,x_k \end{pmatrix} \prod_{k=1}^{k}\mu_k^{x_k}\]</span></p><h3 id="다항분포의-모멘트">다항분포의 모멘트</h3><ul><li>기대값</li></ul><p><span class="math display">\[E[x_k] = N\mu_k\]</span></p><ul><li>분산</li></ul><p><span class="math display">\[Var[x_k] = N\mu_k(1-\mu_k)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>베르누이분포, 이항분포란?</title>
      <link href="/2020/02/10/TIL-mathematics-2020-02-10-bernoilli-md/"/>
      <url>/2020/02/10/TIL-mathematics-2020-02-10-bernoilli-md/</url>
      
        <content type="html"><![CDATA[<h2 id="베르누이-시행bernoulli-trial">베르누이 시행(Bernoulli trial)</h2><ul><li>결과가 두가지 중 하나로만 나오는 실험이나 시행</li></ul><h2 id="베르누이-확률변수">베르누이 확률변수</h2><ul><li>베르누이 시행결과를 0 또는 1로 바꾼것을 베르누이 확률변수라고 한다.</li><li>베르누이 확률변수는 두 값중 하나만 가지므로, 셀수있는 이산확률변수이다.</li></ul><h2 id="베르누이-확률분포">베르누이 확률분포</h2><ul><li>베르누이 확률변수의 분포를 베르누이 확률분포라고 한다.</li><li>어떤 확률변수 <span class="math inline">\(X\)</span>가 베르누이분포에 의해 발생된다면, <code>확률변수 $X$가 베르누이분포를 따른다</code> 라고 명명한다.</li></ul><p><span class="math display">\[X \sim  Bern(x;\,u)\]</span></p><ul><li>베르누이 분포의 확률질량함수(pmf)의 수식은 <span class="math display">\[Bern(x;\mu) = \mu^x(1-\mu)^{(1-x)}\]</span></li></ul><h2 id="베르누이분포의-모멘트">베르누이분포의 모멘트</h2><ul><li>기대값</li></ul><p><span class="math display">\[E[X] = \mu\]</span></p><ul><li>분산</li></ul><p><span class="math display">\[Var[x] = \mu(1-\mu)\]</span></p><h2 id="이항분포bianomial-distribution">이항분포(bianomial distribution)</h2><ul><li>성공확률이 <span class="math inline">\(\mu\)</span>인 베르누이 시행을 <span class="math inline">\(N\)</span>번 반복하는 경우, 성공한 횟수를 확률변수 <span class="math inline">\(X\)</span>라고 한다면 <span class="math inline">\(X\)</span>의 값은 0부터 <span class="math inline">\(N\)</span>까지의 정수중 하나가 된다.</li><li>이런 확률변수를 이항분포를 따르는 확률변수라고 한다</li></ul><p><span class="math display">\[X \sim Bin(x;N,\mu)\]</span></p><ul><li>이항분포를 따르는 확률변수 <span class="math inline">\(X\)</span>의 확률질량함수</li></ul><p><span class="math display">\[Bin(x;N,\mu) = \begin{pmatrix} N \\x\end{pmatrix}\mu^x(1-\mu)^{N-x}\]</span></p><p><span class="math display">\[\begin{pmatrix} N \\x\end{pmatrix} = {N! \over x!(N -x)!}\]</span></p><h2 id="이항분포의-모멘트">이항분포의 모멘트</h2><ul><li>기대값</li></ul><p><span class="math display">\[E[X] = N\mu\]</span></p><ul><li>분산</li></ul><p><span class="math display">\[Var[X] = N\mu(1-\mu)\]</span></p><h3 id="베르누이분포와-이항분포의-모수추정">베르누이분포와 이항분포의 모수추정</h3><ul><li>데이터에서 모수의 값을 찾아내는 과정을 모수추정이라고 한다.</li></ul><p><span class="math display">\[\hat \mu = {\sum_{i=1}^{N}x_i \over N} = {N_1 \over N}\]</span></p><ul><li><span class="math inline">\(N\)</span>은 전체 데이터의수, <span class="math inline">\(N_1\)</span>은 1이 나온 횟수이다.</li></ul><h4 id="베르누이-분포를-활용한-스팸메일-예제">베르누이 분포를 활용한 스팸메일 예제</h4>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>조건부 기대값과 예측문제</title>
      <link href="/2020/02/07/TIL-mathematics-2020-03-03-probability2/"/>
      <url>/2020/02/07/TIL-mathematics-2020-03-03-probability2/</url>
      
        <content type="html"><![CDATA[<h2 id="조건부기대값">조건부기대값</h2><ul><li>확률변수 <span class="math inline">\(Y\)</span>의 기대값을 구할 때, 주변확률밀도함수 <span class="math inline">\(p_Y(y)\)</span>를 사용하여 가중치를 계산하지 않고, 조건부 확률밀도 함수 <span class="math inline">\(p_{X|Y}(y|x)\)</span>를 이용하여 가중치를 계산하면 조건부기대값(conditional expectation) 혹은 조건부평균(conditional mean)이 된다.</li></ul><p><span class="math display">\[ E_Y[Y|X] = \int_{y=-\infty}^{y=\infty}yp_{X|Y}(y|x)dy\]</span> 혹은 <span class="math display">\[ E[Y|X] = \int yp(y|x)dy\]</span></p><ul><li><p>조건부 기대값에서 조건이 되는 확률변수 <span class="math inline">\(X\)</span>의 값 <span class="math inline">\(x\)</span>는 조건부기대값을 만들때 지정해줘야 하는 독립변수다. 따라서, 조건부기대값은 조건이 되는 확률변수 <span class="math inline">\(X\)</span>의 값 <span class="math inline">\(x\)</span>의 값에 따라 달라진다.</p></li><li><p><span class="math inline">\(E[Y|X]\)</span>는 조건이 되는 확률변수 <span class="math inline">\(X\)</span>의 값 <span class="math inline">\(x\)</span>를 입력으로 받는 함수이다.</p></li></ul><p><span class="math display">\[E[Y|X = x] = f(x)\]</span></p><h2 id="예측문제">예측문제</h2><ul><li>두 확률변수가 <span class="math inline">\(X,Y\)</span>에서 <span class="math inline">\(X\)</span>의 값을 알고 있을 때, <span class="math inline">\(Y\)</span>의 값을 알아내는 것을 예측(prediction)문제라고 한다.</li><li><span class="math inline">\(Y\)</span>가 연속확률변수이면 회기분석, 이산확률변수이면 분류라고 한다.</li><li><span class="math inline">\(X\)</span>의 값 <span class="math inline">\(x\)</span>를 알면 조건부확률분포 <span class="math inline">\(p(y|x)\)</span>의 분포를 알수 있지만, 예측문제의 답은 대표성이 있는 하나의 값이 되어야 하므로, 일반적으로 조건부확률분포의 기대값인 조건부기대값을 예측문제의 답으로 한다. <span class="math display">\[x \rightarrow \hat y = E[y|x] = f(x)\]</span></li></ul><h2 id="조건부기대값의-성질">조건부기대값의 성질</h2><ul><li>우리가 <span class="math inline">\(X\)</span>의 값 <span class="math inline">\(x\)</span>를 정하는 순간 <span class="math inline">\(Y\)</span>의 값도 정해져 버리기 때문에 <span class="math inline">\(E[Y|X]\)</span>는 더이상 확률적인 값이 아닌 상수가 된다.</li></ul><p><span class="math display">\[E[Y|X] = E[g(X)|X] = g(X)\]</span></p><h2 id="전체-기대값의-법칙">전체 기대값의 법칙</h2><ul><li>조건부기대값은 확률변수 이므로 조건이 되는 확률변수에 대해 다시 기대값을 구할 수 있다.</li></ul><p><span class="math display">\[E_X[E_Y[Y|X]] = E_Y[Y]\]</span></p><p><span class="math display">\[E[E[Y|X]] = E[Y]\]</span></p><ul><li>이를 전체기대값(low of total expectation)의 법칙, 또는 반복기대값의 법칙(law of interated expectation)이라고 한다.</li></ul><h2 id="조건부분산">조건부분산</h2><ul><li>조건부분산을 정의하면</li></ul><p><span class="math display">\[Var_Y[Y|X] = E_Y[(Y - E_Y[]Y|X)^2|X] = \int(Y - E_Y[Y|X])^2f_{Y|X}(y|x)dy\]</span></p><ul><li>조건부분산은 <span class="math inline">\(x\)</span>의 값을 알고 있을때, 이에대한 조건부확률분포 <span class="math inline">\(p(y|x)\)</span>의 분산이다.</li><li>예측문제에서, 조건부분산은 예측의 불확실성, 즉 예측으로 얼마나 맞출수 없는가에 대한 범위를 나타낸다.</li></ul><h2 id="전체분산의-법칙">전체분산의 법칙</h2><ul><li>확률변수의 분산 = 조건부분산의 기대값 + 조건부기대값의 분산</li></ul><p><span class="math display">\[Var[Y] = E[Var[Y|X]] + Var[E[Y|X]]\]</span></p><ul><li><span class="math inline">\(E[Y|X] = \hat y\)</span>로 표현하면</li></ul><p><span class="math display">\[Var[Y] = E[(\hat y - y)^2] + Var[\hat y]\]</span></p><ul><li>예측문제의 관점에서 조건부분산의 기댓값 <span class="math inline">\(E[(\hat y - y)^2]\)</span> 은 <strong>예측 오차</strong> 즉, 편향(bias)의 평균적인 크기를 뜻한다.</li><li>조건부기댓값의 분산 <span class="math inline">\(Var[\hat y]\)</span> 은 <strong>예측값의 변동 크기</strong>다.</li><li>예측값의 변동 크기가 증가한다는 것(분산이 커진다는 것은)은 예측모형이 복잡하고 비선형적이며 주어진 데이터에 과최적화되기 쉽다는 의미다.</li><li>예측 오차의 크기과 예측값의 변동의 합이 일정하므로 예측 오차를 줄이면 모형이 복잡해지고 과최적화가 되며 반대로 모형을 과최적화를 막기위해 단순하게 하면 예측 오차가 증가한다. 이를 <strong>편향-분산 상충(Bias–variance Tradeoff) 법칙</strong>이라고도 한다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>공분산과 상관계수란?</title>
      <link href="/2020/02/07/TIL-mathematics-2020-02-07-probability-md/"/>
      <url>/2020/02/07/TIL-mathematics-2020-02-07-probability-md/</url>
      
        <content type="html"><![CDATA[<h2 id="표본공분산">표본공분산</h2><p><span class="math display">\[S_{xy} = {1 \over N} \sum_{i=1}^{N}(x_i - \bar x)(y_i - \bar y)\]</span></p><ul><li>표본분산과 마찬가지로 표본공분산도 데이터가 평균값으로 부터 얼마나 떨어져 있는지에 대한 크기와 방향성을 같이 보여준다.</li><li>데이터가 1사분면이나 3사분면에 있는 경우에는 표본공분산은 양수가, 데이터가 2사분면이나 4사분면에 있는 경우에는 음수가 된다.</li><li>표본공분산의 부호는 <span class="math inline">\(X,Y\)</span> 데이터가 같은 부호를 가지는지 다른 부호를 가지는지에 대한 지표</li></ul><h2 id="표본상관계수">표본상관계수</h2><ul><li><p>분포의 크기는 공분산이 아닌 분산만으로도 알수있다. 따라서, 자료 분포의 방향성만 분리해서 보고자 할때는 <strong>상관계수</strong>를 사용한다.</p></li><li><p>공분산을 각각의 표본표준편차 값으로 나누어 정규화 한다(피어슨 상관계수)</p></li></ul><p><span class="math display">\[r_{xy} = {S_{xy} \over \sqrt{s^2_x s^2_y}}\]</span></p><ul><li>스피어만 상관계수 : 데이터들의 분위수(백분위 등)를 이용해 1등부터 줄을 세워서 상관관계를 비교함</li></ul><h3 id="확률변수의-공분산과-상관계수">확률변수의 공분산과 상관계수</h3><ul><li>두 <strong>확률변수</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>의 공분산</li></ul><p><span class="math display">\[Cov[X,Y] = E[(X - E[X](Y - E[Y]))]\]</span></p><ul><li>두 <strong>확률변수</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>의 상관계수도 다음과 같이 정의한다.</li></ul><p><span class="math display">\[\rho[X,Y] = {Cov[X,Y] \over \sqrt{Var[X]Var[Y]}}\]</span></p><ul><li>상관계수 : <span class="math inline">\(-1 \leq \rho \leq 1\)</span> 이고<ul><li><span class="math inline">\(\rho = 1\)</span> : 완전선형 상관관계</li><li><span class="math inline">\(\rho = 0\)</span> : 무상관(독립과는 다른)</li><li><span class="math inline">\(\rho = 1\)</span> : 완전선형 반상관관계</li></ul></li></ul><blockquote><h3 id="공분산-자료가-평균으로-부터-얼마나-멀리-떨어져-있는지-방향성과-크기-모두를-나타냄">공분산 : 자료가 평균으로 부터 얼마나 멀리 떨어져 있는지, 방향성과 크기 모두를 나타냄</h3><h3 id="상관계수-방향성-만을-나타냄-좌상을-향할수록-1에-가깝고-우하를-향할수록--1에-가깝고-둥글게-퍼져있을수록-0에-가깝다">상관계수 : 방향성 만을 나타냄, 좌상을 향할수록 1에 가깝고, 우하를 향할수록 -1에 가깝고, 둥글게 퍼져있을수록 0에 가깝다</h3></blockquote><h2 id="비선형-상관관계">비선형 상관관계</h2><ul><li>두 확률변수가 상관관계가 있으면 두 확률변수의 값 중 하나를 알았을 때 다른 확률변수의 값에 대한 정보를 알 수 있다. 반드시 정확한 값을 알 수 있어야 하는 것은 아니다.</li><li>선형이 아닌 상관관계를 비선형 상관관계라고 한다. 피어슨 상관계수는 비선형관계를 가진 데이터들의 상관관계를 잘 표현하지 못함(엔스콤 데이터 예시)</li></ul><h2 id="다변수-확률변수의-표본공분산">다변수 확률변수의 표본공분산</h2><ul><li><p>스칼라가 아닌 벡터 표본값을 가지는 다변수 확률변수의 공분산을 생각해보자.</p></li><li><p><span class="math inline">\(M\)</span>개의 서로 다른 확률변수가 있다고 하면, 이 확률변수들의 표본 데이터가 각각 <span class="math inline">\(N\)</span>개 씩 있으면 <span class="math inline">\(j\)</span>번재 확률변수의 <span class="math inline">\(i\)</span>번째 데이터를 <span class="math inline">\(x_{j,i}\)</span>로 표기한다.</p></li></ul><p><span class="math display">\[X =\begin{bmatrix}     x_{1,1} &amp; x_{1,2} &amp; \dots &amp; x_{1,M} \\    x_{2,1} &amp; x_{2,2} &amp; \dots &amp; x_{2,M} \\    \dots &amp; \dots &amp; \ddots &amp; \dots \\    x_{N,1} &amp; x_{N,2} &amp; \dots &amp; x_{N,M}\end{bmatrix}\quad\]</span></p><ul><li><span class="math inline">\(M\)</span>개의 서로다른 확률변수의 모든 조합에 대해 공분산을 한꺼번에 표현하는 표본공분산행렬(Sample Covariance Matrix)는</li></ul><p><span class="math display">\[S =\begin{bmatrix}     S^2_{x_1} &amp; S_{x_1x_2} &amp; \dots &amp; S_{x_1x_M} \\    S_{x_1x_2} &amp; S^2_{x_2} &amp; \dots &amp; S_{x_1x_M} \\    \dots &amp; \dots &amp; \ddots &amp; \dots \\    S_{x_1x_M} &amp; S_{x_2x_M} &amp; \dots &amp; S^2_{x_M}\end{bmatrix}\quad\]</span></p><ul><li><p>표본공분산행렬 <span class="math inline">\(S\)</span>를 구하는 방법은</p><ul><li><ol type="1"><li>각 확률변수의 표본평균을 계산한다. <span class="math display">\[\bar x_j = {1 \over N}\sum_{i=1}^{N}x_{i,j}\]</span></li></ol></li><li><ol start="2" type="1"><li>각 확률변수의 분산을 계산한다. <span class="math display">\[s^2_j = {1 \over N}\sum_{i=1}^{N}(x_{i,j} - \bar x)^2\]</span></li></ol></li><li><ol start="3" type="1"><li>두 확률변수의 공분산을 계산한다. <span class="math display">\[s_{j,k} = {1 \over N}\sum_{i=1}^{N}(x_{i,j} - \bar x_j)(x_{i,k} - \bar x_k)\]</span></li></ol></li></ul></li><li><p>최종적으로 표본공분산 행렬 <span class="math inline">\(S\)</span>는 <span class="math display">\[S = {1 \over N}\sum_{i=1}^{N}(x_i - \bar x)(x_i - \bar x)^T\]</span></p></li></ul><h2 id="다변수-확률변수의-공분산">다변수 확률변수의 공분산</h2><ul><li><span class="math inline">\(M\)</span>개의 다변수 확률변수 벡터의 <strong>이론적 공분산행렬</strong>은 <span class="math inline">\(\Sigma\)</span>로 표기하고</li></ul><p><span class="math display">\[\Sigma = E[(X - E[X])(X - E[X])^T]= E\begin{bmatrix} \begin{bmatrix}     X_1 - E[X_1]\\    X_2 - E[X_2]\\    \dots \\    X_M - E[X_M] \end{bmatrix} &amp;[X_1 - E[X_1] &amp; X_2- E[X_2] &amp; \dots &amp; X_M - E[X_M]]\end{bmatrix}\]</span></p><h2 id="조건부-기대값">조건부 기대값</h2><ul><li>조건이 되는 확률변수 X에 따라 값이 달라지는 &quot;확률변수&quot;</li><li>결정론적 함수값</li></ul><h1 id="예측문제">예측문제</h1><ul><li>X의 값을 알고 있을떄 Y를 알아내는 것</li><li>분류 : Y가 이산확률변수일때, 입력이 주어져서 카테고리값이 나온다(0,1, 맞거나 틀리거나)</li><li>회기분석 : Y가 연속확률변수일때, 실수값이 나온다.</li></ul><h2 id="조건부-분산">조건부 분산</h2><h2 id="전체분산의-법칙">전체분산의 법칙</h2><ul><li>편향-분산상충법칙</li><li>Var[Y] = E[(yhat-y)**2] + Var[yhat]</li><li>고정된 값이기 때문에, = 예측오차 상승 + 예측모델의 복잡도 하락</li><li>고정된 값이기 때문에, = 예측오차 하락 + 예측모델의 복잡도 상승</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>다변수 확률변수란?</title>
      <link href="/2020/02/07/TIL-mathematics-2020-03-03-probability/"/>
      <url>/2020/02/07/TIL-mathematics-2020-03-03-probability/</url>
      
        <content type="html"><![CDATA[<h2 id="이산확률변수-에서-다변수-확률변수">이산확률변수 에서 다변수 확률변수</h2><ul><li><h3 id="결합확률질량함수"><strong>결합확률질량함수</strong></h3><span class="math display">\[P_{XY}(x,y)\]</span><ul><li>결합확률 질량함수에서는 독립변수가 𝑥,𝑦 두 개가 된다. 종속변수는 그 숫자 쌍이 나타날 확률이다.</li><li><span class="math inline">\(P_{XY}(2,3)\)</span> 은 <span class="math inline">\({𝑥=2,𝑦=3}\)</span> 이라는 특정한 숫자 쌍으로만 이루어진 사건의 확률이다. 만약 공정한 주사위 두 개를 던지는 경우라면 결합확률질량함수는 <span class="math inline">\(1\over 36\)</span>이다.</li></ul></li><li><h3 id="주변확률질량함수"><strong>주변확률질량함수</strong></h3><ul><li>주변확률질량함수(marginal probability mass function)는 두 확률변수 중 하나의 확률변수 값에 대해서만 확률분포를 표시한 함수</li></ul></li><li><h3 id="조건부확률질량함수"><strong>조건부확률질량함수</strong></h3><ul><li>조건부확률질량함수(conditional probability mass function)는 다변수 확률변수 중 하나의 값이 특정 값으로 고정되어 상수가 되어 버린 경우, 나머지 변수에 대한 확률질량함수를 말한다. <span class="math display">\[P_{X|Y}(x|y) = {P_{XY}(x,y) \over P_X(y)}\]</span></li></ul><p><span class="math display">\[P_{Y|X}(y|x) = {P_{XY}(x,y) \over P_X(x)}\]</span></p><ul><li>조건부확률질량함수의 모양은 결합질량함수 <span class="math inline">\(P_{XY}(x,y)\)</span>에서 <span class="math inline">\(y\)</span>값이 고정된 함수, 즉, 결합질량함수의 단면과 같아진다. 조건부확률질량함수의 합은 1이 된다.</li></ul></li></ul><h2 id="연속확률변수-에서-다변수-확률변수">연속확률변수 에서 다변수 확률변수</h2><p>연속확률분포에서는 이산확률분포와 같이 단순사건을 이용하여 확률을 정의할 수 없으므로 단변수 연속확률변수처럼 누적확률분포함수(cdf)를 먼저 정의한 후 이를 미분하여 확률밀도함수(pdf)를 정의하는 방법을 사용한다.</p><ul><li><h3 id="결합누적확률분포함수">결합누적확률분포함수</h3><ul><li>두 연속 확률변수 <span class="math inline">\(X,Y\)</span>에 대한 결합누적확률분포함수는</li></ul><p><span class="math display">\[F_{XY}(x,y) = P({X &lt; x} \cap {Y &lt; y}) = P({X &lt; x, Y &lt; y})\]</span></p><ul><li>결합누적확률분포함수의 특성</li></ul><p><span class="math display">\[F_{XY}(\infty,\infty) = 1\]</span></p><p><span class="math display">\[F_{XY}(-\infty,y) = F_{XY}(x,-\infty) = 0\]</span></p><ul><li><h3 id="결합확률밀도함수">결합확률밀도함수</h3><ul><li>단변수 확률변수의 경우처럼 결합누적확률분포함수를 미분하여 결합확률밀도함수(joint probability density function)를 정의할 수 있다.</li><li>독립 변수가 2개이므로 각각 <span class="math inline">\(x,y\)</span>에 대해모두 편미분(partial differentication)해야 한다.</li></ul><p><span class="math display">\[P_{XY} = {\partial^2F_{XY}(x,y) \over \partial x \partial y} \]</span></p><ul><li>결합확률밀도함수를 특정 구간에 대해 적분하면 해당 구간에 대한 확률이 된다.</li></ul><span class="math display">\[ \int_{x_1}^{x_2}  \int_{y_1}^{y_2} P_{XY}(x,y)dxdy = P(\{x_1 \leq X \leq x_2,y_1 \leq Y \leq y_2\})\]</span><ul><li>결합확률밀도함수를 모든 변수에 대해 적분하면 1이된다.</li></ul><p><span class="math display">\[\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} P_{XY}(x,y)dxdy = 1\]</span></p></li><li><h3 id="주변확률밀도함수">주변확률밀도함수</h3><ul><li><p>주변확률밀도함수(marginal probability density function)는 결합확률밀도함수를 특정한 하나의 변수에 대해 가중평균한 값을 말한다. 따라서 결합확률밀도함수를 하나의 확률변수에 대해서만 적분하여 구한다.</p></li><li><p>그래프를 밀가루 반죽이라고 생각하고 <span class="math inline">\(x\)</span> 혹은 <span class="math inline">\(y\)</span> 방향으로 밀어서 눌렀다고 생각</p></li></ul><p><span class="math display">\[P_X(x) = \int_{-\infty}^{\infty} P_{XY}(x,y)dy\]</span></p><p><span class="math display">\[P_Y(y) = \int_{-\infty}^{\infty} P_{XY}(x,y)dx\]</span></p></li><li><h3 id="조건부확률밀도함수">조건부확률밀도함수</h3><ul><li><p>조건부확률밀도함수(conditional probability density function)는 다변수 확률변수 중 하나의 값이 특정 값이라는 사실이 알려진 경우, 이러한 조건(가정)에 의해 변화한 나머지 확률변수에 대한 확률밀도함수를 말한다.</p></li><li><p>그래프를 밀가루 반죽이라고 생각하고 <span class="math inline">\(x\)</span>또는 <span class="math inline">\(y\)</span>값의 위치를 칼로 잘라낸 단면이라고 생각</p></li></ul><p><span class="math display">\[ P_{X|Y}(x|y) = {P_{XY}(x,y) \over P_y(y)}\]</span></p><p><span class="math display">\[ P_{Y|X}(y|x) = {P_{XY}(x,y) \over P_X(x)}\]</span></p><ul><li>조건부확률밀도함수에서 조건이 되는 확률변수의 값은 특정한 값으로 고정되어 있으므로 변수가 아니라 모수로 생각할 수 있다. 예를 들어 <span class="math inline">\(P_{X|Y}(x|y)\)</span> 에서 <span class="math inline">\(y\)</span> 의 값은 고정되어 있으므로 이 값은 <span class="math inline">\(x\)</span>의 함수가 된다.</li></ul></li></ul></li></ul><h2 id="독립과-상관관계">독립과 상관관계</h2><ul><li>확률변수 <span class="math inline">\(X\)</span>의 표본값이 달라져서 다른 확률변수<span class="math inline">\(Y\)</span>의 조건부 분포 모양이 달라질때 서로 상관관계라 한다.</li><li>두 확률변수가 상관 관계가 아니면 서로 독립(independent)이라고 한다.</li><li>두 확률변수 <span class="math inline">\(X,Y\)</span> 의 결합확률밀도함수(joint pdf)가 주변확률밀도함수(marginal pdf)의 곱과 같으면 서로 독립(independent)이다.</li></ul><p><span class="math display">\[P_{XY}(x,y) = P_X(x)P_Y(y)\]</span></p><ul><li>분리가능 다변수 함수 참고</li><li>이 법칙은 확률변수가 두개 이상이어도 성립된다.</li></ul><h2 id="반복시행">반복시행</h2><ul><li>같은 확률변수에서 복수의 표본 데이터를 취하는 경우에는 이 표본들은 서로 독립인 확률변수에서 나온 표본으로 볼수있다.</li><li>확률밀도 함수가 <span class="math inline">\(f(x)\)</span>이고 표본 데이터가 <span class="math inline">\(\{x_1,x_2,x_3,\dots,x_N \}\)</span>이면 이 데이터, 즉 벡터 <span class="math inline">\((x_1,x_2,x_3,\dots,x_N)\)</span>이 나올 확률은</li></ul><p><span class="math display">\[p(x_1,x_2,x_3,\dots,x_N)= \prod_{i=1}^N p(x_i)\]</span></p><h2 id="조건부-확률분포">조건부 확률분포</h2><ul><li>독립인 두 확률변수 <span class="math inline">\(X,Y\)</span>의 조건부확률밀도함수 = 주변확률밀도함수</li><li>서로 독립이면 영향을 주지 않기 때문에, &quot;조건부&quot;라는것이 성립자체가 안됨</li><li>pdf의 모양을 보고 독립여부를 판단할수 있어야 한다.<ul><li>pdf그래프의 밀가루 산을 어느 위치에서 칼로 잘라도(<span class="math inline">\(x\)</span>값을 변경해도)크기는 다르지만 스케일링 한후의 모양이 동일하다면, <span class="math inline">\(x\)</span>가 <span class="math inline">\(y\)</span>의 값에 영향을 주지않는다고 볼수있기 때문에, 독립이다.</li></ul></li></ul><p><span class="math display">\[P_{X|Y}(x|y) = {P_{XY}(x,y) \over P_Y(y)} = {P_X(x)P_Y(y) \over P_Y(y)} = P_X(x)\]</span></p><p><span class="math display">\[P_{Y|X}(y|x) = {P_{XY}(x,y) \over P_X(x)} = {P_X(x)P_Y(y) \over P_X(x)} = P_Y(y)\]</span></p><h3 id="독립-확률변수의-기대값-성질">독립 확률변수의 기대값 성질</h3><ul><li>앞장에서 다뤘던 독립인 두 확률변수의 기대값 성질을 되짚어 보면</li></ul><p><span class="math display">\[E[XY] = E[X]E[Y]\]</span></p><p><span class="math display">\[E[(X - \mu X)(Y - \mu Y)] = 0\]</span></p><h3 id="독립-확률변수의-분산">독립 확률변수의 분산</h3><ul><li>독립인 두 확률변수 <span class="math inline">\(X,Y\)</span>의 분산은</li></ul><p><span class="math display">\[Var[X + Y] = Var[X] + Var[Y]\]</span></p>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>분산과 표준편차란?</title>
      <link href="/2020/02/07/TIL-mathematics-2020-03-02-probability2/"/>
      <url>/2020/02/07/TIL-mathematics-2020-03-02-probability2/</url>
      
        <content type="html"><![CDATA[<h2 id="확률분포의-분산">확률분포의 분산</h2><ul><li>확률밀도함수 <span class="math inline">\(p(x)\)</span>의 수식을 알고 있다면 이론적인 분산을 구할수 있다.</li></ul><p><span class="math display">\[\sigma^2 = Var[X] = E[(X-\mu)^2]\]</span></p><h2 id="이산확률변수와-연속확률변수의-분산">이산확률변수와 연속확률변수의 분산</h2><ul><li>이산확률 변수의 분산은 평균으로부터 표본 데이터까지 거리의 제곱을 확률질량함수 <span class="math inline">\(p(x)\)</span>로 가중하여 더한 값이다.</li></ul><p><span class="math display">\[\sigma^2 = \sum_{x_i\in\Omega}(x_i - \mu)^2p(x_i)\]</span></p><ul><li>연속학률변수의 분산은 평균으로부터 표본 데이터까지 거리의 제곱을 확률밀도함수 <span class="math inline">\(p(x)\)</span>로 가중하여 적분한 값이다.</li></ul><p><span class="math display">\[\sigma^2 = \int_{-\infty}^{\infty}(x-\mu)^2p(x)dx\]</span></p><h2 id="분산의-성질">분산의 성질</h2><ul><li>분산은 항상 0또는 양수이다.</li></ul><p><span class="math display">\[Var[X] \geq 0\]</span></p><ul><li>확률변수가 아닌 상수값 C에 대해 다음식이 성립한다.</li></ul><p><span class="math display">\[Var[c] = 0\]</span></p><p><span class="math display">\[Var[cX] = c^2Var[X] \]</span></p><ul><li>기대값의 성질을 이용하면</li></ul><p><span class="math display">\[Var[X] = E[X^2] - (E[X])^2 = E[X^2] - \mu^2\]</span></p><h2 id="두-확률변수의-합의-분산">두 확률변수의 합의 분산</h2><ul><li>두 확률변수 <span class="math inline">\(X,Y\)</span>의 합의 분산은 다음과 같다.</li></ul><p><span class="math display">\[Var[X+Y] = Var[X] + Var[Y] + 2E[(X -\mu x)(Y - \mu y)]\]</span></p><h2 id="확률변수의-독립">확률변수의 독립</h2><ul><li>두 확률변수가 독립이면 두 확률변수가 가질수 있는 모든 사건의 조합에 대해 결합사건의 확률이 각 사건의 확률을 곱한것과 같다는 뜻이다.</li><li>다시말해, 두사건이 서로 영향을 미치지 않는다는 것이다.</li><li>두 확률변수가 독립이면</li></ul><p><span class="math display">\[E[(X-\mu x)(Y - \mu y)] = 0\]</span> 이고</p><p><span class="math display">\[Var[X+Y] = Var[X] + Var[Y] \]</span> 이다</p><h2 id="표본평균의-분산">표본평균의 분산</h2><ul><li>확률변수 <span class="math inline">\(X\)</span>의 표본평균 <span class="math inline">\(\bar X\)</span>도 확률변수이고 그 기대값 은 워래 확률변수 <span class="math inline">\(X\)</span>의 기대값과 같다.</li></ul><p><span class="math display">\[E[\bar X] = E[X]\]</span></p><ul><li>하지만 표본평균 <span class="math inline">\(\bar X\)</span>의 분산 <span class="math inline">\(Var[\bar X]\)</span>는 원래 확률변수 <span class="math inline">\(X\)</span>의 분산 <span class="math inline">\(Var[X]\)</span>와 다음 관계를 가진다.</li></ul><p><span class="math display">\[Var[\bar X] = {1\over N}Var[X]\]</span></p><ul><li>확률변수 <span class="math inline">\(X\)</span>의 기대값 <span class="math inline">\(E[X]\)</span>의 값을 구하기위해, 기대값의 성질을 이용해 <span class="math inline">\(E[\bar X]\)</span>의 값을 구하고, 이 값은 확률변수 <span class="math inline">\(X\)</span>의 기대값과 비슷한 값이 나온다.(다만 정확하진 않음)</li><li>위의 식을 볼때, 표본개수 <span class="math inline">\(N\)</span>이 많아지면 표본평균 <span class="math inline">\(\bar x\)</span>의 분산이 아주 작아져 갈수록 기대값 근처의 거의 일정한 값이 나온다.</li><li>따라서, <strong>표본의 개수 <span class="math inline">\(N\)</span>개가 크면 표본평균 <span class="math inline">\(\bar x\)</span>은 원래 확률변수 <span class="math inline">\(X\)</span>의 기대값 <span class="math inline">\(E[X]\)</span>의 근사값이라고 할수 있다</strong></li></ul><h2 id="표본분산의-기대값">표본분산의 기대값</h2><ul><li>표본분산 <span class="math inline">\(S^2\)</span>의 기대값을 구하면 이론적인 분산 <span class="math inline">\(\sigma^2\)</span>과 같아지는 것이 아닌, 이론적인 분산값의 <span class="math inline">\(N -1 \over N\)</span>배가 된다.</li><li>표본분산값 &lt; 이론적인 분산값</li></ul><p><span class="math display">\[E[S^2] = {N -1 \over N} \sigma^2 \]</span></p><ul><li>기대값이 정확한 분산값과 일치하는 비편향 표본분산은</li></ul><p><span class="math display">\[S^2_{unbiased} \equiv {1 \over N-1} \sum (X_i - \bar X)^2\]</span></p><ul><li>표본분산을 계산할 때 사용하는 표본평균의 값이 데이터가 많이 몰려있는 쪽으로 편향되게 나온다. 또한, 데이터가 몰려있는 위치에 있는 표본평균을 기준으로 각 데이터까지의 거리를 계산하면 원래의 기댓값으로부터의 거리보다 작게 나올 수 있다.</li></ul><h2 id="비대칭도와-첨도">비대칭도와 첨도</h2><ul><li>비대칭도 : 3차 모멘트 값에서 계산하고, 비대칭 정도를 나타낸다. 비대칭도가 0이면 확률분포가 대칭이다.</li><li>첨도 : 4차 모멭느 값에서 계산하고, 확률이 정규분포 대비 얼마나 중심에 모여있는지를 나타낸다.</li></ul><h2 id="모멘트">모멘트</h2><ul><li>기대값(평균)이나 분산, 비대칭도, 첨도등은 확률분포의 모멘트중 하나이다.</li><li>만약 두 확률분포 <span class="math inline">\(X,Y\)</span>의 1차부터 무한대차수에 이르는 모멘트 값이 모두 동일하다면, 두 확률분포는 같은 확률분포이다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>기대값과 확률변수의 변환</title>
      <link href="/2020/02/07/TIL-mathematics-2020-03-02-probability/"/>
      <url>/2020/02/07/TIL-mathematics-2020-03-02-probability/</url>
      
        <content type="html"><![CDATA[<h3 id="확률변수의-기대값">확률변수의 기대값</h3><ul><li><p>확률변수의 확률밀도함수를 알면 확률변수의 이론적 평균값을 구할수 있다. 이런 이론적 평균을 확률변수의 <strong>기대값</strong>이라 한다.</p></li><li><p>이산확률변수의 기대값은</p></li></ul><p><span class="math display">\[\mu x = E[X] = \sum_{x_i \in \Omega} x_ip(x_i)\]</span> 확률질량함수 <span class="math inline">\(p(x_i)\)</span>에 주의!</p><ul><li><p>연속확률변수의 기대값은 <span class="math display">\[\mu x = E[X] = \int_{-\infty}^{\infty}xp(x)dx\]</span></p></li><li><p>기대값은 여러 가능한 x의 값을 확률(또는 확률밀도)값에 따라 가중합을 한것이므로, 가장 확률이 높은 x값 근처의 값이 된다. 다시말해, 확률(또는 확률밀도)가 모여있는 곳의 위치를 나타낸다.</p></li></ul><h2 id="기대값의-성질">기대값의 성질</h2><ul><li><p>확률변수가 아닌 상수 <span class="math inline">\(c\)</span>에 대해 <span class="math display">\[E[c] = c\]</span></p></li><li><p>선형성 <span class="math display">\[E[cX] = cE[X]\]</span> <span class="math display">\[E[X + Y] = E[X] + E[Y]\]</span> <span class="math display">\[E[c_1X + c_2Y] = c_1E[X] + c_2E[Y]\]</span></p></li></ul><h2 id="확률변수의-변환">확률변수의 변환</h2><p><span class="math display">\[ Y = f(X)\]</span></p><ul><li>확률변수를 사용하여 새로운 확률변수를 만드는것을 확률변수의 변환이라 한다.</li></ul><h2 id="통계량">통계량</h2><ul><li>확률변수 <span class="math inline">\(X\)</span>로 부터 얻은 데이터집합의 모든 값을 정해진 어떤 공식에 넣어서 하나의 숫자를 구한것을 통계량이라고 한다.</li><li>표본의합, 표본평균, 표본중앙값, 표본분산등은 모두 통계량이다.</li><li>통계량도 확률변수의 변환에 포함된다.</li></ul><h2 id="표본평균-확률변수">표본평균 확률변수</h2><ul><li>확률변수로 부터 <span class="math inline">\(N\)</span>개의 확률변수 복사본을 만들어 각 확률변수가 만들어낸 표본집합의 표본평균을 구하면 이 값도 확률변수가 된다.</li><li>표본평균 확률변수는 원래의 확률변수 이름에 윗줄을 추가하여 <span class="math inline">\(\bar X\)</span>로 표시한다</li></ul><p><span class="math display">\[\bar X = {1 \over N} \sum_{i=1}^N X_i\]</span></p><h2 id="기대값과-표본평균의-관계">기대값과 표본평균의 관계</h2><ul><li>표본평균도 확률변수이므로 기대값이 존재하고, 아래와 같은 관계가 성립한다.</li></ul><p><span class="math display">\[E[\bar X] = E[X]\]</span></p><ul><li>이 식의 의미는 &gt; <strong>표본평균은 확률변수의 기대값 근처의 값이 된다.</strong><ul><li>예를들어 공정한 주사위의 기대값은 3.5이다. 이 주사위를 던져 나온 값의 평균, 즉 표본평균은 3.623456 또는 3.405985등 처럼 항상 3.5근처의 값이 나온다.</li></ul></li></ul><h2 id="중앙값">중앙값</h2><ul><li>확률변수의 중앙값은 중앙값보다 큰 값이 나올 확률과 작은 값이 나올 확률이 0.5로 같은 값을 뜻한다.</li></ul><h2 id="최빈값">최빈값</h2><ul><li>이산확률분포에서는 가장 확률값이 큰 수를 최빈값이라고 한다.</li><li>연속확률분포의 최빈값은 확률밀도함수 <span class="math inline">\(p(x)\)</span>의 값이 가장큰 확률변수의 값이다.</li><li>최빈값 = $  p(x)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>클래스</title>
      <link href="/2020/02/06/python-2020-02-06-python-class-md/"/>
      <url>/2020/02/06/python-2020-02-06-python-class-md/</url>
      
        <content type="html"><![CDATA[<h1 id="클래스">클래스</h1><p>변수와 함수를 묶어 놓은 개념입니다. <a id="more"></a></p><blockquote><p><strong>사용방법</strong> 1. 변수와 함수가 들어있는 클래스를 선언합니다. 2. 클래스를 객체로 만들어서 클래스 안에 선언된 변수와 함수를 사용합니다.</p></blockquote><h2 id="기본-클래스의-사용">기본 클래스의 사용</h2><blockquote><p>클래스의 선언 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 클래스에서 사용되는 함수의 첫번째 파라미터는 self를 쓴다</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line">     </span><br><span class="line">    num1 = <span class="number">1</span></span><br><span class="line">    num2 = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 + self.num2</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 - self.num2</span><br></pre></td></tr></table></figure> 클래스의 사용 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc = Calculator()</span><br><span class="line">calc</span><br><span class="line"><span class="comment"># 위의 클래스의 선언에서 self는 함수가 포함된 객체 여기서는 calc</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calc.num1, calc.num2, calc.plus(), calc.minus()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1, 2, 3, -1</span></span><br><span class="line"><span class="comment"># 객체로 만들어 클래서에서 선언한 함수를 가져다 쓴다.</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="객체지향">객체지향</h2><p>실제 세계를 코드에 반영해서 개발하는 방법입니다. - 여러명의 개발자가 코드를 효율적으로 작성해서 프로젝트를 완성시키기 위한 방법 - 설계도 작성(class) -&gt; 실제 물건(object) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="string">"python"</span> </span><br><span class="line"><span class="comment">#문자열 데이터 타입을 가지는 '객체' (기본 데이터 타입)</span></span><br><span class="line">obj.upper()</span><br></pre></td></tr></table></figure></p><h2 id="생성자">생성자</h2><p>클래스가 객체로 생성될때 실행되는 함수이며, 변수(재료)를 추가할때 사용합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 생성자 함수 : __init__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num1,num2=<span class="number">10</span>)</span>:</span> <span class="comment">#키워드 아규먼트, 디폴트파라미터 사용가능 </span></span><br><span class="line">        self.num1 = num1</span><br><span class="line">        self.num2 = num2</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 + self.num2</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 - self.num2</span><br><span class="line"></span><br><span class="line">calc = Calculator(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">calc.plus()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure></p><h2 id="상속">상속</h2><p>클래스의 기능을 가져다가 기능을 수정하거나 추가할때 사용하는 방법 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator1</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num1,num2)</span>:</span></span><br><span class="line">        self.num1 = num1</span><br><span class="line">        self.num2 = num2</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 + self.num2</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 - self.num2</span><br><span class="line"></span><br><span class="line">calc1 = Calculator1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">calc1.plus(), calc1.minus()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3,-1</span></span><br></pre></td></tr></table></figure> &gt; 매서드 오버라이딩 : 부모 클래스에서 상속받은 매서드를 수정 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 상속을 사용하여 minus 함수 추가</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator2</span><span class="params">(Calculator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num1 * self.num2</span><br><span class="line"></span><br><span class="line">calc2 = Calculator2(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">calc2.plus(),calc2.minus()     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3, 2</span></span><br></pre></td></tr></table></figure> Calcultor1이 가지고 있는 plus매서드를 그대로 상속받았고, minus매서드는 오버라이딩을 통해 곱해주는 기능으로 바꿨습니다.</p><h2 id="다중-상속">다중 상속</h2><p>여러개의 클래스를 상속받을수 있습니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iphone1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calling</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Calling"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iphone2</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"SendMsg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iphone3</span><span class="params">(Iphone1,Iphone2)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">internet</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Internet"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iphone = Iphone3()</span><br><span class="line">iphone3.calling(),iphone3.send_msg(),iphone3.internet()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling, SendMsg, Internet</span></span><br></pre></td></tr></table></figure></p><h2 id="super">Super</h2><p>부모 클래스에서 사용된 함수의 안의 코드를 가져다가 자식 클래스의 함수에서 재사용할때 사용합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iphone4</span><span class="params">(Iphone3)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">question</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().calling()</span><br><span class="line"></span><br><span class="line">iphone4 = Iphone4()</span><br><span class="line">iphone4.question()</span><br><span class="line"></span><br><span class="line"><span class="comment"># calling</span></span><br></pre></td></tr></table></figure> 상속받은 부모클래스의 calling 매서드의 코드를 가져왔습니다.</p><h2 id="class의-getter-setter">class의 getter, setter</h2><p>객체의 내부 변수에 접근할때 특정 로직(제약 조건)을 거쳐서 접근시키는 방법입니다. &gt; property(geeter,setter)로 제약을 줍니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,first_name)</span>:</span></span><br><span class="line">        self.first_name = first_name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self,first_name)</span>:</span></span><br><span class="line">        print(<span class="string">"Setter"</span>)</span><br><span class="line">        self.first_name = first_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Getter"</span>)</span><br><span class="line">        <span class="keyword">return</span> self.first_name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disp</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.first_name)</span><br><span class="line">        </span><br><span class="line">    name = property(getter,setter)</span><br><span class="line"></span><br><span class="line">user1 = User(<span class="string">"andy"</span>)</span><br><span class="line">user1.disp()</span><br><span class="line"></span><br><span class="line"><span class="comment"># andy</span></span><br><span class="line"></span><br><span class="line">user1.name = <span class="string">"john"</span></span><br><span class="line"><span class="comment"># Setter</span></span><br><span class="line">user1.name</span><br><span class="line"><span class="comment"># Getter</span></span><br><span class="line"><span class="comment"># 'john'</span></span><br></pre></td></tr></table></figure></p><h2 id="non-public">non public</h2><p>'mangling' 이라는 방식으로 다이렉트로 객체의 변수와 매서드에 접근하지 못하게 하는 방법입니다. 변수 앞에 __붙이는 방식으로 구현합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num1,num2)</span>:</span></span><br><span class="line">        self.num1 = num1</span><br><span class="line">        self.__num2 = num2 </span><br><span class="line">        <span class="comment">#실제로는 객체가 선언 될떄는 self._Caculator__num2라는 이름으로 바뀜</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__num2</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self,__num2)</span>:</span></span><br><span class="line">        <span class="comment"># num2에 0이 들어가지 않도록 함</span></span><br><span class="line">        <span class="keyword">if</span> num2 == <span class="number">0</span>:</span><br><span class="line">             num2 = <span class="number">1</span></span><br><span class="line">        self.__num2 = num2</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__disp</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.num1,self.__num2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__disp()</span><br><span class="line">        <span class="keyword">return</span> self.num1 / self.__num2</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    number2 = property(getter,setter)</span><br></pre></td></tr></table></figure> &gt; 매서드 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">calc = Calculator(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">calc.div()</span><br><span class="line"></span><br><span class="line"><span class="comment"># div()매서드에서 __disp()라는 mangling 방식으로 처리된 매서드를 실행해서 1 2 라는 출력이 나오고, div가 리턴하는 0.5라는 값도 함께 나옴</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br><span class="line"><span class="comment"># 0.5</span></span><br><span class="line"></span><br><span class="line">calc.__disp()</span><br><span class="line"><span class="comment"># 실행안됨. </span></span><br><span class="line"></span><br><span class="line">calc._Calculator__disp()</span><br><span class="line"><span class="comment"># 위의 이름으로 실행할수 있음.</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure> &gt; 변수 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calc.num2 = <span class="number">0</span> </span><br><span class="line"><span class="comment">#위에 클래스에서는 num2라는 이름의 변수는 없음, 대신 새로 만들어 지게 됨</span></span><br><span class="line">calc.__num2 = <span class="number">0</span> </span><br><span class="line"><span class="comment"># 역시 __num2 라는  새로운 변수를 생성</span></span><br><span class="line">calc._Calculator__num2 </span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 클래스 안의 __num2와 같음</span></span><br></pre></td></tr></table></figure> ## is a 와 has a 클래스를 설계하는 두가지 개념 입니다. &gt; <strong>A is a B</strong> &gt;&gt; A는 B이다. 상속을 이용해서 클래스를 만드는 방법 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># is a 개념으로 설계</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,email)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name,self.email)</span><br><span class="line"></span><br><span class="line">p = Person2(<span class="string">"andy"</span>,<span class="string">"andy@gmail.com"</span>)</span><br><span class="line"></span><br><span class="line">p.info()</span><br><span class="line"><span class="comment"># andy andy@gmail.com</span></span><br></pre></td></tr></table></figure> &gt; <strong>A has a B</strong> &gt;&gt; A는 B를 가진다. A가 B객체를 가지고 클래스를 만드는 방법 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># has a 개념으로 설계 : 객체안에 객체를 가지고 있다</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name_str = name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,email)</span>:</span></span><br><span class="line">        self.email_str = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name_obj,email_obj)</span>:</span></span><br><span class="line">        self.name = name_obj</span><br><span class="line">        self.email = email_obj</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(name.name_str,email.email_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = Name(<span class="string">"andy"</span>)</span><br><span class="line">email = Email(<span class="string">"andy@gmail.com"</span>)</span><br><span class="line"><span class="comment">#객체 안에 객체를 가지고 있다</span></span><br><span class="line">p = Person(email,name)</span><br><span class="line"></span><br><span class="line">p.info()</span><br><span class="line"><span class="comment"># andy andy@gmail.com</span></span><br></pre></td></tr></table></figure></p><h2 id="magicspecial-method">Magic(Special) Method</h2><p>비교연산자 - <code>__eq__</code> : == - <code>__ne__</code> : != - <code>__lt__</code> : &lt;</p><p>산술연산자 - <code>__add__</code> : + - <code>__sub__</code> : - - <code>__repr__</code>: 객체의 내용을 출력(개발자용) - <code>__str__</code> : 객체의 내용을 출력</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Txt</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,txt)</span>:</span></span><br><span class="line">        self.txt = txt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self,txt_obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.txt.lower() == txt_obj.txt.lower()</span><br><span class="line">        <span class="comment"># 소문자로 변환해서 비교 언산자를 실행합니다.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Txt(txt=&#123;&#125;)"</span>.format(self)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Txt(<span class="string">"python"</span>)</span><br><span class="line">t2 = Txt(<span class="string">"PYTHON"</span>)</span><br><span class="line">t3 = t1</span><br><span class="line"></span><br><span class="line">t1 == t2, t1 == t3, t2 == t3</span><br><span class="line"><span class="comment"># __eq__ 실행</span></span><br><span class="line"><span class="comment"># (True, True, True)</span></span><br><span class="line"></span><br><span class="line">t1</span><br><span class="line"><span class="comment"># __repr__  실행</span></span><br><span class="line"><span class="comment"># Txt(txt=python)</span></span><br><span class="line"></span><br><span class="line">print(t1)</span><br><span class="line"><span class="comment"># python</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Class </tag>
            
            <tag> 객체 지향 </tag>
            
            <tag> 생성자 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>확률적 데이터와 확률변수란?</title>
      <link href="/2020/02/06/TIL-mathematics-2020-02-06-probability-md/"/>
      <url>/2020/02/06/TIL-mathematics-2020-02-06-probability-md/</url>
      
        <content type="html"><![CDATA[<h2 id="결정론적-데이터">결정론적 데이터</h2><ul><li>이미 결정되어 바뀌지 않는 데이터(성별 등) <a id="more"></a></li></ul><h2 id="확률적-데이터">확률적 데이터</h2><ul><li>여러 조건, 상황에 따라 데이터값이 영향을 받거나, 측정시 오차가 생길수 있는 데이터</li></ul><h2 id="분포distribution">분포(distribution)</h2><ul><li>어떤값이 자주 등장, 혹은 드물게 등장하는지를 나타낸 것</li><li>카운트 플롯(번주형 데이터)과 히스토그램(실수형 데이터)으로 표현</li></ul><h2 id="기술통계descriptive-stastics">기술통계(descriptive stastics)</h2><ul><li>표본평균, 표본중앙값, 표본최빈값</li><li>표본분산, 표본표준편차</li><li>표본비대칭도, 표본첨도</li></ul><h2 id="표본평균">표본평균</h2><p align="center"><span class="math display">\[ m = {1 \over N} \sum_{i=1}^N x_i\]</span></p><h2 id="표본중앙값sample-median">표본중앙값(sample median)</h2><ul><li>자료를 크기별로 정렬해서 가장 중앙에 위치하는 값</li><li>표본의 개수가 <span class="math inline">\(N\)</span>인 경우, <span class="math inline">\(N\)</span>이 홀수이면 중앙값은 <span class="math inline">\((N+1)/2\)</span>번재 표본의 값, 짝수이면 <span class="math inline">\(N/2\)</span>번째와 <span class="math inline">\(N/2 +1\)</span>번째 표본값의 평균</li></ul><h2 id="표본최빈값sample-mode">표본최빈값(sample mode)</h2><ul><li>가장 빈번하게 나오는 값</li></ul><h2 id="단봉-분포uni-modal-다봉분포multi-nodal">단봉 분포(uni modal), 다봉분포(multi nodal)</h2><ul><li>분포의 모양에서 봉우리가 하나면 단봉, 여러개면 다봉분포라 한다.</li></ul><h2 id="대칭-분포">대칭 분포</h2><ul><li>표본평균을 기준으로 대칭인 대칭분포이면, <strong>표본중앙값 = 표본평균</strong></li><li>대칭분포이면서 하나의 최고값을 가지는 단봉분포이면, <strong>표본최빈값 = 표본평균</strong></li><li>대칭분포를 비대칭으로 만드는 데이터가 더해지면(outlier) <strong>표본평균 &gt; 중앙값 &gt; 최빈값</strong> 순으로 영향을 받는다.</li></ul><h2 id="분산variance과-표준편차standard-deviation">분산(variance)과 표준편차(standard deviation)</h2><ul><li>데이터가 얼마나 변동하고 있는지 알려주는 특징값을 <strong>표본분산</strong> 또는 <strong>표본표준편차</strong>라고 한다.</li><li>평균, 기대값이 분포의 위치를 대표하는 것이라면, 분산은 분포의 폭을 대표하는 값이다.</li><li><p><strong>표준편차 = 분산의 양의 제곱근</strong></p></li><li><strong>편향 표본분산</strong> : 데이터와 평균 사이의 거리의 제곱의 평균<p align="center"><span class="math display">\[s^2 = {1 \over N} \sum_{i=1}^N(x_i - \bar x)^2\]</span></p></li><li><strong>비편향 표본분산</strong> : 데이터와 평균 사이의 거리의 제곱의 평균할떄 N-1로 나눔<p align="center"><span class="math display">\[s^2_{unbiased} = {1 \over N-1}\sum_{i=1}^N(x_i - \bar x)^2\]</span></p></li></ul><h2 id="표본-비대칭도sample-skewness">표본 비대칭도(sample skewness)</h2><ul><li>데이터와 평균 사이의 거리의 3제곱 이용</li><li>0이면 대칭, 음수이면 표본평균값 기준 왼쪽, 양수이면 오른쪽</li></ul><h2 id="표본첨도sample-kuerosis">표본첨도(sample kuerosis)</h2><ul><li>4제곱 이용</li><li>데이터가 중앙에 몰려있는 정도를 정밀하게 비교할때 사용. 사람눈으로 구분 힘듦</li></ul><h2 id="표본모멘트sample-momoent">표본모멘트(sample momoent)</h2><ul><li>k제곱을 이용함</li></ul><h1 id="확률변수">확률변수</h1><ul><li>수학적으로 확률공간의 표본을 입력으로 받아서 실수인 숫자를 출력하는 함수.</li><li>출력되는 실수가 데이터 값이다. <strong>데이터 생성기</strong>의 개념</li><li>대문자 <span class="math inline">\(X\)</span>등으로 표기한다</li><li>주사위를 던지는 시험, 혈압을 측정하는 실험처럼 같은 조건에서 여러번 반복하여 확률적 데이터를 얻을수 있다. 이 데이터들을 생성한 주사위, 사람등의 데이터 생성기가 존재한다.</li></ul><h2 id="실현-혹은-표본화">실현 혹은 표본화</h2><ul><li>현실 세계의 데이터는 확률변수의 확률분포에 따라 실수 표본공간에서 선택된 표본이다.</li><li>이렇게 선택되는 과정을 <strong>실현(realization)</strong> 혹은 <strong>표본화(sampling)</strong> 이라고 한다.</li><li>표본화는 이상적, 추상적, 수학적인 세계에서 현실로 넘어오는 과정이다.</li><li>현실세계로 넘어오는 과정(표본화)에서 생기는 잡음 때문에, 우리가 가지고 있는 현실의 데이터의 분포를 살폈을때, 완벽하고 꺠끗한 형태가 나오지 않지만, 데이터의 본질을 찾아 이상세계로 넘어가면 명확한 수학적 특성을 가진 확률변수가 존재한다.</li></ul><h2 id="확률변수와-실제-데이터의-관계">확률변수와 실제 데이터의 관계</h2><ul><li>확률변수로 부터 데이터를 여러번 생성하면 데이터 값은 매번 달라질수 있다. 하지만 확률변수는 변하지 않는다.</li><li>확률변수의 확률분포함수는 우리가 직접 관찰할수 없다. 다만 확률변수에서 만들어지는 데이터를 통해 확률변수의 확률분포함수를 <strong>추정</strong> 할 뿐이다.</li><li>확률변수에서 만들어진 실제 데이터는 확률변수의 특성이 반영되어 있다. 데이터 개수가 증가할수록 더욱 명확하게 확률 변수의 확률분포함수를 묘사할수 있게 된다.</li></ul><h2 id="역설계reverse-engineering">역설계(reverse engineering)</h2><ul><li>확률변수를 이용한 데이터 분석의 순서는<ul><li>데이터를 수집하고</li><li>수집한 데이터가 어떤 확률변수의 표본데이터라고 가정한다.</li><li><strong>데이터를 사용하여 해당 확률변수의 확률분포함수의 모양을 결정한다.</strong></li><li>결정된 확률변수로부터 다음에 생성될 데이터나 데이터 특성을 예측한다.</li></ul></li><li>3번째 과정을 역설계라고 하고, 가장 중요한 부분이다.</li><li>역설계의 방법은 여러가지가 있는데 그중에서, 데이터 분포가 가지는 표본평균, 표본분산등의 기술통계값을 구해서, 이같은 기술통계값을 가지느 확률변수의 확률분포함수를 찾는다.</li></ul><h2 id="이산확률변수">이산확률변수</h2><ul><li>확률변수의 값이 연속적이지 않고 떨어져 있도록 정의할수 있으면 <strong>이산확률변수</strong>라고 한다.</li><li>주사위를 던졌을때 나오는 숫자는 연속적이지 않은 1부터 6까지의 숫자이다.</li><li>이때 주사위는 1부터 6까지의 표본을 출력해 내는 이산확률변수라고 할수 있다.</li></ul><h2 id="연속확률변수">연속확률변수</h2><ul><li>주사위가 아닌 원반의 각도처럼 연속적이고 무한대의 실수 표본값을 가지는 확률변수를 <strong>연속확률변수</strong>라고 한다.</li><li>모든 표본이 실수인 숫자로 변한다면 확률이 어떻게 할당되었는지 나타내는 정보인 확률분포를 확률분포함수로 나타낼수 있다. ## 확률변수를 이용한 데이터 분석</li></ul><ol type="1"><li>데이터 수집 및 전처리</li><li>수집한 데이터를 임의의 확률변수의 표본 데이터라 가정</li><li>확률변수의 확률분포함수 모양 결정 = <strong>&quot;역설계, 추정&quot;</strong></li><li>결정된 확률변수로 다음에 생성될 데이터의 특성 예측</li></ol><h2 id="확률변수의-기대값">확률변수의 기대값</h2><ul><li><span class="math inline">\(E[X]\)</span>는 범함수:함수를 받아 함수를 뱉어내는 함수</li><li>이산확률변수의 기대값은 표본공간의 원소 <span class="math inline">\(x_i\)</span>의 가중평균</li><li>연속확률변수의 기대값은 <span class="math inline">\(p(x)\)</span>를 가중치로 하여 모든 가능한 표본x를 적분한값</li></ul><h2 id="확률변수의-변환">확률변수의 변환</h2><ul><li>기존의 확률변수를 사용하여 새로운 확률변수를 만드는것</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>체육복을 빌리자</title>
      <link href="/2020/02/06/Coding-2020-02-06-set-md/"/>
      <url>/2020/02/06/Coding-2020-02-06-set-md/</url>
      
        <content type="html"><![CDATA[<h2 id="체육복-문제">체육복 문제</h2><ul><li>출처 : https://programmers.co.kr/learn/courses/30/lessons/42862</li></ul><p>점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.</p><p>전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.</p><blockquote><p>제한사항 - 전체 학생의 수는 2명 이상 30명 이하입니다. - 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. - 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. - 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. - 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.</p></blockquote><p>입출력 예 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nlostreserve    return</span><br><span class="line">5[2, 4][1, 3, 5]5</span><br><span class="line">5[2, 4][3]        4</span><br><span class="line">3[3]     [1]        2</span><br></pre></td></tr></table></figure></p><h2 id="생각해야-할-부분">생각해야 할 부분</h2><ul><li>lost와 reserve를 비교하여 중복제거(reseve 학생중에 도난맞은 학생이 있을수도 있음)</li><li>필터링한 lost와 reserve를 대조</li><li>n에서 대조후 최종 lost의 길이 만큼 빼주면 됨</li></ul><h2 id="set">set</h2><ul><li>set으로 바꿔주면 중복도 제거(조건)될뿐 아니라 연산이 가능하기 때문에, lost와 reserve에 중복된 학생들을 거를수 있었음.</li></ul><h2 id="최종">최종</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n, lost, reserve)</span>:</span></span><br><span class="line">    <span class="comment">#조건</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">30</span> <span class="keyword">or</span> <span class="number">2</span> &gt; n) <span class="keyword">or</span> (len(reserve) &lt; <span class="number">0</span> <span class="keyword">or</span> len(reserve) &gt;= n):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        set_reserve = set(reserve) - set(lost)</span><br><span class="line">        set_lost = set(lost) - set(reserve)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> set_reserve:</span><br><span class="line">            <span class="keyword">if</span> k<span class="number">-1</span> <span class="keyword">in</span> set_lost:</span><br><span class="line">                set_lost.remove(k<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> k+<span class="number">1</span> <span class="keyword">in</span> set_lost:</span><br><span class="line">                set_lost.remove(k+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n-len(set_lost)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 알고리즘 문제 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>함수</title>
      <link href="/2020/02/05/python-2020-02-05-python-function-md/"/>
      <url>/2020/02/05/python-2020-02-05-python-function-md/</url>
      
        <content type="html"><![CDATA[<h1 id="함수">함수</h1><p>반복되는 코드를 묶음으로 효율적인 코드를 작성하도록 해주는 기능입니다. <a id="more"></a></p><h2 id="함수의-선언과-호출">함수의 선언과 호출</h2><blockquote><p>함수의 선언 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(point)</span>:</span>    </span><br><span class="line">    <span class="keyword">if</span> point &gt;= <span class="number">90</span>:</span><br><span class="line">        print(<span class="string">'A'</span>)</span><br><span class="line">    <span class="keyword">elif</span> point &gt;= <span class="number">80</span>:</span><br><span class="line">        print(<span class="string">'B'</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        print(<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure> 함수의 호출 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grade(<span class="number">88</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># B</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="파라미터와-아규먼트">파라미터와 아규먼트</h2><blockquote><p>파라미터 : 함수를 선언할때 호출하는 부분에서 보내주는 데이터를 받는 변수 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(num1,num2,num3=<span class="number">5</span>)</span>:</span> </span><br><span class="line">    <span class="comment">#디폴트 파라미터 (= 파라미터 값이 안들어 오면 디폴트로 10을 넣어라)</span></span><br><span class="line">    print(num1+num2-num3)</span><br></pre></td></tr></table></figure> 아규먼트 : 함수를 호출할때 함수에 보내주는 데이터 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plus(<span class="number">2</span>,<span class="number">2</span>,num3=<span class="number">15</span>) <span class="comment">#키워드 아규먼트 (=호출할때 값을 지정)</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="리턴">리턴</h2><p>함수를 실행한 결과를 저장하고 싶을때 사용합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(num1,num2)</span>:</span></span><br><span class="line">    print(num1 + num2)</span><br><span class="line">    <span class="keyword">return</span> num1 + num2 <span class="comment">#함수를 실행한 결과를 저장하고 싶을때 사용</span></span><br><span class="line"></span><br><span class="line">result = plus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p><h2 id="argskwargs"><code>*args</code>,<code>**kwargs</code></h2><p>함수를 호출할때 아규먼트와 키워드 아규먼트의 갯수를 특정지을수 없을때 사용합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    print(type(args),args)</span><br><span class="line">    print(type(kwargs),kwargs)</span><br><span class="line">    <span class="keyword">return</span> list(args) + list(kwargs.values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">minus(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,디=<span class="string">"d"</span>,이=<span class="string">"e"</span>)</span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt; ('a', 'b', 'c')</span></span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt; &#123;'디': 'd', '이': 'e'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure> &gt; <code>*args</code>는 아규먼트를 튜플로 저장 &gt; <code>**kwargs</code> 는 dict로 저장(키=밸류 형태로 저장)</p><h2 id="docstring">Docstring</h2><p>함수의 설명을 작성합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    echo func return its input argument</span></span><br><span class="line"><span class="string">    The opertation is :</span></span><br><span class="line"><span class="string">        1. print msg</span></span><br><span class="line"><span class="string">        2. return msg parameter</span></span><br><span class="line"><span class="string">    param : msg : str</span></span><br><span class="line"><span class="string">    return : str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure> &gt; 주피터 노트북에서 <code>echo?</code>매직 명령어로 함수의 설명을 볼수 있습니다. &gt; <code>print(echo.__doc__)</code>로도 설명을 볼수 있습니다.</p><h2 id="scope-범위">Scope 범위</h2><p>함수 안에서 선언되는 변수와 함수 밖에서 선언되는 변수의 범위가 다릅니다. &gt; lobal(전역),local(지역) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global</span></span><br><span class="line">gv = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">()</span>:</span></span><br><span class="line">    print(gv)</span><br><span class="line">    </span><br><span class="line">echo()</span><br><span class="line"></span><br><span class="line"><span class="comment">#10</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#local</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">()</span>:</span>    </span><br><span class="line">    <span class="keyword">global</span> gv</span><br><span class="line">    gv = <span class="number">100</span> </span><br><span class="line">    print(gv)</span><br><span class="line">    </span><br><span class="line">echo()</span><br><span class="line">gv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure></p><h2 id="inner-function">Inner Function</h2><p>함수가 지역영역에서 선언됩니다. 함수안에 함수가 선언되는 개념입니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(c,d)</span>:</span> <span class="comment">#2.실행</span></span><br><span class="line">        <span class="keyword">return</span> c + d</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner(a,b) <span class="comment">#1.inner(a,b)를 호출 # 3.결과값 보내줌 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행</span></span><br><span class="line">outer(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p><blockquote><p>callback function : 함수를 아규먼트, 파라미터로 설정해서 사용 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(func,a,b)</span>:</span></span><br><span class="line">    <span class="comment"># code</span></span><br><span class="line">    a **= <span class="number">2</span></span><br><span class="line">    b **= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> func(a,b)</span><br><span class="line"><span class="comment"># plus,1,2 라는 변수들을 받아서 각각 func,a,b에 대입, a랑 b제곱 해주고 그 값을 리턴 부분에 func(a,b)에 대입후 실행</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">calc(plus,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="map-filter-reduce">map, filter, reduce</h2><blockquote><p><code>map</code> : 순서가 있는 데이터 집합에서 모든 값에 함수를 적용시킨 결과 <code>map(func,*args(iterable 데이터 : list,tuple))</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls = range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd_even_test</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"홀수"</span> <span class="keyword">if</span> num % <span class="number">2</span> <span class="keyword">else</span> <span class="string">"짝수"</span></span><br><span class="line"></span><br><span class="line">print(odd_even_test(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 짝수</span></span><br><span class="line"></span><br><span class="line">print(list(map(odd_even_test,ls)))</span><br><span class="line"><span class="comment"># ['홀수', '짝수', '홀수', '짝수', '홀수', '짝수', '홀수', '짝수', '홀수']</span></span><br></pre></td></tr></table></figure> <code>filter</code> : 리스트 데이터에서 특정 조건에 맞는 value만 남기는 함수 <code>filter(True,False만 리턴받는 함수, iternable 데이터 하나만)</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1~10까지 홀수만 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filter는 리스트 데이터에서 특정 조건에 맞는(=즉 % 2해서 True를 만족하는 데이터들)것만 남기는 함수</span></span><br><span class="line"><span class="comment"># "filter는 True나 False 만 리턴 받는 함수"</span></span><br><span class="line">datas = range(<span class="number">10</span>)</span><br><span class="line">list(filter(<span class="keyword">lambda</span> data: <span class="literal">True</span> <span class="keyword">if</span> data % <span class="number">2</span> <span class="keyword">else</span> <span class="literal">False</span> ,datas))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure> <code>reduce</code> : 리스트 데이터를 처음부터 순서대로 특정 함수를 실행하여 결과를 누적시켜 주는 함수 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">ls = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">reduce(<span class="keyword">lambda</span> x,y: x+y,ls)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="decorator">Decorator</h2><p>함수에서 코드를 바꾸지 않고 기능을 추가하거나 수정하고 싶을때 사용하는 문법입니다.</p><blockquote><p>데코레이터 생성 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    result = a + b </span><br><span class="line">    print(<span class="string">"result : &#123;&#125;"</span>.format(result))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    result = a - b </span><br><span class="line">    print(<span class="string">"result : &#123;&#125;"</span>.format(result))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"start"</span>)</span><br><span class="line">        result = func(*args,**kwargs)</span><br><span class="line">        print(<span class="string">"result : &#123;&#125;"</span>.format(result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure> 데코레이터 적용 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a 데코레이터 쓰면 disp가 리턴하는 함수로 바뀐다</span></span><br><span class="line"><span class="meta">@disp</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    result = a + b <span class="comment">#code_2</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">plus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># start</span></span><br><span class="line"><span class="comment"># result : 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 함수 </tag>
            
            <tag> 파라미터와 아규먼트 </tag>
            
            <tag> Docstring </tag>
            
            <tag> Scope </tag>
            
            <tag> Inner function </tag>
            
            <tag> map, filter, reduce </tag>
            
            <tag> Decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>조건문, 반복문</title>
      <link href="/2020/02/04/python-2020-02-04-python-condition-loop-md/"/>
      <url>/2020/02/04/python-2020-02-04-python-condition-loop-md/</url>
      
        <content type="html"><![CDATA[<h1 id="조건문">조건문</h1><p>특정 조건에 따라서, 코드를 실행하고자 할때 사용합니다. <a id="more"></a></p><h3 id="if-else-elif">if, else, elif</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#조건부분에 bool 데이터 타입 이외의 데이터 타입이 오면 bool로 형변환 되어 판단</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">False</span> :</span><br><span class="line">    print(<span class="string">'python'</span>)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">'done'</span>)</span><br><span class="line"><span class="comment"># done</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">2</span> :</span><br><span class="line">    print(<span class="string">'홀수'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'짝수'</span>)</span><br><span class="line"><span class="comment"># 홀수</span></span><br></pre></td></tr></table></figure><blockquote><p>정반대의 조건 이면 else, 그게 아니면 elif를 사용합니다. elif를 만족하면 조건문을 빠져 나옵니다. 즉 아래쪽의 코드를 실행하지 않습니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 지갑에 돈이 10000원 이상 있으면 택시를 타고</span></span><br><span class="line"><span class="comment"># 그리고 5000원 이상, 10000원 미만이 있으면 버스를 탑니다.</span></span><br><span class="line"><span class="comment"># 그렇지 않으면 걸어 갑니다.</span></span><br><span class="line">money = <span class="number">2000</span></span><br><span class="line"><span class="keyword">if</span> money &gt;= <span class="number">10000</span>:</span><br><span class="line">    print(<span class="string">'택시를 타고 집에 간다.'</span>)</span><br><span class="line"><span class="keyword">elif</span> money &gt;= <span class="number">5000</span>:</span><br><span class="line">    print(<span class="string">'광역 버스를 타고 집에 간다.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'걸어서 집에 갑니다.'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="반복문">반복문</h1><p>반복되는 코드를 실행할때 사용합니다.</p><h3 id="while">while</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while</span></span><br><span class="line">data = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> data: <span class="comment">#조건이 False가 될때까지 구문의 코드를 실행</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#반복되는 코드</span></span><br><span class="line">    print(data)</span><br><span class="line">    data -=<span class="number">1</span>  </span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h3 id="for">for</h3><p>iterable한 값을 하나씩 꺼내서 variable에 대입 시킨후 코드를 iterable변수의 값 갯수 만큼 실행합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &lt;variable&gt; in &lt;iterables&gt;:</span><br><span class="line">    &lt;code&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for를 이용하여 코드를 100번 실행</span></span><br><span class="line"><span class="comment"># range 함수 : iterable한 데이터 타입을 만듦</span></span><br><span class="line">list(range(<span class="number">100</span>))</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    result += data</span><br><span class="line">result</span><br></pre></td></tr></table></figure><blockquote><p>continue : 조건부분으로 올라가서 코드가 실행됩니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#짝수만 출력하는 식</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> ls : </span><br><span class="line">    <span class="keyword">if</span> data % <span class="number">2</span> : <span class="comment"># data가 홀수가 되면 continue를 실행, </span></span><br><span class="line">                  <span class="comment"># %2했을 때 나머지 0 되면 False 밑에 있는 코드 실행</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#data가 짝수이면 print를 실행, 끝에 ' '추가</span></span><br><span class="line">    print(data,end = <span class="string">" "</span>)</span><br><span class="line"><span class="comment"># 2 4 6</span></span><br></pre></td></tr></table></figure> 연습문제 1 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subjects = [<span class="string">"korean"</span>,<span class="string">"english"</span>,<span class="string">"math"</span>]</span><br><span class="line">scores = [<span class="number">80</span>,<span class="number">90</span>,<span class="number">100</span>]</span><br><span class="line"><span class="comment"># for문에서 iterable 데이터가 tuple로 나오면 여러개 변수로 받을수 있습니다.</span></span><br><span class="line"><span class="comment"># subjects, scores 각각 list데이터를 zip으로 묶은다음 받아줄 각각 받아줄 변수 2개를 설정</span></span><br><span class="line"><span class="keyword">for</span> subject,point <span class="keyword">in</span> zip(subjects,scores): </span><br><span class="line">    print(subject,point)</span><br><span class="line"><span class="comment">#zip 같은 인덱스 끼리 튜플로 묶어줌, 튜플이 구성되어 있는 안의 요소 개수 만큼 변수 받아 줘야 합니다.</span></span><br></pre></td></tr></table></figure> 연습문제 2 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num2 <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> num1 <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">"&#123;&#125;*&#123;&#125;=&#123;&#125; "</span>.format(num1,num2,num1*num2),end=<span class="string">"\t"</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="list-comprehention">list comprehention</h3><p>리스트 데이터를 만들어주는 방법입니다. for문 보다 빠르게 동작합니다 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">ls2 = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>]</span><br><span class="line"></span><br><span class="line">result = [data**<span class="number">2</span> <span class="keyword">for</span> data <span class="keyword">in</span> ls]</span><br><span class="line">result</span><br><span class="line">result2 = &#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> zip(ls,ls2)&#125;</span><br><span class="line">print(result, result2)</span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36] &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f'&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 조건문 </tag>
            
            <tag> 반복문 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>결합확률, 조건부확률, 베이즈정리</title>
      <link href="/2020/02/04/TIL-mathematics-2020-02-04-probability-md/"/>
      <url>/2020/02/04/TIL-mathematics-2020-02-04-probability-md/</url>
      
        <content type="html"><![CDATA[<h2 id="결합확률joint-probability">결합확률(joint probability)</h2><ul><li>사건 <span class="math inline">\(A\)</span>와 사건 <span class="math inline">\(B\)</span>가 동시에 발생할 확률, 즉 <span class="math inline">\(A\)</span>도 진실이고, <span class="math inline">\(B\)</span>도 진실이므로 사건 <span class="math inline">\(A\)</span>와 <span class="math inline">\(B\)</span>의 교집합의 확률을 계산하는 것과 같다.<p align="center">$ P(A B) or P(A,B) $</p><a id="more"></a></li></ul><h2 id="주변확률marginal-probability">주변확률(marginal probability)</h2><ul><li>결합확률과 대비되는 개념으로 결합되니 않는 개별 사건의 확률<p align="center">$ P(A) , P(B)$</p></li></ul><h2 id="조건부확률conditional-probability">조건부확률(conditional probability)</h2><ul><li>B가 사실일 경우의 사건 A에 대한 확률을 <strong>사건 B에 대한 사건 A의 조건부확률</strong> 이라고 한다.<p align="center">$ P(A|B)$</p></li><li><p>조건부 확률의 값은 다음처럼 정의한다<br><span class="math display">\[ P(A|B) = {P(A,B) \over P(B)} \]</span></p><ul><li>사건 <span class="math inline">\(B\)</span>가 사실이므로 모든 가능한 표본은 사건 <span class="math inline">\(B\)</span>에 포함되어야 한다. 즉, 새로운 실질적 표본공간은 <span class="math inline">\(\Omega_{new} \rightarrow B\)</span> 가 된다.</li><li>사건 <span class="math inline">\(A\)</span>의 원소는 모두 사건 <span class="math inline">\(B\)</span>의 원소도 되므로 사실상 사건 <span class="math inline">\(A \cap B\)</span>의 원소가 된다. 즉, 새로운 실질적 <span class="math inline">\(A_{new} \rightarrow A \cap B\)</span>가 된다.</li><li>따라서 사건 <span class="math inline">\(A\)</span>의 확률 즉, 신뢰도는 원래의 신뢰도(결합확률)를 새로운 표본공간의 신뢰도(확률)로 정규화(normalize)한 값이라고 할 수 있다. <span class="math display">\[P(A|B)= {P(A_{new}) \over {P(\Omega_{new})}} = {P(A,B) \over P(B)}\]</span></li></ul></li></ul><h2 id="독립independent">독립(independent)</h2><ul><li>사건 A와 사건 B의 결합확률의 값이, P(A,B) = P(A) * P(B)이면, <strong>A와 B는 독립</strong>이다<p align="center"><span class="math inline">\(P(A,B) = P(A)P(B)\)</span></p></li><li>독립인 경우 조건부 확률과 원래의 확률이 같아진다. 즉 <span class="math inline">\(B\)</span>라는 사건이 발생하건 말건 사건 <span class="math inline">\(A\)</span>는 전혀 영향을 주지 않는다.</li></ul><p align="center"><span class="math inline">\(P(A|B) = {P(A,B) \over P(B)} = {P(A)P(B) \over P(B)} = P(A)\)</span></p><ul><li>조건부 확률 <span class="math inline">\(P(A|B)\)</span>에서 사건 <span class="math inline">\(B,A\)</span>는 각각<ul><li>'가정과 그 가정에 따른 조건부 결론'</li><li>'원인과 결과'</li><li>'근거와 추론' 으로 생각할수 있다.</li></ul></li><li>결합확률의 정의를 바꿔쓰면<p align="center">$ P(A,B) = P(A|B)P(B)$</p></li></ul><blockquote><p>$ A,B$가 모두 발생할 확률은 $ B$라는 사건이 발생할 확률과 그 사건이 발생한 경우 다시 $ A$가 발생할 경우의 곱이다.</p></blockquote><h2 id="사슬법칙chain-rule">사슬법칙(chain rule)</h2><ul><li>조건부확률과 결합확률의 관계를 확장한 법칙</li></ul><h2 id="확률변수random-variable">확률변수(random variable)</h2><ul><li>확률적인 숫자값을 출력하는 변수, 정확히 어떤 숫자가 나올지 예측할수는 없는 기계</li></ul><h2 id="베이즈정리bayesian-rule">베이즈정리(Bayesian rule)</h2><p align="center"><span class="math display">\[ P(A|B) = {P(B|A)P(A) \over {P(B)}}\]</span></p><ul><li>$ P(A|B)$: 사후확률(posterior) - 사건 $ B$가 발생한 후 갱신(업데이트)된 사건 A의 확률</li><li>$ P(B|A)$ : 가능도(likelihood) - 사건 $ A$가 발생한 경우 $ B$의 확률</li><li>$ P(A)$ : 사전확률(prior) - 사건 $ B$가 발생하기전에 가지고 있던 사건 A의 확률</li><li>$ P(B)$ : 정규화상수(normaliziong constant) 또는 증거(evidence) - 확률의 크기 조정</li></ul><h2 id="베이즈-정리의-확장-1">베이즈 정리의 확장 1</h2><ul><li>정규화상수는 같은 값이 되므로, 사후확률은 가능도와 사전확률의 곱에 비례한다. 따라서 사건을 비교할때는, 분모를 제외하고 비교한다.</li><li><p>사건 $ A_i$가 서로 배타적이고 완전하다고 하면</p><p align="center">$ P(A_1 | B) P(B|A_1)P(A_1)$</p><ul><li><p>단순히 사건 $ A_1, A_2, A_3$ 등을 서로 비교만 할거라면 분모(정규화 상수)와 상관없이 분자의 값만 비교하면 된다</p></li><li><p>$ A_1 = A, A_2 = A^c$인 경우에는</p></li></ul><p align="center"><span class="math display">\[ P(A|B) = {P(B|A)P(A) \over {P(B|A)P(A) + P(B|A^c)(1 - P(A))}}\]</span></p></li></ul><h2 id="베이즈-정리의-확장2">베이즈 정리의 확장2</h2><ul><li><p>베이즈 정리는 사건 $ A$의 확률이 사건 $ B$에 의해 갱신된 확률을 계산한다. 그런데 이 상태에서 또 추가적인 사건 $ C$가 발생했다면 베이즈 정리는</p><p align="center"><span class="math display">\[P(A|B,C) = {P(C|A,B)P(A|B) \over {P(C|B)}}\]</span></p></li><li>위 식에서 $ P(A|B,C)$ 는 $ B$와 $ C$ 가 조건인 $ A$ 의 확률이다. 즉 $ P (A|(BC))$ 를 뜻한다.</li><li>공동전제를 제거 혹은 추가가 가능하기 떄문에, 위 식을 <span class="math display">\[ P(A|C) = P(C|A)P(A) \over P( C ) \]</span>로 바꿀수 있다.</li><li>제거후 베이즈 정리가 성립되면 Ok!</li><li><p>몬티홀 문제 풀이에 활용</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>확률</title>
      <link href="/2020/02/03/TIL-mathematics-2020-02-03-optimization-probability-md/"/>
      <url>/2020/02/03/TIL-mathematics-2020-02-03-optimization-probability-md/</url>
      
        <content type="html"><![CDATA[<h2 id="확률">확률</h2><a id="more"></a><ul><li>확률이란 사건(표본공간의 부분집합)을 입력으로 받는 함수!</li><li>확률의 정의역은 표본공간의 가능한 모든 부분집합</li><li>표본공간 : 가능한 모든 표본의 집합</li><li>사건 : 부분집합</li><li><strong>콜모고로프의 공리</strong><ul><li>모든 사건에 대해 확률은 실수이고 0또는 양수다<p align="center">$P(A) 0 $</p></li><li>표본공간(전체집합)이라는 사건(부분집합)에 대한 확률은 1이다.<p align="center"><span class="math inline">\(p(\Omega) = 1\)</span></p></li><li>공통 원소가 없는 두 사건의 합집합의 확률은 사건별 확률의 합이다.<p align="center">$A B = P(A B) = P(A) + P(B) $</p></li></ul></li></ul><h2 id="확률의-의미">확률의 의미</h2><ul><li><strong>확률이란 사건(부분집합)을 입력하면 숫자(확률값)이 출력되는 함수다.</strong></li><li><strong>빈도주의적 관점</strong><ul><li><strong>반복적으로 선택된 표본이 사건</strong>(부분 집합) <strong>A의 원소가될 경향</strong>을 사건의 확률이라고 본다.</li></ul></li><li><strong>베이지안 관점</strong><ul><li><strong>선택된 표본이 특정한 사건(부분 집합)에 속한다는 가설(hypothesis), 명제(proposition) 혹은 주장(assertion)</strong> 의 <strong>신뢰도(degree of belief)</strong></li><li>베이지안 관점에서 사건이 일어났다(occur) 혹은 발생했다하는 말은 그 사건(부분집합)의 원소 중에 정말로 선택된 표본이 있다는 사실을 알게 되었다는 것을 말한다.</li></ul></li></ul><h2 id="확률의-성질">확률의 성질</h2><ol type="1"><li><strong>공집합의 확률</strong> : <strong>공집합의 확률은 0이다</strong><p align="center">$P() = 0 $</p></li><li><strong>여집합의 확률</strong> : <strong>어떤 사건의 여집합인 사건의 확률은 (1 - 원래 사건의 확률)과 같다.</strong><p align="center">$ P(A^c) = 1 - P(A) $ , $ 0 P(A) 1$</p></li><li><strong>포함-배제원리</strong> : 두사건의 합집합의 확률은 각 사건의 확률의 합에서 두 사건의 교집합의 확률을 뺸것과 같다<p align="center">$ P(A B) = P(A) + P(B) - P(AB) $</p></li><li><strong>전체확률의 법칙</strong><br>복수의 사건 <span class="math inline">\(C_{i}\)</span>가 다음을 만족하는 사건들이라고 가정한다.</li></ol><ul><li>서로 교집합이 없다. 서로 배타적이다.<p align="center">$ C_iC_j = $</p></li><li>모든 집합의 합집합이 전체집합이다.<p align="center">$ C_1C_2 = $</p></li></ul><p>이경우</p><blockquote><p><strong>사건 A의 확률은 사건 A와 사건 <span class="math inline">\(C_i\)</span>가 동시에 발생할 사건들의 확률의 합과 같다.</strong> $ P(A) = _{i} P(A C_i)$</p></blockquote><h2 id="확률-분포-함수">확률 분포 함수</h2><ul><li><strong>확률질량함수(PMF)</strong> : 유한개의 사건이 존재하는 경우 각 단순사건에 대한 확률만 정의하는 함수<p align="center">$ p(1) = 0.2 P({1})=0.2$</p></li><li><strong>누적분포함수(CDF)</strong>: 무한개의 사건이 존재하는 경우, 시작점을 <span class="math inline">\(-\infty\)</span>로 고정하고 통일된 특수구간을 사용하는 함수<ul><li>음의 무한대에 대한 누적분포함수값은 0이다<p align="center">$ F(-) = 0 $</p></li><li>양의 무한대에 대한 누적분포함수값은 1이다.<p align="center">$ F(+) = 1$</p></li><li>입력이 크면 누적분포함수값은 같거나 커진다.<p align="center">$ x y F(x)F(y)$</p></li><li>단조증가 성질에 따라 절대 내려가지 않는다.</li></ul></li><li><strong>확률밀도함수(PDF)</strong>: 누적분포 함수를 미분하여 구한 도함수, 어떤 확률 변수값이 더 자주 나오는지에 대해 잘 파악할수 있다.<ul><li>누적분포함수의 기울기가 음수가 될수 없기 때문에(단조증가 성질, 절대 값이 내려가지 않기 때문에) pdf는 0보다 같거나 크다.<p align="center">$ p(x) 0$</p></li><li><span class="math inline">\(-\infty\)</span>부터 <span class="math inline">\(\infty\)</span>까지 적분하면 표본공간의 확률이 되므로 값은 1이다.<p align="center">$ ^{-}_{}p(u)du = 1$$</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 확률 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>집합</title>
      <link href="/2020/02/01/TIL-mathematics-2020-02-01-set-md/"/>
      <url>/2020/02/01/TIL-mathematics-2020-02-01-set-md/</url>
      
        <content type="html"><![CDATA[<h2 id="집합">집합</h2><a id="more"></a><ul><li>집합<ul><li>set : mutable, 리스트, 딕셔너리와 같이 수정이 가능(딕셔너리의 key값이 될수 없는 자료형)</li><li>frozenset : immutable, 튜블과 같이 수정이 불가능</li></ul></li><li>집합의 크기<ul><li>len()</li></ul></li><li>합집합과 교집합</li><li>union() 매서드 혹은 | : 합집합</li><li>intersection() 매서드 혹은 &amp; : 교집합</li><li>전체집합, 부분집합, 여집합</li><li>부분 집합 : issubset(), True 나 False를 반환</li><li>차집합과 여집합</li><li>differencd(), -</li><li>부분집합</li><li>합집합과 교집합의 분배 법칙</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 기본 문법_03</title>
      <link href="/2020/01/31/python-2020-01-31-python-basic-syntax03-md/"/>
      <url>/2020/01/31/python-2020-01-31-python-basic-syntax03-md/</url>
      
        <content type="html"><![CDATA[<h1 id="컬렉션-데이터-타입">컬렉션 데이터 타입</h1><p>컬렉션 데이터 타입에는 list, tuple, dict등이 있습니다. <a id="more"></a></p><h2 id="리스트list--">리스트(list) - [ ]</h2><p>&quot;순서&quot;가 있는 수정이 가능한 데이터 타입 입니다.</p><h4 id="리스트-자료형의-매서드">리스트 자료형의 매서드</h4><blockquote><p><strong>.append( ): 리스트의 맨 뒤에 값을 추가</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">ls.append(<span class="number">3</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1,4,2,4,3</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>.sort( ) : 오름차순으로 정렬</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls.sort()</span><br><span class="line"><span class="comment"># 내림차순 정렬</span></span><br><span class="line">ls[::<span class="number">-1</span>]</span><br><span class="line">ls.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5,4,3,2,1</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>.pop( ) : 맨 뒤의 값을 떼어냄</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = ls.pop()  <span class="comment"># 리스트 맨뒤의값 떼어내는 함수</span></span><br><span class="line">print(num, ls)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1, [5,4,3,2]</span></span><br></pre></td></tr></table></figure></p></blockquote><h4 id="깊은-복사-vs-얕은-복사">깊은 복사 vs 얕은 복사</h4><blockquote><p><strong>얕은 복사</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ls2 = ls1 </span><br><span class="line">print(ls1, ls2)</span><br><span class="line"><span class="comment"># [1,2,3],[1,2,3]</span></span><br><span class="line">ls1[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment"># [1,2,5],[1,2,5]</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>깊은 복사</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls3 = ls1.copy()</span><br><span class="line"><span class="comment"># 새로운 저장공간을 만들어서 ls1에 들어있던 [1,2,5]를 ls3 에 저장 : 깊은 복사</span></span><br><span class="line">ls1, ls3</span><br><span class="line"><span class="comment"># [1,2,3],[1,2,3]</span></span><br><span class="line">ls1[<span class="number">2</span>] = <span class="number">10</span></span><br><span class="line">ls1, ls3</span><br><span class="line"><span class="comment"># [1,2,10],[1,2,5]</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="튜블tuple--">튜블(tuple) - ( )</h3><p>순서가 있는 수정이 불가능한 데이터 타입 입니다. 튜플은 리스트 보다 같은 데이터를 가졌을때 공간을 적게 사용 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tp1 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">tp2 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">#괄호가 없어도 가능</span></span><br><span class="line">print(type(tp1), type(tp2), tp1, tp2)</span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt;, &lt;class 'tuple'&gt;, (1, 2, 3), (4, 5, 6)</span></span><br></pre></td></tr></table></figure> ## <em>Offset index</em><br>데이터에서 특정 위치의 데이터를 출력할때 사용합니다. 마스크, 혹은 마스킹 이라고도 합니다.</p><pre><code>[idx] : idx 위치 데이터를 출력합니다. (인덱스는 0부터 시작)[start:end] : start에서 end까지 출력(end는 미포함)[start:end:stride] : stride만큼씩 점프하여 출력<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="string">"abcdefg"</span></span><br><span class="line">g[<span class="number">2</span>], g[<span class="number">-2</span>], g[<span class="number">2</span>:<span class="number">5</span>], g[:<span class="number">2</span>], g[<span class="number">3</span>:], g[<span class="number">-2</span>:], g[::<span class="number">3</span>], g[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'c', 'f', 'cde', 'ab', 'defg', 'fg', 'adg', 'gfedcba'</span></span><br><span class="line"></span><br><span class="line">numbers = <span class="string">"123456789"</span>  <span class="comment"># 97531로 출력하고자 한다면</span></span><br><span class="line">numbers[::<span class="number">2</span>][::<span class="number">-1</span>] <span class="comment"># [::-1]은 역수</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 97531</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="딕셔너리dict--">딕셔너리(dict) -</h2><p>순서가 없고, key : value 로 구성되어 있는 데이터 타입입니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 선언 : 키는 정수(실수도 가능), 문자열 데이터 타입만 사용이 가능</span></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">    <span class="string">"two"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"three"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># &#123;1: 'one', 'two': 2, 'three': [1, 2, 3]&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic[<span class="number">1</span>], dic[<span class="string">"three"</span>]  <span class="comment"># 인덱스로는 못부름, 키를 정확히 입력해야 값을 찾을수 있음</span></span><br><span class="line">dic[<span class="string">"four"</span>] = <span class="number">1234</span>  <span class="comment"># 키로 찾아서 새로운 값을 넣어줌,혹은 새로운 키값에 밸류 추가 가능</span></span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># &#123;1: 'one', 'two': 2, 'three': [1, 2, 3], 'four': 1234&#125;</span></span><br></pre></td></tr></table></figure><h2 id="형변환">형변환</h2><p>이미 변수에 설정된 데이터 타입을 변경하는 행위입니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="string">"2"</span></span><br><span class="line">print(a + int(b))</span><br><span class="line">print(str(a) + b)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure></p><h2 id="연산자">연산자</h2><blockquote><p>산술연산자 : +, -, *, /, //(몫), %(나머지), <strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span> + <span class="number">4</span> / <span class="number">2</span> ** <span class="number">2</span></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># 2.0</span></span><br></pre></td></tr></table></figure> 할당연산자 : 변수에 누적시켜서 연산 : +=, //=, </strong>=, ... <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">a = a + <span class="number">10</span></span><br><span class="line">a = a + <span class="number">10</span></span><br><span class="line">a += <span class="number">10</span></span><br><span class="line">a += <span class="number">10</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 50</span></span><br></pre></td></tr></table></figure> 비교연산자 : &gt;, &lt;, ==, !=, &lt;=, &gt;= : 결과로 True,False <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(a, b)</span><br><span class="line">print(a &lt; b, a == b, a != b)</span><br><span class="line"><span class="comment"># 50, 2.0</span></span><br><span class="line"><span class="comment"># False, True, True</span></span><br></pre></td></tr></table></figure> 논리연산자 : True,False 를 연산 : or,and,not <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 논리연산</span></span><br><span class="line"><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>, <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>, <span class="keyword">not</span> (</span><br><span class="line">    <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">True</span>), <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">True</span>  <span class="comment"># 왼쪽부터 연산. 괄호안 먼저</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (False, True, False, True)</span></span><br></pre></td></tr></table></figure> 멤버연산자 : 특정 데이터가 있는지 확인할때 사용 : not in, in <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 멤버연산</span></span><br><span class="line">ls = [<span class="string">"jin"</span>, <span class="string">"andy"</span>, <span class="string">"john"</span>]</span><br><span class="line"><span class="string">"andy"</span> <span class="keyword">in</span> ls  <span class="comment"># andy가 ls에 있냐?</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="string">"howard"</span> <span class="keyword">in</span> ls  <span class="comment"># howard가 ls에 있냐?</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure> 연산자 우선순위 : 산술 &gt; 비교 &gt; 멤버 &gt; 논리</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 컬렉션 데이터 타입 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>최적화 문제란?</title>
      <link href="/2020/01/31/TIL-mathematics-2020-01-31-optimization-md/"/>
      <url>/2020/01/31/TIL-mathematics-2020-01-31-optimization-md/</url>
      
        <content type="html"><![CDATA[<h2 id="최적화-문제">최적화 문제</h2><a id="more"></a><ul><li>목적함수의 값을 최대화 혹은 최소화 하는 변수 x의 값을 찾는것 <span class="math display">\[ x^{\ast} = \arg \max_x f(x) \]</span> <span class="math display">\[ x^{\ast} = \arg \min_x f(x) \]</span></li><li>최소화하려는 함수 <span class="math inline">\(f(x)\)</span>를 <strong>목적함수</strong>(objective function), <strong>비용함수</strong>(cost function), <strong>손실함수</strong>(loss function) <strong>오차함수</strong>(error function) 등으로 부른다</li></ul><h2 id="그리드-서치">그리드 서치</h2><ul><li>목적함수의 값을 찾는 가장 쉽고 단순한 방법은, 값을 여러개 넣어보고 가장 작은 값을 찾아내면 된다. 이런 방법을 그리드 서치라 한다.</li></ul><h2 id="수치적-최적화">수치적 최적화</h2><ul><li><strong>기울기 필요조건</strong> : 최저점에서는 기울기가 항상 0이다.</li><li><strong>최대경사법</strong> <span class="math display">\[x_{k+1} = x_{k} - \mu \nabla f(x_k) = x_{k} - \mu g(x_k) \]</span><ul><li>현재 위치 <span class="math inline">\(x_k\)</span>에서의 기울기 <span class="math inline">\(g(x_k)\)</span>를 이용하여 다음번 위치 <span class="math inline">\(x_{k+1}\)</span>의 위치를 찾는 방법이다.</li><li>스텝사이즈(혹은 학습률) <span class="math inline">\(\mu\)</span>를 잘 선택해야 한다.</li><li><span class="math inline">\(x_k\)</span> 에서 기울기가 음수면 곡면이 아래로 향하고 <span class="math inline">\(g(x_k) &lt; 0\)</span>이 되므로 앞으로 진행(위로 올라감)</li><li><span class="math inline">\(x_k\)</span> 에서 기울기가 양수면 곡면이 위로 향하고 <span class="math inline">\(g(x_k) &gt; 0\)</span>이 되어 뒤로 진행하여, 점점 낮은위치로 이동한다.(최저점으로 간다)</li><li><span class="math inline">\(x_k\)</span>가 최저점에 도달하면 <span class="math inline">\(g(x_k) = 0\)</span>이 되므로, 더이상 움직이지 않는다.</li></ul></li><li><strong>진동현상</strong> : 함수 곡면의 모양이 계곡처럼 생길 경우 최저점에 도달하지 못하고 계속 움직인다.</li><li><strong>뉴턴방법</strong> : 스텝사이즈 없이, 목적 함수가 2차식이라는 가정하에 그레디언트 벡터에 해시안 행렬의 역행렬을 곱하여 한번에 최저점을 찾는다</li><li>sp.minimize(목적함수, 초깃값 벡터, 그레디언트 벡터를 출력하는 함수(옵션))</li></ul><h2 id="전역-최적화-문제">전역 최적화 문제</h2><ul><li>국소 최저점(local minima)를 가지고 있으면 수치적 최적화 방법으로는 전역 최저점(global minimum)에 도달한다는 보장은 없다.</li><li>따라서, 결과는 초기 추정값 및 알고리즘, 파라미터 등에 의존한다.</li></ul><h2 id="컨벡스-문제">컨벡스 문제</h2><ul><li>목적함수의 2차 도함수의 값이 항상 0 이상이 되는 영역에서만 정의된 최적화 문제를 컨벡스(convex) 문제라고 한다.</li><li>다변수 목적함수에선 헤시안 행렬이 항상 양의 준정부호라는 조건</li></ul><h4 id="symbol-연산">symbol 연산</h4><ul><li>미지수(x,y)등을 설정해 방정식을 연산할수 있게 하는 sympy의 기능 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = sympy.symbols(<span class="string">'x y'</span>)</span><br><span class="line">f = (<span class="number">1</span>-x)**<span class="number">2</span>+<span class="number">100</span>*(y-x**<span class="number">2</span>)**<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="다차식의-최적화">다차식의 최적화</h2><ul><li>다차식에선 그레디언트 벡터를 출력하는 함수(jac)를 설정할때 np.array로 설정해서 넣어줘야 함 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#함수 정의</span></span><br><span class="line">x1,x2,x3 = sympy.symbols(<span class="string">'x1 x2 x3'</span>)</span><br><span class="line">f = (<span class="number">1</span>-x1)**<span class="number">2</span> + (<span class="number">1</span>-x2)**<span class="number">2</span> + <span class="number">100</span>*((x2-x1**<span class="number">2</span>)**<span class="number">2</span>+ (x3-x2**<span class="number">2</span>)**<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 각 함수의 도함수를 구함</span></span><br><span class="line">sympy.simplify(sympy.diff(f,x1))</span><br><span class="line">sympy.simplify(sympy.diff(f,x2))</span><br><span class="line">sympy.simplify(sympy.diff(f,x3))</span><br><span class="line"></span><br><span class="line">sympy.simplify(sympy.diff(f,x1,x2))</span><br><span class="line">sympy.simplify(sympy.diff(f,x1,x3))</span><br><span class="line">sympy.simplify(sympy.diff(f,x2,x3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3차식에선 np.array로 x1,x2,x3에 대한 도함수 3개 다 넣어줘야 함</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>-x[<span class="number">0</span>])**<span class="number">2</span> + (<span class="number">1</span>-x[<span class="number">1</span>])**<span class="number">2</span> + <span class="number">100</span>*((x[<span class="number">1</span>]-x[<span class="number">0</span>]**<span class="number">2</span>)**<span class="number">2</span> + (x[<span class="number">2</span>]-x[<span class="number">1</span>]**<span class="number">2</span>)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array([<span class="number">400</span>*x[<span class="number">0</span>]*(x[<span class="number">0</span>]**<span class="number">2</span>-x[<span class="number">1</span>])+<span class="number">2</span>*x[<span class="number">0</span>]<span class="number">-2</span>,<span class="number">-200</span>*x[<span class="number">0</span>]**<span class="number">2</span><span class="number">-400</span>*x[<span class="number">1</span>]*(-x[<span class="number">1</span>]**<span class="number">2</span>+x[<span class="number">2</span>])+<span class="number">202</span>*x[<span class="number">1</span>]<span class="number">-2</span>,<span class="number">-200</span>*x[<span class="number">1</span>]**<span class="number">2</span> + <span class="number">200</span>*x[<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">x = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">result = sp.optimize.minimize(f,x,jac=jac2)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></li></ul><h2 id="제한-조건이-있는-최적화-문제">제한 조건이 있는 최적화 문제</h2><ul><li>&quot;등식&quot; 제한 조건이 있는 최적화 문제<ul><li>라그랑주 승수법<br></li></ul></li><li>&quot;부등식&quot; 제한 조건이 있는 최적화 문제<ul><li>KKT(karush-kuhn-Tucker)을 필요로 한다</li></ul></li></ul><h2 id="선형계획법-문제와-이차계획법-문제">선형계획법 문제와 이차계획법 문제</h2><ul><li>선형계획법 문제(Linear Programming) : 방정식 혹은 부등식 제한 조건을 가지는 &quot;선형모형&quot;의 값을 최소화 하는 문제<ul><li>sp.optimize.linprog(목적함수의 계수 벡터, 등식 제한조건의 계수행렬, 등식 제한조건의 상수 벡터)</li></ul></li><li>이차계획법 문제(Quadraic Programming) : 방정식 혹은 부등식 제한 조건을 가지는 &quot;이차형식&quot;의 값을 최소화 하는 문제</li></ul>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 최적화 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>함수 미분, 적분, 행렬 미분</title>
      <link href="/2020/01/30/TIL-mathematics-201030-function-md/"/>
      <url>/2020/01/30/TIL-mathematics-201030-function-md/</url>
      
        <content type="html"><![CDATA[<h2 id="함수">함수</h2><ul><li>함수와 변수</li><li>연속과 불연속함수</li><li>데이터분석에서 자주 등장하는 불연속함수</li><li>부호함수</li><li>단위계단함수</li><li>지시함수</li><li>역함수</li><li>다항식함수</li><li>지수함수</li><li>로지스틱함수</li><li>로그함수</li><li>소프트플러스 함수</li><li>다변수함수 &amp; 다변수 다출력 함수</li><li>함수의 평행이동 및 스케일링</li></ul><h2 id="심파이를-사용한-함수-미분">심파이를 사용한 함수 미분</h2><ul><li>최적화에 필요한 미분</li><li>기울기 : 또는 민감도</li><li>수치미분 : 대략적인 기울기 구함</li><li>미분 : 도함수를 만들어 내는 작업</li><li>도함수 : 변수를 입력했을때 그 순간의 기울기를 출력하는 함수</li><li>미분공식 5가지<ol type="1"><li>기본 미분공식 : 상수, 거듭제곱</li><li>선형조합법칙</li><li>곱셈법칙</li><li>연쇄법칙</li><li>로그함수의 연쇄법칙</li></ol></li><li>편미분 : 둘 이상의 독립변수를 가지는 다변수 함수의 미분</li><li>다변수 함수의 연쇄법칙</li><li>2차 편미분 : 편미분에 대한 2차 도함수. 각 미분에 쓰이는 독립변수를 자유롭게 사용</li><li>테일러 전개 : 함수의 기울기를 안다면, 함수의 모양 근사화 가능</li></ul><h2 id="적분">적분</h2><ul><li>미분과 반대 개념 : 도함수를 원래 함수로 돌리는 것</li><li>편미분의 부정적분 : 마지막 상수항이 C(y),C(x)처럼 함수 일수도 있음</li><li>다차 도함수와 다중적분 : x로 편미분한후 y로 편미분한 함수는, y로 적분후 x로 다시 적분해야 한다</li><li>정적분 : 독립변수 x가 [a,b]구간 사이일때, 함수 f(x)의 값과 수평선이 이르는 면적을 구하는 행위</li><li>수치적분 : 함수를 아주 작은 구간으로 나누어 실제면적 계산하는 노가다</li><li>다변수 정적분 : 입력변수가 여러개인 함수의 정적분</li><li>다차원 함수의 단일 정적분 : 결과값이 함수가 됨, x만 입력받고 y는 정해지지 않는 상수로 보기 때문</li></ul><h2 id="행렬의-미분">행렬의 미분</h2><ul><li>독립변수가 벡터나 행렬, 혹은 백터나 행렬을 출력하는 것</li><li>스칼라를 벡터로 미분하는 경우 : 결과를 열벡터로 표시하고 이를 그레디언트 벡터라고 한다<ul><li>평면상에 컨투어 플롯으로 나타내고, 그레디언트 벡터를 화살표로 나타낸것을 퀴버플롯이라 한다</li><li>그레디언트 벡터의<ol type="1"><li>크기는 기울기를 의미. 기울기가 클수록 함수 곡면의 기울기가 커진다.</li><li>방향은 함수 곡면의 기울기가 가장 큰 방향. 즉, 단위길이당 함수값(높이)가 가장크게 증가하는 방향</li><li>방향은 등고선의 방향과 직교한다</li></ol></li></ul></li><li>행렬 미분법칙</li></ul><ol type="1"><li>선형모형</li><li>이차형식</li><li>행렬과 벡터의 곱의 미분</li><li>행렬곱의 대각성분</li><li>행렬식의 로그</li></ol>]]></content>
      
      
      <categories>
          
          <category> TIL.. </category>
          
          <category> Math </category>
          
          <category> 미적분 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA</title>
      <link href="/2020/01/29/TIL-mathematics-201028-linear-algebra-function/"/>
      <url>/2020/01/29/TIL-mathematics-201028-linear-algebra-function/</url>
      
        <content type="html"><![CDATA[<h2 id="pcaprincipal-component-analysis">PCA(Principal Component Analysis)</h2><ul><li>주성분 분석</li><li>차원축소와 투영 == 특이분해의 로우-랭크 근사문제</li><li>근사 성능을 높이기 위해 원점을 지나는 조건을 삭제</li><li>쓸모있는 정보를 유지하며 더 작은차원의 벡터들로 선형변환하고자 하는것.</li><li>변환후 차원을 맞추기 위해 다시 역변환, 그리고 원래 벡터와 변환후 벡터 비교</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 기본 문법_02</title>
      <link href="/2020/01/29/python-2020-01-29-python-basic-syntax02-md/"/>
      <url>/2020/01/29/python-2020-01-29-python-basic-syntax02-md/</url>
      
        <content type="html"><![CDATA[<h1 id="데이터-타입">데이터 타입</h1><p>RAM 저장공간을 효율적으로 사용하기 위해 저장공간의 타입을 설정합니다. <a id="more"></a> 동적타이핑 : 변수 선언시 저장되는 값에 따라서 자동으로 데이터 타입이 설정됩니다. 파이썬의 특징중 하나 입니다.</p><h2 id="기본-데이터-타입-int-정수-float-실수-bool-true-혹은-false-str-문자열">기본 데이터 타입 : <em>int</em> (정수), <em>float</em> (실수), <em>bool</em> (True 혹은 False), <em>str</em> (문자열)</h2><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 기본 데이터 타입 int, float, bool, str</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1.2</span></span><br><span class="line">c = <span class="literal">True</span> <span class="comment">#False</span></span><br><span class="line">d = <span class="string">"data"</span></span><br><span class="line"><span class="comment"># 데이터 타입을 확인하는 함수 type()</span></span><br><span class="line">type(a),type(b),type(c),type(d)</span><br></pre></td></tr></table></figure></code></pre><h2 id="불리언-데이터-타입">불리언 데이터 타입</h2><p>Ture 혹은 False의 값을 가집니다. int와 flaot타입 : 0과 0.0을 제외한 나머지 값은 모두 True입니다. 문자열 : ''을 제외한 나머지 값은 모두 True입니다.</p><h2 id="문자열-자료형의-매서드">문자열 자료형의 매서드</h2><blockquote><p><strong>.upper( ) : 대문자 변환</strong></p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="string">"data"</span></span><br><span class="line">e = d.upper()</span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>.lower( ) : 소문자 변환</strong></p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = e.lower()</span><br><span class="line">print(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>.strip( ) : 공백제거</strong></p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="string">"Howard Howon Yu"</span></span><br><span class="line">h = g.strip()</span><br><span class="line">print(h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># HowardHowonYu</span></span><br></pre></td></tr></table></figure> &gt; <strong>.replace( ) : 특정 문자열 치환</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g.replace(<span class="string">"Howard"</span>,<span class="string">"하워드"</span>)</span><br><span class="line">print(g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 하워드 Howon Yu</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 데이터 타입 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>선형대수 - 문제풀이</title>
      <link href="/2020/01/29/TIL-mathematics-200129-linear-algebra/"/>
      <url>/2020/01/29/TIL-mathematics-200129-linear-algebra/</url>
      
        <content type="html"><![CDATA[<h2 id="linear-algebra">linear-algebra</h2><ul><li>고유값 분해</li><li>특이값 분해<ul><li>사진 손실 압축 방식에 활용</li></ul></li><li>PCA 분석<ul><li>데이터가 움직이는 경향을 찾는다</li><li>보스턴 집값 분석 : 데이터 별로 크기가 상이하기 떄문에, sclae맞춰주고 PCA분석</li><li>올리베티 얼굴 : 주성분에 따라, 사진이 다르게 변화함</li><li>주식가격의 PCA</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>두 정수 사이에 속한 정수의 합</title>
      <link href="/2020/01/28/Coding-array/"/>
      <url>/2020/01/28/Coding-array/</url>
      
        <content type="html"><![CDATA[<h4 id="두-정수-a-b가-주어졌을-때-a와-b-사이에-속한-모든-정수의-합을-리턴하는-함수-solution을-완성하세요.">두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.</h4><ul><li><p>예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.</p></li><li>제한 조건<ul><li>a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.</li><li>a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.</li><li>a와 b의 대소관계는 정해져있지 않습니다.</li></ul></li></ul><h4 id="해답">해답</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b: </span><br><span class="line">        a,b = b,a</span><br><span class="line">    <span class="comment"># a가 b보다 큰경우 두 값을 바꿔줬습니다.</span></span><br><span class="line">    <span class="keyword">return</span> sum(list(range(a,b+<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 알고리즘 문제 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 기본 문법_01</title>
      <link href="/2020/01/28/python-2020-01-28-python-basic-syntax/"/>
      <url>/2020/01/28/python-2020-01-28-python-basic-syntax/</url>
      
        <content type="html"><![CDATA[<h1 id="주석comment과-출력print">주석(comment)과 출력(print)</h1><a id="more"></a><p>#을 붙이면 코드로 실행이 안됩니다. 코드에 대한 설명, 혹은 중간에 코드를 실행시키고 싶지 않을때 사용합니다. 해당 라인에 커서를 옮기고, cmd(ctrl) + / 키를 누르면 주석처리 할수 있습니다.</p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  1,3을 출력하는 코드</span></span><br><span class="line">print(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># print(2)</span></span><br><span class="line">print(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></code></pre><blockquote><p><strong>print( )</strong> : 값을 출력할때 사용합니다</p></blockquote><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">print(b)</span><br><span class="line">c = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></code></pre><blockquote><p><strong>print( )</strong> 함수 옵션</p></blockquote><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1</span>,<span class="number">2</span>,sep = <span class="string">'-'</span>, end = <span class="string">'\t'</span>)</span><br><span class="line">print(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1-23</span></span><br></pre></td></tr></table></figure></code></pre><p>alt+tab 키를 눌러 docstring을 확인합니다. docsting : 함수에 대한 설명서 개념입니다. 함수를 만들때 추가하여 활용할수 있습니다. sep : 각 출력 결과물을 '-'로 구분하라는 뜻입니다. end : 출력후 끝에 tab키를 추가하라라는 뜻입니다.</p><h1 id="변수-선언">변수 선언</h1><p>RAM 저장공간에 값을 할당하는 행위입니다.</p><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure></code></pre><h1 id="식별자">식별자</h1><p>변수, 함수, 클래스, 모듈등의 &quot;이름&quot;을 식별자 라고 합니다. 식별자를 만드는 데는 규칙이 존재합니다. 1. 소문자, 대문자, 숫자, _,등을 사용합니다. 2. 가장 앞에 숫자 사용 불가합니다. 3. 예약어는 사용 불가 합니다. 예) def,class,try,except,... 4. 컨벤션을 지켜야 합니다. 이름만 보고 변수, 함수, 클래스를 구분할수 있게 하기 위해 알맞은 식별자를 지정해 줘야 합니다. snake case : fast_campus : 변수, 함수 camel case : FastCampus, fastCampus : 클래스</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 변수 선언 </tag>
            
            <tag> 식별자 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>수학 - 선형대수</title>
      <link href="/2020/01/24/TIL-mathematics-201024-linear-algebra/"/>
      <url>/2020/01/24/TIL-mathematics-201024-linear-algebra/</url>
      
        <content type="html"><![CDATA[<h2 id="essence-of-linear-algebra-by-3blue1brown-part.2">Essence of linear algebra by 3blue1brown / Part.2</h2><ul><li>크래머 공식 : 왜 전체 행렬의 행렬식 / 특정 행렬의 행렬식이 성립되는지.</li><li>선형대수학의 범용성 : 선형대수학의 실수배와 합의 &quot;8가지 공리&quot;만 만족하면 어떤 형테는 벡터로 취급할수 있다.</li><li>좌표 변환 : 기저벡터와 좌표와의 관계</li><li>선형종속, 선형독립</li><li>랭크</li><li>고유값 분해<ul><li>고유값, 고유벡터</li><li>특성방정식</li><li>고유값의 개수와 행렬식, 대각식의 연관</li><li>대각화</li><li>분산 행렬</li></ul></li><li>특이값 분해<ul><li>특이값 분해 행렬의 크기</li><li>특이값 분해의 축소형</li></ul></li><li>1차원 근사</li><li>벡터w와 점ai들 과의 거리 구하는 방법</li><li>k차원 근사<ul><li>1차원 근사에서 확장한 개념</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>수학 - 선형대수</title>
      <link href="/2020/01/23/TIL-mathematics-201023-linear-algebra/"/>
      <url>/2020/01/23/TIL-mathematics-201023-linear-algebra/</url>
      
        <content type="html"><![CDATA[<h2 id="essence-of-linear-algebra-by-3blue1brown">Essence of linear algebra by 3blue1brown</h2><ul><li>Vector</li><li>Span</li><li>Basis vector</li><li>Matric multipication as composition</li><li>Three-dimensional linear transformations</li><li>Determinant</li><li>Column space and null space</li><li>Dot products</li><li>Cross products</li><li>Eigenvectors and Eigenvalues</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
